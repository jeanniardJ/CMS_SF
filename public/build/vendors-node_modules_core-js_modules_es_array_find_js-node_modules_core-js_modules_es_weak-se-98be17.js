"use strict";
(self["webpackChunkjja_dev"] = self["webpackChunkjja_dev"] || []).push([["vendors-node_modules_core-js_modules_es_array_find_js-node_modules_core-js_modules_es_weak-se-98be17"],{

/***/ "./node_modules/@orchidjs/sifter/dist/esm/sifter.js":
/*!**********************************************************!*\
  !*** ./node_modules/@orchidjs/sifter/dist/esm/sifter.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Sifter: function() { return /* binding */ Sifter; },
/* harmony export */   cmp: function() { return /* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.cmp; },
/* harmony export */   getAttr: function() { return /* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.getAttr; },
/* harmony export */   getAttrNesting: function() { return /* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.getAttrNesting; },
/* harmony export */   getPattern: function() { return /* reexport safe */ _orchidjs_unicode_variants__WEBPACK_IMPORTED_MODULE_1__.getPattern; },
/* harmony export */   iterate: function() { return /* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.iterate; },
/* harmony export */   propToArray: function() { return /* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.propToArray; },
/* harmony export */   scoreValue: function() { return /* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.scoreValue; }
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@orchidjs/sifter/dist/esm/utils.js");
/* harmony import */ var _orchidjs_unicode_variants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @orchidjs/unicode-variants */ "./node_modules/@orchidjs/unicode-variants/dist/esm/index.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types.js */ "./node_modules/@orchidjs/sifter/dist/esm/types.js");
/**
 * sifter.js
 * Copyright (c) 2013–2020 Brian Reavis & contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 * @author Brian Reavis <brian@thirdroute.com>
 */


class Sifter {
    items; // []|{};
    settings;
    /**
     * Textually searches arrays and hashes of objects
     * by property (or multiple properties). Designed
     * specifically for autocomplete.
     *
     */
    constructor(items, settings) {
        this.items = items;
        this.settings = settings || { diacritics: true };
    }
    ;
    /**
     * Splits a search string into an array of individual
     * regexps to be used to match results.
     *
     */
    tokenize(query, respect_word_boundaries, weights) {
        if (!query || !query.length)
            return [];
        const tokens = [];
        const words = query.split(/\s+/);
        var field_regex;
        if (weights) {
            field_regex = new RegExp('^(' + Object.keys(weights).map(_orchidjs_unicode_variants__WEBPACK_IMPORTED_MODULE_1__.escape_regex).join('|') + ')\:(.*)$');
        }
        words.forEach((word) => {
            let field_match;
            let field = null;
            let regex = null;
            // look for "field:query" tokens
            if (field_regex && (field_match = word.match(field_regex))) {
                field = field_match[1];
                word = field_match[2];
            }
            if (word.length > 0) {
                if (this.settings.diacritics) {
                    regex = (0,_orchidjs_unicode_variants__WEBPACK_IMPORTED_MODULE_1__.getPattern)(word) || null;
                }
                else {
                    regex = (0,_orchidjs_unicode_variants__WEBPACK_IMPORTED_MODULE_1__.escape_regex)(word);
                }
                if (regex && respect_word_boundaries)
                    regex = "\\b" + regex;
            }
            tokens.push({
                string: word,
                regex: regex ? new RegExp(regex, 'iu') : null,
                field: field,
            });
        });
        return tokens;
    }
    ;
    /**
     * Returns a function to be used to score individual results.
     *
     * Good matches will have a higher score than poor matches.
     * If an item is not a match, 0 will be returned by the function.
     *
     * @returns {T.ScoreFn}
     */
    getScoreFunction(query, options) {
        var search = this.prepareSearch(query, options);
        return this._getScoreFunction(search);
    }
    /**
     * @returns {T.ScoreFn}
     *
     */
    _getScoreFunction(search) {
        const tokens = search.tokens, token_count = tokens.length;
        if (!token_count) {
            return function () { return 0; };
        }
        const fields = search.options.fields, weights = search.weights, field_count = fields.length, getAttrFn = search.getAttrFn;
        if (!field_count) {
            return function () { return 1; };
        }
        /**
         * Calculates the score of an object
         * against the search query.
         *
         */
        const scoreObject = (function () {
            if (field_count === 1) {
                return function (token, data) {
                    const field = fields[0].field;
                    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.scoreValue)(getAttrFn(data, field), token, weights[field] || 1);
                };
            }
            return function (token, data) {
                var sum = 0;
                // is the token specific to a field?
                if (token.field) {
                    const value = getAttrFn(data, token.field);
                    if (!token.regex && value) {
                        sum += (1 / field_count);
                    }
                    else {
                        sum += (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.scoreValue)(value, token, 1);
                    }
                }
                else {
                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.iterate)(weights, (weight, field) => {
                        sum += (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.scoreValue)(getAttrFn(data, field), token, weight);
                    });
                }
                return sum / field_count;
            };
        })();
        if (token_count === 1) {
            return function (data) {
                return scoreObject(tokens[0], data);
            };
        }
        if (search.options.conjunction === 'and') {
            return function (data) {
                var score, sum = 0;
                for (let token of tokens) {
                    score = scoreObject(token, data);
                    if (score <= 0)
                        return 0;
                    sum += score;
                }
                return sum / token_count;
            };
        }
        else {
            return function (data) {
                var sum = 0;
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.iterate)(tokens, (token) => {
                    sum += scoreObject(token, data);
                });
                return sum / token_count;
            };
        }
    }
    ;
    /**
     * Returns a function that can be used to compare two
     * results, for sorting purposes. If no sorting should
     * be performed, `null` will be returned.
     *
     * @return function(a,b)
     */
    getSortFunction(query, options) {
        var search = this.prepareSearch(query, options);
        return this._getSortFunction(search);
    }
    _getSortFunction(search) {
        var implicit_score, sort_flds = [];
        const self = this, options = search.options, sort = (!search.query && options.sort_empty) ? options.sort_empty : options.sort;
        if (typeof sort == 'function') {
            return sort.bind(this);
        }
        /**
         * Fetches the specified sort field value
         * from a search result item.
         *
         */
        const get_field = function (name, result) {
            if (name === '$score')
                return result.score;
            return search.getAttrFn(self.items[result.id], name);
        };
        // parse options
        if (sort) {
            for (let s of sort) {
                if (search.query || s.field !== '$score') {
                    sort_flds.push(s);
                }
            }
        }
        // the "$score" field is implied to be the primary
        // sort field, unless it's manually specified
        if (search.query) {
            implicit_score = true;
            for (let fld of sort_flds) {
                if (fld.field === '$score') {
                    implicit_score = false;
                    break;
                }
            }
            if (implicit_score) {
                sort_flds.unshift({ field: '$score', direction: 'desc' });
            }
            // without a search.query, all items will have the same score
        }
        else {
            sort_flds = sort_flds.filter((fld) => fld.field !== '$score');
        }
        // build function
        const sort_flds_count = sort_flds.length;
        if (!sort_flds_count) {
            return null;
        }
        return function (a, b) {
            var result, field;
            for (let sort_fld of sort_flds) {
                field = sort_fld.field;
                let multiplier = sort_fld.direction === 'desc' ? -1 : 1;
                result = multiplier * (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cmp)(get_field(field, a), get_field(field, b));
                if (result)
                    return result;
            }
            return 0;
        };
    }
    ;
    /**
     * Parses a search query and returns an object
     * with tokens and fields ready to be populated
     * with results.
     *
     */
    prepareSearch(query, optsUser) {
        const weights = {};
        var options = Object.assign({}, optsUser);
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.propToArray)(options, 'sort');
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.propToArray)(options, 'sort_empty');
        // convert fields to new format
        if (options.fields) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.propToArray)(options, 'fields');
            const fields = [];
            options.fields.forEach((field) => {
                if (typeof field == 'string') {
                    field = { field: field, weight: 1 };
                }
                fields.push(field);
                weights[field.field] = ('weight' in field) ? field.weight : 1;
            });
            options.fields = fields;
        }
        return {
            options: options,
            query: query.toLowerCase().trim(),
            tokens: this.tokenize(query, options.respect_word_boundaries, weights),
            total: 0,
            items: [],
            weights: weights,
            getAttrFn: (options.nesting) ? _utils_js__WEBPACK_IMPORTED_MODULE_0__.getAttrNesting : _utils_js__WEBPACK_IMPORTED_MODULE_0__.getAttr,
        };
    }
    ;
    /**
     * Searches through all items and returns a sorted array of matches.
     *
     */
    search(query, options) {
        var self = this, score, search;
        search = this.prepareSearch(query, options);
        options = search.options;
        query = search.query;
        // generate result scoring function
        const fn_score = options.score || self._getScoreFunction(search);
        // perform search and sort
        if (query.length) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.iterate)(self.items, (item, id) => {
                score = fn_score(item);
                if (options.filter === false || score > 0) {
                    search.items.push({ 'score': score, 'id': id });
                }
            });
        }
        else {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.iterate)(self.items, (_, id) => {
                search.items.push({ 'score': 1, 'id': id });
            });
        }
        const fn_sort = self._getSortFunction(search);
        if (fn_sort)
            search.items.sort(fn_sort);
        // apply limits
        search.total = search.items.length;
        if (typeof options.limit === 'number') {
            search.items = search.items.slice(0, options.limit);
        }
        return search;
    }
    ;
}


//# sourceMappingURL=sifter.js.map

/***/ }),

/***/ "./node_modules/@orchidjs/sifter/dist/esm/types.js":
/*!*********************************************************!*\
  !*** ./node_modules/@orchidjs/sifter/dist/esm/types.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/@orchidjs/sifter/dist/esm/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/@orchidjs/sifter/dist/esm/utils.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cmp: function() { return /* binding */ cmp; },
/* harmony export */   getAttr: function() { return /* binding */ getAttr; },
/* harmony export */   getAttrNesting: function() { return /* binding */ getAttrNesting; },
/* harmony export */   iterate: function() { return /* binding */ iterate; },
/* harmony export */   propToArray: function() { return /* binding */ propToArray; },
/* harmony export */   scoreValue: function() { return /* binding */ scoreValue; }
/* harmony export */ });
/* harmony import */ var _orchidjs_unicode_variants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @orchidjs/unicode-variants */ "./node_modules/@orchidjs/unicode-variants/dist/esm/index.js");

/**
 * A property getter resolving dot-notation
 * @param  {Object}  obj     The root object to fetch property on
 * @param  {String}  name    The optionally dotted property name to fetch
 * @return {Object}          The resolved property value
 */
const getAttr = (obj, name) => {
    if (!obj)
        return;
    return obj[name];
};
/**
 * A property getter resolving dot-notation
 * @param  {Object}  obj     The root object to fetch property on
 * @param  {String}  name    The optionally dotted property name to fetch
 * @return {Object}          The resolved property value
 */
const getAttrNesting = (obj, name) => {
    if (!obj)
        return;
    var part, names = name.split(".");
    while ((part = names.shift()) && (obj = obj[part]))
        ;
    return obj;
};
/**
 * Calculates how close of a match the
 * given value is against a search token.
 *
 */
const scoreValue = (value, token, weight) => {
    var score, pos;
    if (!value)
        return 0;
    value = value + '';
    if (token.regex == null)
        return 0;
    pos = value.search(token.regex);
    if (pos === -1)
        return 0;
    score = token.string.length / value.length;
    if (pos === 0)
        score += 0.5;
    return score * weight;
};
/**
 * Cast object property to an array if it exists and has a value
 *
 */
const propToArray = (obj, key) => {
    var value = obj[key];
    if (typeof value == 'function')
        return value;
    if (value && !Array.isArray(value)) {
        obj[key] = [value];
    }
};
/**
 * Iterates over arrays and hashes.
 *
 * ```
 * iterate(this.items, function(item, id) {
 *    // invoked for each item
 * });
 * ```
 *
 */
const iterate = (object, callback) => {
    if (Array.isArray(object)) {
        object.forEach(callback);
    }
    else {
        for (var key in object) {
            if (object.hasOwnProperty(key)) {
                callback(object[key], key);
            }
        }
    }
};
const cmp = (a, b) => {
    if (typeof a === 'number' && typeof b === 'number') {
        return a > b ? 1 : (a < b ? -1 : 0);
    }
    a = (0,_orchidjs_unicode_variants__WEBPACK_IMPORTED_MODULE_0__.asciifold)(a + '').toLowerCase();
    b = (0,_orchidjs_unicode_variants__WEBPACK_IMPORTED_MODULE_0__.asciifold)(b + '').toLowerCase();
    if (a > b)
        return 1;
    if (b > a)
        return -1;
    return 0;
};
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/@orchidjs/unicode-variants/dist/esm/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@orchidjs/unicode-variants/dist/esm/index.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _asciifold: function() { return /* binding */ _asciifold; },
/* harmony export */   asciifold: function() { return /* binding */ asciifold; },
/* harmony export */   code_points: function() { return /* binding */ code_points; },
/* harmony export */   escape_regex: function() { return /* reexport safe */ _regex_js__WEBPACK_IMPORTED_MODULE_0__.escape_regex; },
/* harmony export */   generateMap: function() { return /* binding */ generateMap; },
/* harmony export */   generateSets: function() { return /* binding */ generateSets; },
/* harmony export */   generator: function() { return /* binding */ generator; },
/* harmony export */   getPattern: function() { return /* binding */ getPattern; },
/* harmony export */   initialize: function() { return /* binding */ initialize; },
/* harmony export */   mapSequence: function() { return /* binding */ mapSequence; },
/* harmony export */   normalize: function() { return /* binding */ normalize; },
/* harmony export */   substringsToPattern: function() { return /* binding */ substringsToPattern; },
/* harmony export */   unicode_map: function() { return /* binding */ unicode_map; }
/* harmony export */ });
/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ "./node_modules/@orchidjs/unicode-variants/dist/esm/regex.js");
/* harmony import */ var _strings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./strings.js */ "./node_modules/@orchidjs/unicode-variants/dist/esm/strings.js");


const code_points = [[0, 65535]];
const accent_pat = '[\u0300-\u036F\u{b7}\u{2be}\u{2bc}]';
let unicode_map;
let multi_char_reg;
const max_char_length = 3;
const latin_convert = {};
const latin_condensed = {
    '/': '⁄∕',
    '0': '߀',
    "a": "ⱥɐɑ",
    "aa": "ꜳ",
    "ae": "æǽǣ",
    "ao": "ꜵ",
    "au": "ꜷ",
    "av": "ꜹꜻ",
    "ay": "ꜽ",
    "b": "ƀɓƃ",
    "c": "ꜿƈȼↄ",
    "d": "đɗɖᴅƌꮷԁɦ",
    "e": "ɛǝᴇɇ",
    "f": "ꝼƒ",
    "g": "ǥɠꞡᵹꝿɢ",
    "h": "ħⱨⱶɥ",
    "i": "ɨı",
    "j": "ɉȷ",
    "k": "ƙⱪꝁꝃꝅꞣ",
    "l": "łƚɫⱡꝉꝇꞁɭ",
    "m": "ɱɯϻ",
    "n": "ꞥƞɲꞑᴎлԉ",
    "o": "øǿɔɵꝋꝍᴑ",
    "oe": "œ",
    "oi": "ƣ",
    "oo": "ꝏ",
    "ou": "ȣ",
    "p": "ƥᵽꝑꝓꝕρ",
    "q": "ꝗꝙɋ",
    "r": "ɍɽꝛꞧꞃ",
    "s": "ßȿꞩꞅʂ",
    "t": "ŧƭʈⱦꞇ",
    "th": "þ",
    "tz": "ꜩ",
    "u": "ʉ",
    "v": "ʋꝟʌ",
    "vy": "ꝡ",
    "w": "ⱳ",
    "y": "ƴɏỿ",
    "z": "ƶȥɀⱬꝣ",
    "hv": "ƕ"
};
for (let latin in latin_condensed) {
    let unicode = latin_condensed[latin] || '';
    for (let i = 0; i < unicode.length; i++) {
        let char = unicode.substring(i, i + 1);
        latin_convert[char] = latin;
    }
}
const convert_pat = new RegExp(Object.keys(latin_convert).join('|') + '|' + accent_pat, 'gu');
/**
 * Initialize the unicode_map from the give code point ranges
 */
const initialize = (_code_points) => {
    if (unicode_map !== undefined)
        return;
    unicode_map = generateMap(_code_points || code_points);
};
/**
 * Helper method for normalize a string
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize
 */
const normalize = (str, form = 'NFKD') => str.normalize(form);
/**
 * Remove accents without reordering string
 * calling str.normalize('NFKD') on \u{594}\u{595}\u{596} becomes \u{596}\u{594}\u{595}
 * via https://github.com/krisk/Fuse/issues/133#issuecomment-318692703
 */
const asciifold = (str) => {
    return Array.from(str).reduce(
    /**
     * @param {string} result
     * @param {string} char
     */
    (result, char) => {
        return result + _asciifold(char);
    }, '');
};
const _asciifold = (str) => {
    str = normalize(str)
        .toLowerCase()
        .replace(convert_pat, (/** @type {string} */ char) => {
        return latin_convert[char] || '';
    });
    //return str;
    return normalize(str, 'NFC');
};
/**
 * Generate a list of unicode variants from the list of code points
 */
function* generator(code_points) {
    for (const [code_point_min, code_point_max] of code_points) {
        for (let i = code_point_min; i <= code_point_max; i++) {
            let composed = String.fromCharCode(i);
            let folded = asciifold(composed);
            if (folded == composed.toLowerCase()) {
                continue;
            }
            // skip when folded is a string longer than 3 characters long
            // bc the resulting regex patterns will be long
            // eg:
            // folded صلى الله عليه وسلم length 18 code point 65018
            // folded جل جلاله length 8 code point 65019
            if (folded.length > max_char_length) {
                continue;
            }
            if (folded.length == 0) {
                continue;
            }
            yield { folded: folded, composed: composed, code_point: i };
        }
    }
}
/**
 * Generate a unicode map from the list of code points
 */
const generateSets = (code_points) => {
    const unicode_sets = {};
    const addMatching = (folded, to_add) => {
        /** @type {Set<string>} */
        const folded_set = unicode_sets[folded] || new Set();
        const patt = new RegExp('^' + (0,_regex_js__WEBPACK_IMPORTED_MODULE_0__.setToPattern)(folded_set) + '$', 'iu');
        if (to_add.match(patt)) {
            return;
        }
        folded_set.add((0,_regex_js__WEBPACK_IMPORTED_MODULE_0__.escape_regex)(to_add));
        unicode_sets[folded] = folded_set;
    };
    for (let value of generator(code_points)) {
        addMatching(value.folded, value.folded);
        addMatching(value.folded, value.composed);
    }
    return unicode_sets;
};
/**
 * Generate a unicode map from the list of code points
 * ae => (?:(?:ae|Æ|Ǽ|Ǣ)|(?:A|Ⓐ|Ａ...)(?:E|ɛ|Ⓔ...))
 */
const generateMap = (code_points) => {
    const unicode_sets = generateSets(code_points);
    const unicode_map = {};
    let multi_char = [];
    for (let folded in unicode_sets) {
        let set = unicode_sets[folded];
        if (set) {
            unicode_map[folded] = (0,_regex_js__WEBPACK_IMPORTED_MODULE_0__.setToPattern)(set);
        }
        if (folded.length > 1) {
            multi_char.push((0,_regex_js__WEBPACK_IMPORTED_MODULE_0__.escape_regex)(folded));
        }
    }
    multi_char.sort((a, b) => b.length - a.length);
    const multi_char_patt = (0,_regex_js__WEBPACK_IMPORTED_MODULE_0__.arrayToPattern)(multi_char);
    multi_char_reg = new RegExp('^' + multi_char_patt, 'u');
    return unicode_map;
};
/**
 * Map each element of an array from its folded value to all possible unicode matches
 */
const mapSequence = (strings, min_replacement = 1) => {
    let chars_replaced = 0;
    strings = strings.map((str) => {
        if (unicode_map[str]) {
            chars_replaced += str.length;
        }
        return unicode_map[str] || str;
    });
    if (chars_replaced >= min_replacement) {
        return (0,_regex_js__WEBPACK_IMPORTED_MODULE_0__.sequencePattern)(strings);
    }
    return '';
};
/**
 * Convert a short string and split it into all possible patterns
 * Keep a pattern only if min_replacement is met
 *
 * 'abc'
 * 		=> [['abc'],['ab','c'],['a','bc'],['a','b','c']]
 *		=> ['abc-pattern','ab-c-pattern'...]
 */
const substringsToPattern = (str, min_replacement = 1) => {
    min_replacement = Math.max(min_replacement, str.length - 1);
    return (0,_regex_js__WEBPACK_IMPORTED_MODULE_0__.arrayToPattern)((0,_strings_js__WEBPACK_IMPORTED_MODULE_1__.allSubstrings)(str).map((sub_pat) => {
        return mapSequence(sub_pat, min_replacement);
    }));
};
/**
 * Convert an array of sequences into a pattern
 * [{start:0,end:3,length:3,substr:'iii'}...] => (?:iii...)
 */
const sequencesToPattern = (sequences, all = true) => {
    let min_replacement = sequences.length > 1 ? 1 : 0;
    return (0,_regex_js__WEBPACK_IMPORTED_MODULE_0__.arrayToPattern)(sequences.map((sequence) => {
        let seq = [];
        const len = all ? sequence.length() : sequence.length() - 1;
        for (let j = 0; j < len; j++) {
            seq.push(substringsToPattern(sequence.substrs[j] || '', min_replacement));
        }
        return (0,_regex_js__WEBPACK_IMPORTED_MODULE_0__.sequencePattern)(seq);
    }));
};
/**
 * Return true if the sequence is already in the sequences
 */
const inSequences = (needle_seq, sequences) => {
    for (const seq of sequences) {
        if (seq.start != needle_seq.start || seq.end != needle_seq.end) {
            continue;
        }
        if (seq.substrs.join('') !== needle_seq.substrs.join('')) {
            continue;
        }
        let needle_parts = needle_seq.parts;
        const filter = (part) => {
            for (const needle_part of needle_parts) {
                if (needle_part.start === part.start && needle_part.substr === part.substr) {
                    return false;
                }
                if (part.length == 1 || needle_part.length == 1) {
                    continue;
                }
                // check for overlapping parts
                // a = ['::=','==']
                // b = ['::','===']
                // a = ['r','sm']
                // b = ['rs','m']
                if (part.start < needle_part.start && part.end > needle_part.start) {
                    return true;
                }
                if (needle_part.start < part.start && needle_part.end > part.start) {
                    return true;
                }
            }
            return false;
        };
        let filtered = seq.parts.filter(filter);
        if (filtered.length > 0) {
            continue;
        }
        return true;
    }
    return false;
};
class Sequence {
    parts;
    substrs;
    start;
    end;
    constructor() {
        this.parts = [];
        this.substrs = [];
        this.start = 0;
        this.end = 0;
    }
    add(part) {
        if (part) {
            this.parts.push(part);
            this.substrs.push(part.substr);
            this.start = Math.min(part.start, this.start);
            this.end = Math.max(part.end, this.end);
        }
    }
    last() {
        return this.parts[this.parts.length - 1];
    }
    length() {
        return this.parts.length;
    }
    clone(position, last_piece) {
        let clone = new Sequence();
        let parts = JSON.parse(JSON.stringify(this.parts));
        let last_part = parts.pop();
        for (const part of parts) {
            clone.add(part);
        }
        let last_substr = last_piece.substr.substring(0, position - last_part.start);
        let clone_last_len = last_substr.length;
        clone.add({ start: last_part.start, end: last_part.start + clone_last_len, length: clone_last_len, substr: last_substr });
        return clone;
    }
}
/**
 * Expand a regular expression pattern to include unicode variants
 * 	eg /a/ becomes /aⓐａẚàáâầấẫẩãāăằắẵẳȧǡäǟảåǻǎȁȃạậặḁąⱥɐɑAⒶＡÀÁÂẦẤẪẨÃĀĂẰẮẴẲȦǠÄǞẢÅǺǍȀȂẠẬẶḀĄȺⱯ/
 *
 * Issue:
 *  ﺊﺋ [ 'ﺊ = \\u{fe8a}', 'ﺋ = \\u{fe8b}' ]
 *	becomes:	ئئ [ 'ي = \\u{64a}', 'ٔ = \\u{654}', 'ي = \\u{64a}', 'ٔ = \\u{654}' ]
 *
 *	İĲ = IIJ = ⅡJ
 *
 * 	1/2/4
 */
const getPattern = (str) => {
    initialize();
    str = asciifold(str);
    let pattern = '';
    let sequences = [new Sequence()];
    for (let i = 0; i < str.length; i++) {
        let substr = str.substring(i);
        let match = substr.match(multi_char_reg);
        const char = str.substring(i, i + 1);
        const match_str = match ? match[0] : null;
        // loop through sequences
        // add either the char or multi_match
        let overlapping = [];
        let added_types = new Set();
        for (const sequence of sequences) {
            const last_piece = sequence.last();
            if (!last_piece || last_piece.length == 1 || last_piece.end <= i) {
                // if we have a multi match
                if (match_str) {
                    const len = match_str.length;
                    sequence.add({ start: i, end: i + len, length: len, substr: match_str });
                    added_types.add('1');
                }
                else {
                    sequence.add({ start: i, end: i + 1, length: 1, substr: char });
                    added_types.add('2');
                }
            }
            else if (match_str) {
                let clone = sequence.clone(i, last_piece);
                const len = match_str.length;
                clone.add({ start: i, end: i + len, length: len, substr: match_str });
                overlapping.push(clone);
            }
            else {
                // don't add char
                // adding would create invalid patterns: 234 => [2,34,4]
                added_types.add('3');
            }
        }
        // if we have overlapping
        if (overlapping.length > 0) {
            // ['ii','iii'] before ['i','i','iii']
            overlapping = overlapping.sort((a, b) => {
                return a.length() - b.length();
            });
            for (let clone of overlapping) {
                // don't add if we already have an equivalent sequence
                if (inSequences(clone, sequences)) {
                    continue;
                }
                sequences.push(clone);
            }
            continue;
        }
        // if we haven't done anything unique
        // clean up the patterns
        // helps keep patterns smaller
        // if str = 'r₨㎧aarss', pattern will be 446 instead of 655
        if (i > 0 && added_types.size == 1 && !added_types.has('3')) {
            pattern += sequencesToPattern(sequences, false);
            let new_seq = new Sequence();
            const old_seq = sequences[0];
            if (old_seq) {
                new_seq.add(old_seq.last());
            }
            sequences = [new_seq];
        }
    }
    pattern += sequencesToPattern(sequences, true);
    return pattern;
};

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@orchidjs/unicode-variants/dist/esm/regex.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@orchidjs/unicode-variants/dist/esm/regex.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arrayToPattern: function() { return /* binding */ arrayToPattern; },
/* harmony export */   escape_regex: function() { return /* binding */ escape_regex; },
/* harmony export */   hasDuplicates: function() { return /* binding */ hasDuplicates; },
/* harmony export */   maxValueLength: function() { return /* binding */ maxValueLength; },
/* harmony export */   sequencePattern: function() { return /* binding */ sequencePattern; },
/* harmony export */   setToPattern: function() { return /* binding */ setToPattern; },
/* harmony export */   unicodeLength: function() { return /* binding */ unicodeLength; }
/* harmony export */ });
/**
 * Convert array of strings to a regular expression
 *	ex ['ab','a'] => (?:ab|a)
 * 	ex ['a','b'] => [ab]
 */
const arrayToPattern = (chars) => {
    chars = chars.filter(Boolean);
    if (chars.length < 2) {
        return chars[0] || '';
    }
    return (maxValueLength(chars) == 1) ? '[' + chars.join('') + ']' : '(?:' + chars.join('|') + ')';
};
const sequencePattern = (array) => {
    if (!hasDuplicates(array)) {
        return array.join('');
    }
    let pattern = '';
    let prev_char_count = 0;
    const prev_pattern = () => {
        if (prev_char_count > 1) {
            pattern += '{' + prev_char_count + '}';
        }
    };
    array.forEach((char, i) => {
        if (char === array[i - 1]) {
            prev_char_count++;
            return;
        }
        prev_pattern();
        pattern += char;
        prev_char_count = 1;
    });
    prev_pattern();
    return pattern;
};
/**
 * Convert array of strings to a regular expression
 *	ex ['ab','a'] => (?:ab|a)
 * 	ex ['a','b'] => [ab]
 */
const setToPattern = (chars) => {
    let array = Array.from(chars);
    return arrayToPattern(array);
};
/**
 * https://stackoverflow.com/questions/7376598/in-javascript-how-do-i-check-if-an-array-has-duplicate-values
 */
const hasDuplicates = (array) => {
    return (new Set(array)).size !== array.length;
};
/**
 * https://stackoverflow.com/questions/63006601/why-does-u-throw-an-invalid-escape-error
 */
const escape_regex = (str) => {
    return (str + '').replace(/([\$\(\)\*\+\.\?\[\]\^\{\|\}\\])/gu, '\\$1');
};
/**
 * Return the max length of array values
 */
const maxValueLength = (array) => {
    return array.reduce((longest, value) => Math.max(longest, unicodeLength(value)), 0);
};
const unicodeLength = (str) => {
    return Array.from(str).length;
};
//# sourceMappingURL=regex.js.map

/***/ }),

/***/ "./node_modules/@orchidjs/unicode-variants/dist/esm/strings.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@orchidjs/unicode-variants/dist/esm/strings.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   allSubstrings: function() { return /* binding */ allSubstrings; }
/* harmony export */ });
/**
 * Get all possible combinations of substrings that add up to the given string
 * https://stackoverflow.com/questions/30169587/find-all-the-combination-of-substrings-that-add-up-to-the-given-string
 */
const allSubstrings = (input) => {
    if (input.length === 1)
        return [[input]];
    let result = [];
    const start = input.substring(1);
    const suba = allSubstrings(start);
    suba.forEach(function (subresult) {
        let tmp = subresult.slice(0);
        tmp[0] = input.charAt(0) + tmp[0];
        result.push(tmp);
        tmp = subresult.slice(0);
        tmp.unshift(input.charAt(0));
        result.push(tmp);
    });
    return result;
};
//# sourceMappingURL=strings.js.map

/***/ }),

/***/ "./node_modules/core-js/modules/es.array.find.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.find.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $find = (__webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").find);
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js/internals/add-to-unscopables.js");

var FIND = 'find';
var SKIPS_HOLES = true;

// Shouldn't skip holes
// eslint-disable-next-line es/no-array-prototype-find -- testing
if (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES = false; });

// `Array.prototype.find` method
// https://tc39.es/ecma262/#sec-array.prototype.find
$({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND);


/***/ }),

/***/ "./node_modules/core-js/modules/es.weak-set.constructor.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.weak-set.constructor.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var collection = __webpack_require__(/*! ../internals/collection */ "./node_modules/core-js/internals/collection.js");
var collectionWeak = __webpack_require__(/*! ../internals/collection-weak */ "./node_modules/core-js/internals/collection-weak.js");

// `WeakSet` constructor
// https://tc39.es/ecma262/#sec-weakset-constructor
collection('WeakSet', function (init) {
  return function WeakSet() { return init(this, arguments.length ? arguments[0] : undefined); };
}, collectionWeak);


/***/ }),

/***/ "./node_modules/core-js/modules/es.weak-set.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/es.weak-set.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


// TODO: Remove this module from `core-js@4` since it's replaced to module below
__webpack_require__(/*! ../modules/es.weak-set.constructor */ "./node_modules/core-js/modules/es.weak-set.constructor.js");


/***/ }),

/***/ "./node_modules/tom-select/dist/esm/constants.js":
/*!*******************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/constants.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IS_MAC: function() { return /* binding */ IS_MAC; },
/* harmony export */   KEY_A: function() { return /* binding */ KEY_A; },
/* harmony export */   KEY_BACKSPACE: function() { return /* binding */ KEY_BACKSPACE; },
/* harmony export */   KEY_DELETE: function() { return /* binding */ KEY_DELETE; },
/* harmony export */   KEY_DOWN: function() { return /* binding */ KEY_DOWN; },
/* harmony export */   KEY_ESC: function() { return /* binding */ KEY_ESC; },
/* harmony export */   KEY_LEFT: function() { return /* binding */ KEY_LEFT; },
/* harmony export */   KEY_RETURN: function() { return /* binding */ KEY_RETURN; },
/* harmony export */   KEY_RIGHT: function() { return /* binding */ KEY_RIGHT; },
/* harmony export */   KEY_SHORTCUT: function() { return /* binding */ KEY_SHORTCUT; },
/* harmony export */   KEY_TAB: function() { return /* binding */ KEY_TAB; },
/* harmony export */   KEY_UP: function() { return /* binding */ KEY_UP; }
/* harmony export */ });
const KEY_A = 65;
const KEY_RETURN = 13;
const KEY_ESC = 27;
const KEY_LEFT = 37;
const KEY_UP = 38;
const KEY_RIGHT = 39;
const KEY_DOWN = 40;
const KEY_BACKSPACE = 8;
const KEY_DELETE = 46;
const KEY_TAB = 9;
const IS_MAC = typeof navigator === 'undefined' ? false : /Mac/.test(navigator.userAgent);
const KEY_SHORTCUT = IS_MAC ? 'metaKey' : 'ctrlKey'; // ctrl key or apple key for ma
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "./node_modules/tom-select/dist/esm/contrib/highlight.js":
/*!***************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/contrib/highlight.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   highlight: function() { return /* binding */ highlight; },
/* harmony export */   removeHighlight: function() { return /* binding */ removeHighlight; }
/* harmony export */ });
/* harmony import */ var _vanilla_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../vanilla.js */ "./node_modules/tom-select/dist/esm/vanilla.js");
/**
 * highlight v3 | MIT license | Johann Burkard <jb@eaio.com>
 * Highlights arbitrary terms in a node.
 *
 * - Modified by Marshal <beatgates@gmail.com> 2011-6-24 (added regex)
 * - Modified by Brian Reavis <brian@thirdroute.com> 2012-8-27 (cleanup)
 */

const highlight = (element, regex) => {
    if (regex === null)
        return;
    // convet string to regex
    if (typeof regex === 'string') {
        if (!regex.length)
            return;
        regex = new RegExp(regex, 'i');
    }
    // Wrap matching part of text node with highlighting <span>, e.g.
    // Soccer  ->  <span class="highlight">Soc</span>cer  for regex = /soc/i
    const highlightText = (node) => {
        var match = node.data.match(regex);
        if (match && node.data.length > 0) {
            var spannode = document.createElement('span');
            spannode.className = 'highlight';
            var middlebit = node.splitText(match.index);
            middlebit.splitText(match[0].length);
            var middleclone = middlebit.cloneNode(true);
            spannode.appendChild(middleclone);
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_0__.replaceNode)(middlebit, spannode);
            return 1;
        }
        return 0;
    };
    // Recurse element node, looking for child text nodes to highlight, unless element
    // is childless, <script>, <style>, or already highlighted: <span class="hightlight">
    const highlightChildren = (node) => {
        if (node.nodeType === 1 && node.childNodes && !/(script|style)/i.test(node.tagName) && (node.className !== 'highlight' || node.tagName !== 'SPAN')) {
            Array.from(node.childNodes).forEach(element => {
                highlightRecursive(element);
            });
        }
    };
    const highlightRecursive = (node) => {
        if (node.nodeType === 3) {
            return highlightText(node);
        }
        highlightChildren(node);
        return 0;
    };
    highlightRecursive(element);
};
/**
 * removeHighlight fn copied from highlight v5 and
 * edited to remove with(), pass js strict mode, and use without jquery
 */
const removeHighlight = (el) => {
    var elements = el.querySelectorAll("span.highlight");
    Array.prototype.forEach.call(elements, function (el) {
        var parent = el.parentNode;
        parent.replaceChild(el.firstChild, el);
        parent.normalize();
    });
};
//# sourceMappingURL=highlight.js.map

/***/ }),

/***/ "./node_modules/tom-select/dist/esm/contrib/microevent.js":
/*!****************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/contrib/microevent.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ MicroEvent; }
/* harmony export */ });
/**
 * MicroEvent - to make any js object an event emitter
 *
 * - pure javascript - server compatible, browser compatible
 * - dont rely on the browser doms
 * - super simple - you get it immediatly, no mistery, no magic involved
 *
 * @author Jerome Etienne (https://github.com/jeromeetienne)
 */
/**
 * Execute callback for each event in space separated list of event names
 *
 */
function forEvents(events, callback) {
    events.split(/\s+/).forEach((event) => {
        callback(event);
    });
}
class MicroEvent {
    constructor() {
        this._events = {};
    }
    on(events, fct) {
        forEvents(events, (event) => {
            const event_array = this._events[event] || [];
            event_array.push(fct);
            this._events[event] = event_array;
        });
    }
    off(events, fct) {
        var n = arguments.length;
        if (n === 0) {
            this._events = {};
            return;
        }
        forEvents(events, (event) => {
            if (n === 1) {
                delete this._events[event];
                return;
            }
            const event_array = this._events[event];
            if (event_array === undefined)
                return;
            event_array.splice(event_array.indexOf(fct), 1);
            this._events[event] = event_array;
        });
    }
    trigger(events, ...args) {
        var self = this;
        forEvents(events, (event) => {
            const event_array = self._events[event];
            if (event_array === undefined)
                return;
            event_array.forEach(fct => {
                fct.apply(self, args);
            });
        });
    }
}
;
//# sourceMappingURL=microevent.js.map

/***/ }),

/***/ "./node_modules/tom-select/dist/esm/contrib/microplugin.js":
/*!*****************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/contrib/microplugin.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ MicroPlugin; }
/* harmony export */ });
/**
 * microplugin.js
 * Copyright (c) 2013 Brian Reavis & contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 * @author Brian Reavis <brian@thirdroute.com>
 */
function MicroPlugin(Interface) {
    Interface.plugins = {};
    return class extends Interface {
        constructor() {
            super(...arguments);
            this.plugins = {
                names: [],
                settings: {},
                requested: {},
                loaded: {}
            };
        }
        /**
         * Registers a plugin.
         *
         * @param {function} fn
         */
        static define(name, fn) {
            Interface.plugins[name] = {
                'name': name,
                'fn': fn
            };
        }
        /**
         * Initializes the listed plugins (with options).
         * Acceptable formats:
         *
         * List (without options):
         *   ['a', 'b', 'c']
         *
         * List (with options):
         *   [{'name': 'a', options: {}}, {'name': 'b', options: {}}]
         *
         * Hash (with options):
         *   {'a': { ... }, 'b': { ... }, 'c': { ... }}
         *
         * @param {array|object} plugins
         */
        initializePlugins(plugins) {
            var key, name;
            const self = this;
            const queue = [];
            if (Array.isArray(plugins)) {
                plugins.forEach((plugin) => {
                    if (typeof plugin === 'string') {
                        queue.push(plugin);
                    }
                    else {
                        self.plugins.settings[plugin.name] = plugin.options;
                        queue.push(plugin.name);
                    }
                });
            }
            else if (plugins) {
                for (key in plugins) {
                    if (plugins.hasOwnProperty(key)) {
                        self.plugins.settings[key] = plugins[key];
                        queue.push(key);
                    }
                }
            }
            while (name = queue.shift()) {
                self.require(name);
            }
        }
        loadPlugin(name) {
            var self = this;
            var plugins = self.plugins;
            var plugin = Interface.plugins[name];
            if (!Interface.plugins.hasOwnProperty(name)) {
                throw new Error('Unable to find "' + name + '" plugin');
            }
            plugins.requested[name] = true;
            plugins.loaded[name] = plugin.fn.apply(self, [self.plugins.settings[name] || {}]);
            plugins.names.push(name);
        }
        /**
         * Initializes a plugin.
         *
         */
        require(name) {
            var self = this;
            var plugins = self.plugins;
            if (!self.plugins.loaded.hasOwnProperty(name)) {
                if (plugins.requested[name]) {
                    throw new Error('Plugin has circular dependency ("' + name + '")');
                }
                self.loadPlugin(name);
            }
            return plugins.loaded[name];
        }
    };
}
//# sourceMappingURL=microplugin.js.map

/***/ }),

/***/ "./node_modules/tom-select/dist/esm/defaults.js":
/*!******************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/defaults.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({
    options: [],
    optgroups: [],
    plugins: [],
    delimiter: ',',
    splitOn: null, // regexp or string for splitting up values from a paste command
    persist: true,
    diacritics: true,
    create: null,
    createOnBlur: false,
    createFilter: null,
    highlight: true,
    openOnFocus: true,
    shouldOpen: null,
    maxOptions: 50,
    maxItems: null,
    hideSelected: null,
    duplicates: false,
    addPrecedence: false,
    selectOnTab: false,
    preload: null,
    allowEmptyOption: false,
    //closeAfterSelect: false,
    refreshThrottle: 300,
    loadThrottle: 300,
    loadingClass: 'loading',
    dataAttr: null, //'data-data',
    optgroupField: 'optgroup',
    valueField: 'value',
    labelField: 'text',
    disabledField: 'disabled',
    optgroupLabelField: 'label',
    optgroupValueField: 'value',
    lockOptgroupOrder: false,
    sortField: '$order',
    searchField: ['text'],
    searchConjunction: 'and',
    mode: null,
    wrapperClass: 'ts-wrapper',
    controlClass: 'ts-control',
    dropdownClass: 'ts-dropdown',
    dropdownContentClass: 'ts-dropdown-content',
    itemClass: 'item',
    optionClass: 'option',
    dropdownParent: null,
    controlInput: '<input type="text" autocomplete="off" size="1" />',
    copyClassesToDropdown: false,
    placeholder: null,
    hidePlaceholder: null,
    shouldLoad: function (query) {
        return query.length > 0;
    },
    /*
    load                 : null, // function(query, callback) { ... }
    score                : null, // function(search) { ... }
    onInitialize         : null, // function() { ... }
    onChange             : null, // function(value) { ... }
    onItemAdd            : null, // function(value, $item) { ... }
    onItemRemove         : null, // function(value) { ... }
    onClear              : null, // function() { ... }
    onOptionAdd          : null, // function(value, data) { ... }
    onOptionRemove       : null, // function(value) { ... }
    onOptionClear        : null, // function() { ... }
    onOptionGroupAdd     : null, // function(id, data) { ... }
    onOptionGroupRemove  : null, // function(id) { ... }
    onOptionGroupClear   : null, // function() { ... }
    onDropdownOpen       : null, // function(dropdown) { ... }
    onDropdownClose      : null, // function(dropdown) { ... }
    onType               : null, // function(str) { ... }
    onDelete             : null, // function(values) { ... }
    */
    render: {
    /*
    item: null,
    optgroup: null,
    optgroup_header: null,
    option: null,
    option_create: null
    */
    }
});
//# sourceMappingURL=defaults.js.map

/***/ }),

/***/ "./node_modules/tom-select/dist/esm/getSettings.js":
/*!*********************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/getSettings.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getSettings; }
/* harmony export */ });
/* harmony import */ var _defaults_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaults.js */ "./node_modules/tom-select/dist/esm/defaults.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/tom-select/dist/esm/utils.js");


function getSettings(input, settings_user) {
    var settings = Object.assign({}, _defaults_js__WEBPACK_IMPORTED_MODULE_0__["default"], settings_user);
    var attr_data = settings.dataAttr;
    var field_label = settings.labelField;
    var field_value = settings.valueField;
    var field_disabled = settings.disabledField;
    var field_optgroup = settings.optgroupField;
    var field_optgroup_label = settings.optgroupLabelField;
    var field_optgroup_value = settings.optgroupValueField;
    var tag_name = input.tagName.toLowerCase();
    var placeholder = input.getAttribute('placeholder') || input.getAttribute('data-placeholder');
    if (!placeholder && !settings.allowEmptyOption) {
        let option = input.querySelector('option[value=""]');
        if (option) {
            placeholder = option.textContent;
        }
    }
    var settings_element = {
        placeholder: placeholder,
        options: [],
        optgroups: [],
        items: [],
        maxItems: null,
    };
    /**
     * Initialize from a <select> element.
     *
     */
    var init_select = () => {
        var tagName;
        var options = settings_element.options;
        var optionsMap = {};
        var group_count = 1;
        let $order = 0;
        var readData = (el) => {
            var data = Object.assign({}, el.dataset); // get plain object from DOMStringMap
            var json = attr_data && data[attr_data];
            if (typeof json === 'string' && json.length) {
                data = Object.assign(data, JSON.parse(json));
            }
            return data;
        };
        var addOption = (option, group) => {
            var value = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.hash_key)(option.value);
            if (value == null)
                return;
            if (!value && !settings.allowEmptyOption)
                return;
            // if the option already exists, it's probably been
            // duplicated in another optgroup. in this case, push
            // the current group to the "optgroup" property on the
            // existing option so that it's rendered in both places.
            if (optionsMap.hasOwnProperty(value)) {
                if (group) {
                    var arr = optionsMap[value][field_optgroup];
                    if (!arr) {
                        optionsMap[value][field_optgroup] = group;
                    }
                    else if (!Array.isArray(arr)) {
                        optionsMap[value][field_optgroup] = [arr, group];
                    }
                    else {
                        arr.push(group);
                    }
                }
            }
            else {
                var option_data = readData(option);
                option_data[field_label] = option_data[field_label] || option.textContent;
                option_data[field_value] = option_data[field_value] || value;
                option_data[field_disabled] = option_data[field_disabled] || option.disabled;
                option_data[field_optgroup] = option_data[field_optgroup] || group;
                option_data.$option = option;
                option_data.$order = option_data.$order || ++$order;
                optionsMap[value] = option_data;
                options.push(option_data);
            }
            if (option.selected) {
                settings_element.items.push(value);
            }
        };
        var addGroup = (optgroup) => {
            var id, optgroup_data;
            optgroup_data = readData(optgroup);
            optgroup_data[field_optgroup_label] = optgroup_data[field_optgroup_label] || optgroup.getAttribute('label') || '';
            optgroup_data[field_optgroup_value] = optgroup_data[field_optgroup_value] || group_count++;
            optgroup_data[field_disabled] = optgroup_data[field_disabled] || optgroup.disabled;
            optgroup_data.$order = optgroup_data.$order || ++$order;
            settings_element.optgroups.push(optgroup_data);
            id = optgroup_data[field_optgroup_value];
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.iterate)(optgroup.children, (option) => {
                addOption(option, id);
            });
        };
        settings_element.maxItems = input.hasAttribute('multiple') ? null : 1;
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.iterate)(input.children, (child) => {
            tagName = child.tagName.toLowerCase();
            if (tagName === 'optgroup') {
                addGroup(child);
            }
            else if (tagName === 'option') {
                addOption(child);
            }
        });
    };
    /**
     * Initialize from a <input type="text"> element.
     *
     */
    var init_textbox = () => {
        const data_raw = input.getAttribute(attr_data);
        if (!data_raw) {
            var value = input.value.trim() || '';
            if (!settings.allowEmptyOption && !value.length)
                return;
            const values = value.split(settings.delimiter);
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.iterate)(values, (value) => {
                const option = {};
                option[field_label] = value;
                option[field_value] = value;
                settings_element.options.push(option);
            });
            settings_element.items = values;
        }
        else {
            settings_element.options = JSON.parse(data_raw);
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.iterate)(settings_element.options, (opt) => {
                settings_element.items.push(opt[field_value]);
            });
        }
    };
    if (tag_name === 'select') {
        init_select();
    }
    else {
        init_textbox();
    }
    return Object.assign({}, _defaults_js__WEBPACK_IMPORTED_MODULE_0__["default"], settings_element, settings_user);
}
;
//# sourceMappingURL=getSettings.js.map

/***/ }),

/***/ "./node_modules/tom-select/dist/esm/plugins/caret_position/plugin.js":
/*!***************************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/plugins/caret_position/plugin.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ plugin; }
/* harmony export */ });
/**
* Tom Select v2.4.3
* Licensed under the Apache License, Version 2.0 (the "License");
*/

/**
 * Converts a scalar to its best string representation
 * for hash keys and HTML attribute values.
 *
 * Transformations:
 *   'str'     -> 'str'
 *   null      -> ''
 *   undefined -> ''
 *   true      -> '1'
 *   false     -> '0'
 *   0         -> '0'
 *   1         -> '1'
 *
 */

/**
 * Iterates over arrays and hashes.
 *
 * ```
 * iterate(this.items, function(item, id) {
 *    // invoked for each item
 * });
 * ```
 *
 */
const iterate = (object, callback) => {
  if (Array.isArray(object)) {
    object.forEach(callback);
  } else {
    for (var key in object) {
      if (object.hasOwnProperty(key)) {
        callback(object[key], key);
      }
    }
  }
};

/**
 * Remove css classes
 *
 */
const removeClasses = (elmts, ...classes) => {
  var norm_classes = classesArray(classes);
  elmts = castAsArray(elmts);
  elmts.map(el => {
    norm_classes.map(cls => {
      el.classList.remove(cls);
    });
  });
};

/**
 * Return arguments
 *
 */
const classesArray = args => {
  var classes = [];
  iterate(args, _classes => {
    if (typeof _classes === 'string') {
      _classes = _classes.trim().split(/[\t\n\f\r\s]/);
    }
    if (Array.isArray(_classes)) {
      classes = classes.concat(_classes);
    }
  });
  return classes.filter(Boolean);
};

/**
 * Create an array from arg if it's not already an array
 *
 */
const castAsArray = arg => {
  if (!Array.isArray(arg)) {
    arg = [arg];
  }
  return arg;
};

/**
 * Get the index of an element amongst sibling nodes of the same type
 *
 */
const nodeIndex = (el, amongst) => {
  if (!el) return -1;
  amongst = amongst || el.nodeName;
  var i = 0;
  while (el = el.previousElementSibling) {
    if (el.matches(amongst)) {
      i++;
    }
  }
  return i;
};

/**
 * Plugin: "dropdown_input" (Tom Select)
 * Copyright (c) contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 */

function plugin () {
  var self = this;

  /**
   * Moves the caret to the specified index.
   *
   * The input must be moved by leaving it in place and moving the
   * siblings, due to the fact that focus cannot be restored once lost
   * on mobile webkit devices
   *
   */
  self.hook('instead', 'setCaret', new_pos => {
    if (self.settings.mode === 'single' || !self.control.contains(self.control_input)) {
      new_pos = self.items.length;
    } else {
      new_pos = Math.max(0, Math.min(self.items.length, new_pos));
      if (new_pos != self.caretPos && !self.isPending) {
        self.controlChildren().forEach((child, j) => {
          if (j < new_pos) {
            self.control_input.insertAdjacentElement('beforebegin', child);
          } else {
            self.control.appendChild(child);
          }
        });
      }
    }
    self.caretPos = new_pos;
  });
  self.hook('instead', 'moveCaret', direction => {
    if (!self.isFocused) return;

    // move caret before or after selected items
    const last_active = self.getLastActive(direction);
    if (last_active) {
      const idx = nodeIndex(last_active);
      self.setCaret(direction > 0 ? idx + 1 : idx);
      self.setActiveItem();
      removeClasses(last_active, 'last-active');

      // move caret left or right of current position
    } else {
      self.setCaret(self.caretPos + direction);
    }
  });
}


//# sourceMappingURL=plugin.js.map


/***/ }),

/***/ "./node_modules/tom-select/dist/esm/plugins/change_listener/plugin.js":
/*!****************************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/plugins/change_listener/plugin.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ plugin; }
/* harmony export */ });
/**
* Tom Select v2.4.3
* Licensed under the Apache License, Version 2.0 (the "License");
*/

/**
 * Converts a scalar to its best string representation
 * for hash keys and HTML attribute values.
 *
 * Transformations:
 *   'str'     -> 'str'
 *   null      -> ''
 *   undefined -> ''
 *   true      -> '1'
 *   false     -> '0'
 *   0         -> '0'
 *   1         -> '1'
 *
 */

/**
 * Add event helper
 *
 */
const addEvent = (target, type, callback, options) => {
  target.addEventListener(type, callback, options);
};

/**
 * Plugin: "change_listener" (Tom Select)
 * Copyright (c) contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 */

function plugin () {
  addEvent(this.input, 'change', () => {
    this.sync();
  });
}


//# sourceMappingURL=plugin.js.map


/***/ }),

/***/ "./node_modules/tom-select/dist/esm/plugins/checkbox_options/plugin.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/plugins/checkbox_options/plugin.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ plugin; }
/* harmony export */ });
/**
* Tom Select v2.4.3
* Licensed under the Apache License, Version 2.0 (the "License");
*/

/**
 * Converts a scalar to its best string representation
 * for hash keys and HTML attribute values.
 *
 * Transformations:
 *   'str'     -> 'str'
 *   null      -> ''
 *   undefined -> ''
 *   true      -> '1'
 *   false     -> '0'
 *   0         -> '0'
 *   1         -> '1'
 *
 */
const hash_key = value => {
  if (typeof value === 'undefined' || value === null) return null;
  return get_hash(value);
};
const get_hash = value => {
  if (typeof value === 'boolean') return value ? '1' : '0';
  return value + '';
};

/**
 * Prevent default
 *
 */
const preventDefault = (evt, stop = false) => {
  if (evt) {
    evt.preventDefault();
    if (stop) {
      evt.stopPropagation();
    }
  }
};

/**
 * Return a dom element from either a dom query string, jQuery object, a dom element or html string
 * https://stackoverflow.com/questions/494143/creating-a-new-dom-element-from-an-html-string-using-built-in-dom-methods-or-pro/35385518#35385518
 *
 * param query should be {}
 */
const getDom = query => {
  if (query.jquery) {
    return query[0];
  }
  if (query instanceof HTMLElement) {
    return query;
  }
  if (isHtmlString(query)) {
    var tpl = document.createElement('template');
    tpl.innerHTML = query.trim(); // Never return a text node of whitespace as the result
    return tpl.content.firstChild;
  }
  return document.querySelector(query);
};
const isHtmlString = arg => {
  if (typeof arg === 'string' && arg.indexOf('<') > -1) {
    return true;
  }
  return false;
};

/**
 * Plugin: "checkbox_options" (Tom Select)
 * Copyright (c) contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 */

function plugin (userOptions) {
  var self = this;
  var orig_onOptionSelect = self.onOptionSelect;
  self.settings.hideSelected = false;
  const cbOptions = Object.assign({
    // so that the user may add different ones as well
    className: "tomselect-checkbox",
    // the following default to the historic plugin's values
    checkedClassNames: undefined,
    uncheckedClassNames: undefined
  }, userOptions);
  var UpdateChecked = function UpdateChecked(checkbox, toCheck) {
    if (toCheck) {
      checkbox.checked = true;
      if (cbOptions.uncheckedClassNames) {
        checkbox.classList.remove(...cbOptions.uncheckedClassNames);
      }
      if (cbOptions.checkedClassNames) {
        checkbox.classList.add(...cbOptions.checkedClassNames);
      }
    } else {
      checkbox.checked = false;
      if (cbOptions.checkedClassNames) {
        checkbox.classList.remove(...cbOptions.checkedClassNames);
      }
      if (cbOptions.uncheckedClassNames) {
        checkbox.classList.add(...cbOptions.uncheckedClassNames);
      }
    }
  };

  // update the checkbox for an option
  var UpdateCheckbox = function UpdateCheckbox(option) {
    setTimeout(() => {
      var checkbox = option.querySelector('input.' + cbOptions.className);
      if (checkbox instanceof HTMLInputElement) {
        UpdateChecked(checkbox, option.classList.contains('selected'));
      }
    }, 1);
  };

  // add checkbox to option template
  self.hook('after', 'setupTemplates', () => {
    var orig_render_option = self.settings.render.option;
    self.settings.render.option = (data, escape_html) => {
      var rendered = getDom(orig_render_option.call(self, data, escape_html));
      var checkbox = document.createElement('input');
      if (cbOptions.className) {
        checkbox.classList.add(cbOptions.className);
      }
      checkbox.addEventListener('click', function (evt) {
        preventDefault(evt);
      });
      checkbox.type = 'checkbox';
      const hashed = hash_key(data[self.settings.valueField]);
      UpdateChecked(checkbox, !!(hashed && self.items.indexOf(hashed) > -1));
      rendered.prepend(checkbox);
      return rendered;
    };
  });

  // uncheck when item removed
  self.on('item_remove', value => {
    var option = self.getOption(value);
    if (option) {
      // if dropdown hasn't been opened yet, the option won't exist
      option.classList.remove('selected'); // selected class won't be removed yet
      UpdateCheckbox(option);
    }
  });

  // check when item added
  self.on('item_add', value => {
    var option = self.getOption(value);
    if (option) {
      // if dropdown hasn't been opened yet, the option won't exist
      UpdateCheckbox(option);
    }
  });

  // remove items when selected option is clicked
  self.hook('instead', 'onOptionSelect', (evt, option) => {
    if (option.classList.contains('selected')) {
      option.classList.remove('selected');
      self.removeItem(option.dataset.value);
      self.refreshOptions();
      preventDefault(evt, true);
      return;
    }
    orig_onOptionSelect.call(self, evt, option);
    UpdateCheckbox(option);
  });
}


//# sourceMappingURL=plugin.js.map


/***/ }),

/***/ "./node_modules/tom-select/dist/esm/plugins/clear_button/plugin.js":
/*!*************************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/plugins/clear_button/plugin.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ plugin; }
/* harmony export */ });
/**
* Tom Select v2.4.3
* Licensed under the Apache License, Version 2.0 (the "License");
*/

/**
 * Return a dom element from either a dom query string, jQuery object, a dom element or html string
 * https://stackoverflow.com/questions/494143/creating-a-new-dom-element-from-an-html-string-using-built-in-dom-methods-or-pro/35385518#35385518
 *
 * param query should be {}
 */
const getDom = query => {
  if (query.jquery) {
    return query[0];
  }
  if (query instanceof HTMLElement) {
    return query;
  }
  if (isHtmlString(query)) {
    var tpl = document.createElement('template');
    tpl.innerHTML = query.trim(); // Never return a text node of whitespace as the result
    return tpl.content.firstChild;
  }
  return document.querySelector(query);
};
const isHtmlString = arg => {
  if (typeof arg === 'string' && arg.indexOf('<') > -1) {
    return true;
  }
  return false;
};

/**
 * Plugin: "dropdown_header" (Tom Select)
 * Copyright (c) contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 */

function plugin (userOptions) {
  const self = this;
  const options = Object.assign({
    className: 'clear-button',
    title: 'Clear All',
    html: data => {
      return `<div class="${data.className}" title="${data.title}">&#10799;</div>`;
    }
  }, userOptions);
  self.on('initialize', () => {
    var button = getDom(options.html(options));
    button.addEventListener('click', evt => {
      if (self.isLocked) return;
      self.clear();
      if (self.settings.mode === 'single' && self.settings.allowEmptyOption) {
        self.addItem('');
      }
      evt.preventDefault();
      evt.stopPropagation();
    });
    self.control.appendChild(button);
  });
}


//# sourceMappingURL=plugin.js.map


/***/ }),

/***/ "./node_modules/tom-select/dist/esm/plugins/drag_drop/plugin.js":
/*!**********************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/plugins/drag_drop/plugin.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ plugin; }
/* harmony export */ });
/**
* Tom Select v2.4.3
* Licensed under the Apache License, Version 2.0 (the "License");
*/

/**
 * Converts a scalar to its best string representation
 * for hash keys and HTML attribute values.
 *
 * Transformations:
 *   'str'     -> 'str'
 *   null      -> ''
 *   undefined -> ''
 *   true      -> '1'
 *   false     -> '0'
 *   0         -> '0'
 *   1         -> '1'
 *
 */

/**
 * Prevent default
 *
 */
const preventDefault = (evt, stop = false) => {
  if (evt) {
    evt.preventDefault();
    if (stop) {
      evt.stopPropagation();
    }
  }
};

/**
 * Add event helper
 *
 */
const addEvent = (target, type, callback, options) => {
  target.addEventListener(type, callback, options);
};

/**
 * Iterates over arrays and hashes.
 *
 * ```
 * iterate(this.items, function(item, id) {
 *    // invoked for each item
 * });
 * ```
 *
 */
const iterate = (object, callback) => {
  if (Array.isArray(object)) {
    object.forEach(callback);
  } else {
    for (var key in object) {
      if (object.hasOwnProperty(key)) {
        callback(object[key], key);
      }
    }
  }
};

/**
 * Return a dom element from either a dom query string, jQuery object, a dom element or html string
 * https://stackoverflow.com/questions/494143/creating-a-new-dom-element-from-an-html-string-using-built-in-dom-methods-or-pro/35385518#35385518
 *
 * param query should be {}
 */
const getDom = query => {
  if (query.jquery) {
    return query[0];
  }
  if (query instanceof HTMLElement) {
    return query;
  }
  if (isHtmlString(query)) {
    var tpl = document.createElement('template');
    tpl.innerHTML = query.trim(); // Never return a text node of whitespace as the result
    return tpl.content.firstChild;
  }
  return document.querySelector(query);
};
const isHtmlString = arg => {
  if (typeof arg === 'string' && arg.indexOf('<') > -1) {
    return true;
  }
  return false;
};

/**
 * Set attributes of an element
 *
 */
const setAttr = (el, attrs) => {
  iterate(attrs, (val, attr) => {
    if (val == null) {
      el.removeAttribute(attr);
    } else {
      el.setAttribute(attr, '' + val);
    }
  });
};

/**
 * Plugin: "drag_drop" (Tom Select)
 * Copyright (c) contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 */

const insertAfter = (referenceNode, newNode) => {
  var _referenceNode$parent;
  (_referenceNode$parent = referenceNode.parentNode) == null || _referenceNode$parent.insertBefore(newNode, referenceNode.nextSibling);
};
const insertBefore = (referenceNode, newNode) => {
  var _referenceNode$parent2;
  (_referenceNode$parent2 = referenceNode.parentNode) == null || _referenceNode$parent2.insertBefore(newNode, referenceNode);
};
const isBefore = (referenceNode, newNode) => {
  do {
    var _newNode;
    newNode = (_newNode = newNode) == null ? void 0 : _newNode.previousElementSibling;
    if (referenceNode == newNode) {
      return true;
    }
  } while (newNode && newNode.previousElementSibling);
  return false;
};
function plugin () {
  var self = this;
  if (self.settings.mode !== 'multi') return;
  var orig_lock = self.lock;
  var orig_unlock = self.unlock;
  let sortable = true;
  let drag_item;

  /**
   * Add draggable attribute to item
   */
  self.hook('after', 'setupTemplates', () => {
    var orig_render_item = self.settings.render.item;
    self.settings.render.item = (data, escape) => {
      const item = getDom(orig_render_item.call(self, data, escape));
      setAttr(item, {
        'draggable': 'true'
      });

      // prevent doc_mousedown (see tom-select.ts)
      const mousedown = evt => {
        if (!sortable) preventDefault(evt);
        evt.stopPropagation();
      };
      const dragStart = evt => {
        drag_item = item;
        setTimeout(() => {
          item.classList.add('ts-dragging');
        }, 0);
      };
      const dragOver = evt => {
        evt.preventDefault();
        item.classList.add('ts-drag-over');
        moveitem(item, drag_item);
      };
      const dragLeave = () => {
        item.classList.remove('ts-drag-over');
      };
      const moveitem = (targetitem, dragitem) => {
        if (dragitem === undefined) return;
        if (isBefore(dragitem, item)) {
          insertAfter(targetitem, dragitem);
        } else {
          insertBefore(targetitem, dragitem);
        }
      };
      const dragend = () => {
        var _drag_item;
        document.querySelectorAll('.ts-drag-over').forEach(el => el.classList.remove('ts-drag-over'));
        (_drag_item = drag_item) == null || _drag_item.classList.remove('ts-dragging');
        drag_item = undefined;
        var values = [];
        self.control.querySelectorAll(`[data-value]`).forEach(el => {
          if (el.dataset.value) {
            let value = el.dataset.value;
            if (value) {
              values.push(value);
            }
          }
        });
        self.setValue(values);
      };
      addEvent(item, 'mousedown', mousedown);
      addEvent(item, 'dragstart', dragStart);
      addEvent(item, 'dragenter', dragOver);
      addEvent(item, 'dragover', dragOver);
      addEvent(item, 'dragleave', dragLeave);
      addEvent(item, 'dragend', dragend);
      return item;
    };
  });
  self.hook('instead', 'lock', () => {
    sortable = false;
    return orig_lock.call(self);
  });
  self.hook('instead', 'unlock', () => {
    sortable = true;
    return orig_unlock.call(self);
  });
}


//# sourceMappingURL=plugin.js.map


/***/ }),

/***/ "./node_modules/tom-select/dist/esm/plugins/dropdown_header/plugin.js":
/*!****************************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/plugins/dropdown_header/plugin.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ plugin; }
/* harmony export */ });
/**
* Tom Select v2.4.3
* Licensed under the Apache License, Version 2.0 (the "License");
*/

/**
 * Converts a scalar to its best string representation
 * for hash keys and HTML attribute values.
 *
 * Transformations:
 *   'str'     -> 'str'
 *   null      -> ''
 *   undefined -> ''
 *   true      -> '1'
 *   false     -> '0'
 *   0         -> '0'
 *   1         -> '1'
 *
 */

/**
 * Prevent default
 *
 */
const preventDefault = (evt, stop = false) => {
  if (evt) {
    evt.preventDefault();
    if (stop) {
      evt.stopPropagation();
    }
  }
};

/**
 * Return a dom element from either a dom query string, jQuery object, a dom element or html string
 * https://stackoverflow.com/questions/494143/creating-a-new-dom-element-from-an-html-string-using-built-in-dom-methods-or-pro/35385518#35385518
 *
 * param query should be {}
 */
const getDom = query => {
  if (query.jquery) {
    return query[0];
  }
  if (query instanceof HTMLElement) {
    return query;
  }
  if (isHtmlString(query)) {
    var tpl = document.createElement('template');
    tpl.innerHTML = query.trim(); // Never return a text node of whitespace as the result
    return tpl.content.firstChild;
  }
  return document.querySelector(query);
};
const isHtmlString = arg => {
  if (typeof arg === 'string' && arg.indexOf('<') > -1) {
    return true;
  }
  return false;
};

/**
 * Plugin: "dropdown_header" (Tom Select)
 * Copyright (c) contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 */

function plugin (userOptions) {
  const self = this;
  const options = Object.assign({
    title: 'Untitled',
    headerClass: 'dropdown-header',
    titleRowClass: 'dropdown-header-title',
    labelClass: 'dropdown-header-label',
    closeClass: 'dropdown-header-close',
    html: data => {
      return '<div class="' + data.headerClass + '">' + '<div class="' + data.titleRowClass + '">' + '<span class="' + data.labelClass + '">' + data.title + '</span>' + '<a class="' + data.closeClass + '">&times;</a>' + '</div>' + '</div>';
    }
  }, userOptions);
  self.on('initialize', () => {
    var header = getDom(options.html(options));
    var close_link = header.querySelector('.' + options.closeClass);
    if (close_link) {
      close_link.addEventListener('click', evt => {
        preventDefault(evt, true);
        self.close();
      });
    }
    self.dropdown.insertBefore(header, self.dropdown.firstChild);
  });
}


//# sourceMappingURL=plugin.js.map


/***/ }),

/***/ "./node_modules/tom-select/dist/esm/plugins/dropdown_input/plugin.js":
/*!***************************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/plugins/dropdown_input/plugin.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ plugin; }
/* harmony export */ });
/**
* Tom Select v2.4.3
* Licensed under the Apache License, Version 2.0 (the "License");
*/

const KEY_ESC = 27;
const KEY_TAB = 9;
 // ctrl key or apple key for ma

/**
 * Converts a scalar to its best string representation
 * for hash keys and HTML attribute values.
 *
 * Transformations:
 *   'str'     -> 'str'
 *   null      -> ''
 *   undefined -> ''
 *   true      -> '1'
 *   false     -> '0'
 *   0         -> '0'
 *   1         -> '1'
 *
 */

/**
 * Prevent default
 *
 */
const preventDefault = (evt, stop = false) => {
  if (evt) {
    evt.preventDefault();
    if (stop) {
      evt.stopPropagation();
    }
  }
};

/**
 * Add event helper
 *
 */
const addEvent = (target, type, callback, options) => {
  target.addEventListener(type, callback, options);
};

/**
 * Iterates over arrays and hashes.
 *
 * ```
 * iterate(this.items, function(item, id) {
 *    // invoked for each item
 * });
 * ```
 *
 */
const iterate = (object, callback) => {
  if (Array.isArray(object)) {
    object.forEach(callback);
  } else {
    for (var key in object) {
      if (object.hasOwnProperty(key)) {
        callback(object[key], key);
      }
    }
  }
};

/**
 * Return a dom element from either a dom query string, jQuery object, a dom element or html string
 * https://stackoverflow.com/questions/494143/creating-a-new-dom-element-from-an-html-string-using-built-in-dom-methods-or-pro/35385518#35385518
 *
 * param query should be {}
 */
const getDom = query => {
  if (query.jquery) {
    return query[0];
  }
  if (query instanceof HTMLElement) {
    return query;
  }
  if (isHtmlString(query)) {
    var tpl = document.createElement('template');
    tpl.innerHTML = query.trim(); // Never return a text node of whitespace as the result
    return tpl.content.firstChild;
  }
  return document.querySelector(query);
};
const isHtmlString = arg => {
  if (typeof arg === 'string' && arg.indexOf('<') > -1) {
    return true;
  }
  return false;
};

/**
 * Add css classes
 *
 */
const addClasses = (elmts, ...classes) => {
  var norm_classes = classesArray(classes);
  elmts = castAsArray(elmts);
  elmts.map(el => {
    norm_classes.map(cls => {
      el.classList.add(cls);
    });
  });
};

/**
 * Return arguments
 *
 */
const classesArray = args => {
  var classes = [];
  iterate(args, _classes => {
    if (typeof _classes === 'string') {
      _classes = _classes.trim().split(/[\t\n\f\r\s]/);
    }
    if (Array.isArray(_classes)) {
      classes = classes.concat(_classes);
    }
  });
  return classes.filter(Boolean);
};

/**
 * Create an array from arg if it's not already an array
 *
 */
const castAsArray = arg => {
  if (!Array.isArray(arg)) {
    arg = [arg];
  }
  return arg;
};

/**
 * Plugin: "dropdown_input" (Tom Select)
 * Copyright (c) contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 */

function plugin () {
  const self = this;
  self.settings.shouldOpen = true; // make sure the input is shown even if there are no options to display in the dropdown

  self.hook('before', 'setup', () => {
    self.focus_node = self.control;
    addClasses(self.control_input, 'dropdown-input');
    const div = getDom('<div class="dropdown-input-wrap">');
    div.append(self.control_input);
    self.dropdown.insertBefore(div, self.dropdown.firstChild);

    // set a placeholder in the select control
    const placeholder = getDom('<input class="items-placeholder" tabindex="-1" />');
    placeholder.placeholder = self.settings.placeholder || '';
    self.control.append(placeholder);
  });
  self.on('initialize', () => {
    // set tabIndex on control to -1, otherwise [shift+tab] will put focus right back on control_input
    self.control_input.addEventListener('keydown', evt => {
      //addEvent(self.control_input,'keydown' as const,(evt:KeyboardEvent) =>{
      switch (evt.keyCode) {
        case KEY_ESC:
          if (self.isOpen) {
            preventDefault(evt, true);
            self.close();
          }
          self.clearActiveItems();
          return;
        case KEY_TAB:
          self.focus_node.tabIndex = -1;
          break;
      }
      return self.onKeyDown.call(self, evt);
    });
    self.on('blur', () => {
      self.focus_node.tabIndex = self.isDisabled ? -1 : self.tabIndex;
    });

    // give the control_input focus when the dropdown is open
    self.on('dropdown_open', () => {
      self.control_input.focus();
    });

    // prevent onBlur from closing when focus is on the control_input
    const orig_onBlur = self.onBlur;
    self.hook('instead', 'onBlur', evt => {
      if (evt && evt.relatedTarget == self.control_input) return;
      return orig_onBlur.call(self);
    });
    addEvent(self.control_input, 'blur', () => self.onBlur());

    // return focus to control to allow further keyboard input
    self.hook('before', 'close', () => {
      if (!self.isOpen) return;
      self.focus_node.focus({
        preventScroll: true
      });
    });
  });
}


//# sourceMappingURL=plugin.js.map


/***/ }),

/***/ "./node_modules/tom-select/dist/esm/plugins/input_autogrow/plugin.js":
/*!***************************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/plugins/input_autogrow/plugin.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ plugin; }
/* harmony export */ });
/**
* Tom Select v2.4.3
* Licensed under the Apache License, Version 2.0 (the "License");
*/

/**
 * Converts a scalar to its best string representation
 * for hash keys and HTML attribute values.
 *
 * Transformations:
 *   'str'     -> 'str'
 *   null      -> ''
 *   undefined -> ''
 *   true      -> '1'
 *   false     -> '0'
 *   0         -> '0'
 *   1         -> '1'
 *
 */

/**
 * Add event helper
 *
 */
const addEvent = (target, type, callback, options) => {
  target.addEventListener(type, callback, options);
};

/**
 * Plugin: "input_autogrow" (Tom Select)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 */

function plugin () {
  var self = this;
  self.on('initialize', () => {
    var test_input = document.createElement('span');
    var control = self.control_input;
    test_input.style.cssText = 'position:absolute; top:-99999px; left:-99999px; width:auto; padding:0; white-space:pre; ';
    self.wrapper.appendChild(test_input);
    var transfer_styles = ['letterSpacing', 'fontSize', 'fontFamily', 'fontWeight', 'textTransform'];
    for (const style_name of transfer_styles) {
      // @ts-ignore TS7015 https://stackoverflow.com/a/50506154/697576
      test_input.style[style_name] = control.style[style_name];
    }

    /**
     * Set the control width
     *
     */
    var resize = () => {
      test_input.textContent = control.value;
      control.style.width = test_input.clientWidth + 'px';
    };
    resize();
    self.on('update item_add item_remove', resize);
    addEvent(control, 'input', resize);
    addEvent(control, 'keyup', resize);
    addEvent(control, 'blur', resize);
    addEvent(control, 'update', resize);
  });
}


//# sourceMappingURL=plugin.js.map


/***/ }),

/***/ "./node_modules/tom-select/dist/esm/plugins/no_active_items/plugin.js":
/*!****************************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/plugins/no_active_items/plugin.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ plugin; }
/* harmony export */ });
/**
* Tom Select v2.4.3
* Licensed under the Apache License, Version 2.0 (the "License");
*/

/**
 * Plugin: "no_active_items" (Tom Select)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 */

function plugin () {
  this.hook('instead', 'setActiveItem', () => {});
  this.hook('instead', 'selectAll', () => {});
}


//# sourceMappingURL=plugin.js.map


/***/ }),

/***/ "./node_modules/tom-select/dist/esm/plugins/no_backspace_delete/plugin.js":
/*!********************************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/plugins/no_backspace_delete/plugin.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ plugin; }
/* harmony export */ });
/**
* Tom Select v2.4.3
* Licensed under the Apache License, Version 2.0 (the "License");
*/

/**
 * Plugin: "input_autogrow" (Tom Select)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 */

function plugin () {
  var self = this;
  var orig_deleteSelection = self.deleteSelection;
  this.hook('instead', 'deleteSelection', evt => {
    if (self.activeItems.length) {
      return orig_deleteSelection.call(self, evt);
    }
    return false;
  });
}


//# sourceMappingURL=plugin.js.map


/***/ }),

/***/ "./node_modules/tom-select/dist/esm/plugins/optgroup_columns/plugin.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/plugins/optgroup_columns/plugin.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ plugin; }
/* harmony export */ });
/**
* Tom Select v2.4.3
* Licensed under the Apache License, Version 2.0 (the "License");
*/

const KEY_LEFT = 37;
const KEY_RIGHT = 39;
 // ctrl key or apple key for ma

/**
 * Get the closest node to the evt.target matching the selector
 * Stops at wrapper
 *
 */
const parentMatch = (target, selector, wrapper) => {
  while (target && target.matches) {
    if (target.matches(selector)) {
      return target;
    }
    target = target.parentNode;
  }
};

/**
 * Get the index of an element amongst sibling nodes of the same type
 *
 */
const nodeIndex = (el, amongst) => {
  if (!el) return -1;
  amongst = amongst || el.nodeName;
  var i = 0;
  while (el = el.previousElementSibling) {
    if (el.matches(amongst)) {
      i++;
    }
  }
  return i;
};

/**
 * Plugin: "optgroup_columns" (Tom Select.js)
 * Copyright (c) contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 */

function plugin () {
  var self = this;
  var orig_keydown = self.onKeyDown;
  self.hook('instead', 'onKeyDown', evt => {
    var index, option, options, optgroup;
    if (!self.isOpen || !(evt.keyCode === KEY_LEFT || evt.keyCode === KEY_RIGHT)) {
      return orig_keydown.call(self, evt);
    }
    self.ignoreHover = true;
    optgroup = parentMatch(self.activeOption, '[data-group]');
    index = nodeIndex(self.activeOption, '[data-selectable]');
    if (!optgroup) {
      return;
    }
    if (evt.keyCode === KEY_LEFT) {
      optgroup = optgroup.previousSibling;
    } else {
      optgroup = optgroup.nextSibling;
    }
    if (!optgroup) {
      return;
    }
    options = optgroup.querySelectorAll('[data-selectable]');
    option = options[Math.min(options.length - 1, index)];
    if (option) {
      self.setActiveOption(option);
    }
  });
}


//# sourceMappingURL=plugin.js.map


/***/ }),

/***/ "./node_modules/tom-select/dist/esm/plugins/remove_button/plugin.js":
/*!**************************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/plugins/remove_button/plugin.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ plugin; }
/* harmony export */ });
/**
* Tom Select v2.4.3
* Licensed under the Apache License, Version 2.0 (the "License");
*/

/**
 * Converts a scalar to its best string representation
 * for hash keys and HTML attribute values.
 *
 * Transformations:
 *   'str'     -> 'str'
 *   null      -> ''
 *   undefined -> ''
 *   true      -> '1'
 *   false     -> '0'
 *   0         -> '0'
 *   1         -> '1'
 *
 */

/**
 * Escapes a string for use within HTML.
 *
 */
const escape_html = str => {
  return (str + '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
};

/**
 * Prevent default
 *
 */
const preventDefault = (evt, stop = false) => {
  if (evt) {
    evt.preventDefault();
    if (stop) {
      evt.stopPropagation();
    }
  }
};

/**
 * Add event helper
 *
 */
const addEvent = (target, type, callback, options) => {
  target.addEventListener(type, callback, options);
};

/**
 * Return a dom element from either a dom query string, jQuery object, a dom element or html string
 * https://stackoverflow.com/questions/494143/creating-a-new-dom-element-from-an-html-string-using-built-in-dom-methods-or-pro/35385518#35385518
 *
 * param query should be {}
 */
const getDom = query => {
  if (query.jquery) {
    return query[0];
  }
  if (query instanceof HTMLElement) {
    return query;
  }
  if (isHtmlString(query)) {
    var tpl = document.createElement('template');
    tpl.innerHTML = query.trim(); // Never return a text node of whitespace as the result
    return tpl.content.firstChild;
  }
  return document.querySelector(query);
};
const isHtmlString = arg => {
  if (typeof arg === 'string' && arg.indexOf('<') > -1) {
    return true;
  }
  return false;
};

/**
 * Plugin: "remove_button" (Tom Select)
 * Copyright (c) contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 */

function plugin (userOptions) {
  const options = Object.assign({
    label: '&times;',
    title: 'Remove',
    className: 'remove',
    append: true
  }, userOptions);

  //options.className = 'remove-single';
  var self = this;

  // override the render method to add remove button to each item
  if (!options.append) {
    return;
  }
  var html = '<a href="javascript:void(0)" class="' + options.className + '" tabindex="-1" title="' + escape_html(options.title) + '">' + options.label + '</a>';
  self.hook('after', 'setupTemplates', () => {
    var orig_render_item = self.settings.render.item;
    self.settings.render.item = (data, escape) => {
      var item = getDom(orig_render_item.call(self, data, escape));
      var close_button = getDom(html);
      item.appendChild(close_button);
      addEvent(close_button, 'mousedown', evt => {
        preventDefault(evt, true);
      });
      addEvent(close_button, 'click', evt => {
        if (self.isLocked) return;

        // propagating will trigger the dropdown to show for single mode
        preventDefault(evt, true);
        if (self.isLocked) return;
        if (!self.shouldDelete([item], evt)) return;
        self.removeItem(item);
        self.refreshOptions(false);
        self.inputState();
      });
      return item;
    };
  });
}


//# sourceMappingURL=plugin.js.map


/***/ }),

/***/ "./node_modules/tom-select/dist/esm/plugins/restore_on_backspace/plugin.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/plugins/restore_on_backspace/plugin.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ plugin; }
/* harmony export */ });
/**
* Tom Select v2.4.3
* Licensed under the Apache License, Version 2.0 (the "License");
*/

/**
 * Plugin: "restore_on_backspace" (Tom Select)
 * Copyright (c) contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 */

function plugin (userOptions) {
  const self = this;
  const options = Object.assign({
    text: option => {
      return option[self.settings.labelField];
    }
  }, userOptions);
  self.on('item_remove', function (value) {
    if (!self.isFocused) {
      return;
    }
    if (self.control_input.value.trim() === '') {
      var option = self.options[value];
      if (option) {
        self.setTextboxValue(options.text.call(self, option));
      }
    }
  });
}


//# sourceMappingURL=plugin.js.map


/***/ }),

/***/ "./node_modules/tom-select/dist/esm/plugins/virtual_scroll/plugin.js":
/*!***************************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/plugins/virtual_scroll/plugin.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ plugin; }
/* harmony export */ });
/**
* Tom Select v2.4.3
* Licensed under the Apache License, Version 2.0 (the "License");
*/

/**
 * Converts a scalar to its best string representation
 * for hash keys and HTML attribute values.
 *
 * Transformations:
 *   'str'     -> 'str'
 *   null      -> ''
 *   undefined -> ''
 *   true      -> '1'
 *   false     -> '0'
 *   0         -> '0'
 *   1         -> '1'
 *
 */

/**
 * Iterates over arrays and hashes.
 *
 * ```
 * iterate(this.items, function(item, id) {
 *    // invoked for each item
 * });
 * ```
 *
 */
const iterate = (object, callback) => {
  if (Array.isArray(object)) {
    object.forEach(callback);
  } else {
    for (var key in object) {
      if (object.hasOwnProperty(key)) {
        callback(object[key], key);
      }
    }
  }
};

/**
 * Add css classes
 *
 */
const addClasses = (elmts, ...classes) => {
  var norm_classes = classesArray(classes);
  elmts = castAsArray(elmts);
  elmts.map(el => {
    norm_classes.map(cls => {
      el.classList.add(cls);
    });
  });
};

/**
 * Return arguments
 *
 */
const classesArray = args => {
  var classes = [];
  iterate(args, _classes => {
    if (typeof _classes === 'string') {
      _classes = _classes.trim().split(/[\t\n\f\r\s]/);
    }
    if (Array.isArray(_classes)) {
      classes = classes.concat(_classes);
    }
  });
  return classes.filter(Boolean);
};

/**
 * Create an array from arg if it's not already an array
 *
 */
const castAsArray = arg => {
  if (!Array.isArray(arg)) {
    arg = [arg];
  }
  return arg;
};

/**
 * Plugin: "restore_on_backspace" (Tom Select)
 * Copyright (c) contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 */

function plugin () {
  const self = this;
  const orig_canLoad = self.canLoad;
  const orig_clearActiveOption = self.clearActiveOption;
  const orig_loadCallback = self.loadCallback;
  var pagination = {};
  var dropdown_content;
  var loading_more = false;
  var load_more_opt;
  var default_values = [];
  if (!self.settings.shouldLoadMore) {
    // return true if additional results should be loaded
    self.settings.shouldLoadMore = () => {
      const scroll_percent = dropdown_content.clientHeight / (dropdown_content.scrollHeight - dropdown_content.scrollTop);
      if (scroll_percent > 0.9) {
        return true;
      }
      if (self.activeOption) {
        var selectable = self.selectable();
        var index = Array.from(selectable).indexOf(self.activeOption);
        if (index >= selectable.length - 2) {
          return true;
        }
      }
      return false;
    };
  }
  if (!self.settings.firstUrl) {
    throw 'virtual_scroll plugin requires a firstUrl() method';
  }

  // in order for virtual scrolling to work,
  // options need to be ordered the same way they're returned from the remote data source
  self.settings.sortField = [{
    field: '$order'
  }, {
    field: '$score'
  }];

  // can we load more results for given query?
  const canLoadMore = query => {
    if (typeof self.settings.maxOptions === 'number' && dropdown_content.children.length >= self.settings.maxOptions) {
      return false;
    }
    if (query in pagination && pagination[query]) {
      return true;
    }
    return false;
  };
  const clearFilter = (option, value) => {
    if (self.items.indexOf(value) >= 0 || default_values.indexOf(value) >= 0) {
      return true;
    }
    return false;
  };

  // set the next url that will be
  self.setNextUrl = (value, next_url) => {
    pagination[value] = next_url;
  };

  // getUrl() to be used in settings.load()
  self.getUrl = query => {
    if (query in pagination) {
      const next_url = pagination[query];
      pagination[query] = false;
      return next_url;
    }

    // if the user goes back to a previous query
    // we need to load the first page again
    self.clearPagination();
    return self.settings.firstUrl.call(self, query);
  };

  // clear pagination
  self.clearPagination = () => {
    pagination = {};
  };

  // don't clear the active option (and cause unwanted dropdown scroll)
  // while loading more results
  self.hook('instead', 'clearActiveOption', () => {
    if (loading_more) {
      return;
    }
    return orig_clearActiveOption.call(self);
  });

  // override the canLoad method
  self.hook('instead', 'canLoad', query => {
    // first time the query has been seen
    if (!(query in pagination)) {
      return orig_canLoad.call(self, query);
    }
    return canLoadMore(query);
  });

  // wrap the load
  self.hook('instead', 'loadCallback', (options, optgroups) => {
    if (!loading_more) {
      self.clearOptions(clearFilter);
    } else if (load_more_opt) {
      const first_option = options[0];
      if (first_option !== undefined) {
        load_more_opt.dataset.value = first_option[self.settings.valueField];
      }
    }
    orig_loadCallback.call(self, options, optgroups);
    loading_more = false;
  });

  // add templates to dropdown
  //	loading_more if we have another url in the queue
  //	no_more_results if we don't have another url in the queue
  self.hook('after', 'refreshOptions', () => {
    const query = self.lastValue;
    var option;
    if (canLoadMore(query)) {
      option = self.render('loading_more', {
        query: query
      });
      if (option) {
        option.setAttribute('data-selectable', ''); // so that navigating dropdown with [down] keypresses can navigate to this node
        load_more_opt = option;
      }
    } else if (query in pagination && !dropdown_content.querySelector('.no-results')) {
      option = self.render('no_more_results', {
        query: query
      });
    }
    if (option) {
      addClasses(option, self.settings.optionClass);
      dropdown_content.append(option);
    }
  });

  // add scroll listener and default templates
  self.on('initialize', () => {
    default_values = Object.keys(self.options);
    dropdown_content = self.dropdown_content;

    // default templates
    self.settings.render = Object.assign({}, {
      loading_more: () => {
        return `<div class="loading-more-results">Loading more results ... </div>`;
      },
      no_more_results: () => {
        return `<div class="no-more-results">No more results</div>`;
      }
    }, self.settings.render);

    // watch dropdown content scroll position
    dropdown_content.addEventListener('scroll', () => {
      if (!self.settings.shouldLoadMore.call(self)) {
        return;
      }

      // !important: this will get checked again in load() but we still need to check here otherwise loading_more will be set to true
      if (!canLoadMore(self.lastValue)) {
        return;
      }

      // don't call load() too much
      if (loading_more) return;
      loading_more = true;
      self.load.call(self, self.lastValue);
    });
  });
}


//# sourceMappingURL=plugin.js.map


/***/ }),

/***/ "./node_modules/tom-select/dist/esm/tom-select.complete.js":
/*!*****************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/tom-select.complete.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tom_select_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tom-select.js */ "./node_modules/tom-select/dist/esm/tom-select.js");
/* harmony import */ var _plugins_change_listener_plugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugins/change_listener/plugin.js */ "./node_modules/tom-select/dist/esm/plugins/change_listener/plugin.js");
/* harmony import */ var _plugins_checkbox_options_plugin_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plugins/checkbox_options/plugin.js */ "./node_modules/tom-select/dist/esm/plugins/checkbox_options/plugin.js");
/* harmony import */ var _plugins_clear_button_plugin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plugins/clear_button/plugin.js */ "./node_modules/tom-select/dist/esm/plugins/clear_button/plugin.js");
/* harmony import */ var _plugins_drag_drop_plugin_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./plugins/drag_drop/plugin.js */ "./node_modules/tom-select/dist/esm/plugins/drag_drop/plugin.js");
/* harmony import */ var _plugins_dropdown_header_plugin_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./plugins/dropdown_header/plugin.js */ "./node_modules/tom-select/dist/esm/plugins/dropdown_header/plugin.js");
/* harmony import */ var _plugins_caret_position_plugin_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./plugins/caret_position/plugin.js */ "./node_modules/tom-select/dist/esm/plugins/caret_position/plugin.js");
/* harmony import */ var _plugins_dropdown_input_plugin_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./plugins/dropdown_input/plugin.js */ "./node_modules/tom-select/dist/esm/plugins/dropdown_input/plugin.js");
/* harmony import */ var _plugins_input_autogrow_plugin_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./plugins/input_autogrow/plugin.js */ "./node_modules/tom-select/dist/esm/plugins/input_autogrow/plugin.js");
/* harmony import */ var _plugins_no_backspace_delete_plugin_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./plugins/no_backspace_delete/plugin.js */ "./node_modules/tom-select/dist/esm/plugins/no_backspace_delete/plugin.js");
/* harmony import */ var _plugins_no_active_items_plugin_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./plugins/no_active_items/plugin.js */ "./node_modules/tom-select/dist/esm/plugins/no_active_items/plugin.js");
/* harmony import */ var _plugins_optgroup_columns_plugin_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./plugins/optgroup_columns/plugin.js */ "./node_modules/tom-select/dist/esm/plugins/optgroup_columns/plugin.js");
/* harmony import */ var _plugins_remove_button_plugin_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./plugins/remove_button/plugin.js */ "./node_modules/tom-select/dist/esm/plugins/remove_button/plugin.js");
/* harmony import */ var _plugins_restore_on_backspace_plugin_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./plugins/restore_on_backspace/plugin.js */ "./node_modules/tom-select/dist/esm/plugins/restore_on_backspace/plugin.js");
/* harmony import */ var _plugins_virtual_scroll_plugin_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./plugins/virtual_scroll/plugin.js */ "./node_modules/tom-select/dist/esm/plugins/virtual_scroll/plugin.js");















_tom_select_js__WEBPACK_IMPORTED_MODULE_0__["default"].define('change_listener', _plugins_change_listener_plugin_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
_tom_select_js__WEBPACK_IMPORTED_MODULE_0__["default"].define('checkbox_options', _plugins_checkbox_options_plugin_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
_tom_select_js__WEBPACK_IMPORTED_MODULE_0__["default"].define('clear_button', _plugins_clear_button_plugin_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
_tom_select_js__WEBPACK_IMPORTED_MODULE_0__["default"].define('drag_drop', _plugins_drag_drop_plugin_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
_tom_select_js__WEBPACK_IMPORTED_MODULE_0__["default"].define('dropdown_header', _plugins_dropdown_header_plugin_js__WEBPACK_IMPORTED_MODULE_5__["default"]);
_tom_select_js__WEBPACK_IMPORTED_MODULE_0__["default"].define('caret_position', _plugins_caret_position_plugin_js__WEBPACK_IMPORTED_MODULE_6__["default"]);
_tom_select_js__WEBPACK_IMPORTED_MODULE_0__["default"].define('dropdown_input', _plugins_dropdown_input_plugin_js__WEBPACK_IMPORTED_MODULE_7__["default"]);
_tom_select_js__WEBPACK_IMPORTED_MODULE_0__["default"].define('input_autogrow', _plugins_input_autogrow_plugin_js__WEBPACK_IMPORTED_MODULE_8__["default"]);
_tom_select_js__WEBPACK_IMPORTED_MODULE_0__["default"].define('no_backspace_delete', _plugins_no_backspace_delete_plugin_js__WEBPACK_IMPORTED_MODULE_9__["default"]);
_tom_select_js__WEBPACK_IMPORTED_MODULE_0__["default"].define('no_active_items', _plugins_no_active_items_plugin_js__WEBPACK_IMPORTED_MODULE_10__["default"]);
_tom_select_js__WEBPACK_IMPORTED_MODULE_0__["default"].define('optgroup_columns', _plugins_optgroup_columns_plugin_js__WEBPACK_IMPORTED_MODULE_11__["default"]);
_tom_select_js__WEBPACK_IMPORTED_MODULE_0__["default"].define('remove_button', _plugins_remove_button_plugin_js__WEBPACK_IMPORTED_MODULE_12__["default"]);
_tom_select_js__WEBPACK_IMPORTED_MODULE_0__["default"].define('restore_on_backspace', _plugins_restore_on_backspace_plugin_js__WEBPACK_IMPORTED_MODULE_13__["default"]);
_tom_select_js__WEBPACK_IMPORTED_MODULE_0__["default"].define('virtual_scroll', _plugins_virtual_scroll_plugin_js__WEBPACK_IMPORTED_MODULE_14__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (_tom_select_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
//# sourceMappingURL=tom-select.complete.js.map

/***/ }),

/***/ "./node_modules/tom-select/dist/esm/tom-select.js":
/*!********************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/tom-select.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ TomSelect; }
/* harmony export */ });
/* harmony import */ var _contrib_microevent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./contrib/microevent.js */ "./node_modules/tom-select/dist/esm/contrib/microevent.js");
/* harmony import */ var _contrib_microplugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./contrib/microplugin.js */ "./node_modules/tom-select/dist/esm/contrib/microplugin.js");
/* harmony import */ var _orchidjs_sifter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @orchidjs/sifter */ "./node_modules/@orchidjs/sifter/dist/esm/sifter.js");
/* harmony import */ var _orchidjs_unicode_variants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @orchidjs/unicode-variants */ "./node_modules/@orchidjs/unicode-variants/dist/esm/index.js");
/* harmony import */ var _contrib_highlight_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./contrib/highlight.js */ "./node_modules/tom-select/dist/esm/contrib/highlight.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants.js */ "./node_modules/tom-select/dist/esm/constants.js");
/* harmony import */ var _getSettings_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getSettings.js */ "./node_modules/tom-select/dist/esm/getSettings.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils.js */ "./node_modules/tom-select/dist/esm/utils.js");
/* harmony import */ var _vanilla_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./vanilla.js */ "./node_modules/tom-select/dist/esm/vanilla.js");









var instance_i = 0;
class TomSelect extends (0,_contrib_microplugin_js__WEBPACK_IMPORTED_MODULE_1__["default"])(_contrib_microevent_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
    constructor(input_arg, user_settings) {
        super();
        this.order = 0;
        this.isOpen = false;
        this.isDisabled = false;
        this.isReadOnly = false;
        this.isInvalid = false; // @deprecated 1.8
        this.isValid = true;
        this.isLocked = false;
        this.isFocused = false;
        this.isInputHidden = false;
        this.isSetup = false;
        this.ignoreFocus = false;
        this.ignoreHover = false;
        this.hasOptions = false;
        this.lastValue = '';
        this.caretPos = 0;
        this.loading = 0;
        this.loadedSearches = {};
        this.activeOption = null;
        this.activeItems = [];
        this.optgroups = {};
        this.options = {};
        this.userOptions = {};
        this.items = [];
        this.refreshTimeout = null;
        instance_i++;
        var dir;
        var input = (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.getDom)(input_arg);
        if (input.tomselect) {
            throw new Error('Tom Select already initialized on this element');
        }
        input.tomselect = this;
        // detect rtl environment
        var computedStyle = window.getComputedStyle && window.getComputedStyle(input, null);
        dir = computedStyle.getPropertyValue('direction');
        // setup default state
        const settings = (0,_getSettings_js__WEBPACK_IMPORTED_MODULE_6__["default"])(input, user_settings);
        this.settings = settings;
        this.input = input;
        this.tabIndex = input.tabIndex || 0;
        this.is_select_tag = input.tagName.toLowerCase() === 'select';
        this.rtl = /rtl/i.test(dir);
        this.inputId = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.getId)(input, 'tomselect-' + instance_i);
        this.isRequired = input.required;
        // search system
        this.sifter = new _orchidjs_sifter__WEBPACK_IMPORTED_MODULE_2__.Sifter(this.options, { diacritics: settings.diacritics });
        // option-dependent defaults
        settings.mode = settings.mode || (settings.maxItems === 1 ? 'single' : 'multi');
        if (typeof settings.hideSelected !== 'boolean') {
            settings.hideSelected = settings.mode === 'multi';
        }
        if (typeof settings.hidePlaceholder !== 'boolean') {
            settings.hidePlaceholder = settings.mode !== 'multi';
        }
        // set up createFilter callback
        var filter = settings.createFilter;
        if (typeof filter !== 'function') {
            if (typeof filter === 'string') {
                filter = new RegExp(filter);
            }
            if (filter instanceof RegExp) {
                settings.createFilter = (input) => filter.test(input);
            }
            else {
                settings.createFilter = (value) => {
                    return this.settings.duplicates || !this.options[value];
                };
            }
        }
        this.initializePlugins(settings.plugins);
        this.setupCallbacks();
        this.setupTemplates();
        // Create all elements
        const wrapper = (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.getDom)('<div>');
        const control = (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.getDom)('<div>');
        const dropdown = this._render('dropdown');
        const dropdown_content = (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.getDom)(`<div role="listbox" tabindex="-1">`);
        const classes = this.input.getAttribute('class') || '';
        const inputMode = settings.mode;
        var control_input;
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.addClasses)(wrapper, settings.wrapperClass, classes, inputMode);
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.addClasses)(control, settings.controlClass);
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.append)(wrapper, control);
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.addClasses)(dropdown, settings.dropdownClass, inputMode);
        if (settings.copyClassesToDropdown) {
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.addClasses)(dropdown, classes);
        }
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.addClasses)(dropdown_content, settings.dropdownContentClass);
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.append)(dropdown, dropdown_content);
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.getDom)(settings.dropdownParent || wrapper).appendChild(dropdown);
        // default controlInput
        if ((0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.isHtmlString)(settings.controlInput)) {
            control_input = (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.getDom)(settings.controlInput);
            // set attributes
            var attrs = ['autocorrect', 'autocapitalize', 'autocomplete', 'spellcheck'];
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.iterate)(attrs, (attr) => {
                if (input.getAttribute(attr)) {
                    (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(control_input, { [attr]: input.getAttribute(attr) });
                }
            });
            control_input.tabIndex = -1;
            control.appendChild(control_input);
            this.focus_node = control_input;
            // dom element
        }
        else if (settings.controlInput) {
            control_input = (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.getDom)(settings.controlInput);
            this.focus_node = control_input;
        }
        else {
            control_input = (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.getDom)('<input/>');
            this.focus_node = control;
        }
        this.wrapper = wrapper;
        this.dropdown = dropdown;
        this.dropdown_content = dropdown_content;
        this.control = control;
        this.control_input = control_input;
        this.setup();
    }
    /**
     * set up event bindings.
     *
     */
    setup() {
        const self = this;
        const settings = self.settings;
        const control_input = self.control_input;
        const dropdown = self.dropdown;
        const dropdown_content = self.dropdown_content;
        const wrapper = self.wrapper;
        const control = self.control;
        const input = self.input;
        const focus_node = self.focus_node;
        const passive_event = { passive: true };
        const listboxId = self.inputId + '-ts-dropdown';
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(dropdown_content, {
            id: listboxId
        });
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(focus_node, {
            role: 'combobox',
            'aria-haspopup': 'listbox',
            'aria-expanded': 'false',
            'aria-controls': listboxId
        });
        const control_id = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.getId)(focus_node, self.inputId + '-ts-control');
        const query = "label[for='" + (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.escapeQuery)(self.inputId) + "']";
        const label = document.querySelector(query);
        const label_click = self.focus.bind(self);
        if (label) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addEvent)(label, 'click', label_click);
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(label, { for: control_id });
            const label_id = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.getId)(label, self.inputId + '-ts-label');
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(focus_node, { 'aria-labelledby': label_id });
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(dropdown_content, { 'aria-labelledby': label_id });
        }
        wrapper.style.width = input.style.width;
        if (self.plugins.names.length) {
            const classes_plugins = 'plugin-' + self.plugins.names.join(' plugin-');
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.addClasses)([wrapper, dropdown], classes_plugins);
        }
        if ((settings.maxItems === null || settings.maxItems > 1) && self.is_select_tag) {
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(input, { multiple: 'multiple' });
        }
        if (settings.placeholder) {
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(control_input, { placeholder: settings.placeholder });
        }
        // if splitOn was not passed in, construct it from the delimiter to allow pasting universally
        if (!settings.splitOn && settings.delimiter) {
            settings.splitOn = new RegExp('\\s*' + (0,_orchidjs_unicode_variants__WEBPACK_IMPORTED_MODULE_3__.escape_regex)(settings.delimiter) + '+\\s*');
        }
        // debounce user defined load() if loadThrottle > 0
        // after initializePlugins() so plugins can create/modify user defined loaders
        if (settings.load && settings.loadThrottle) {
            settings.load = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.loadDebounce)(settings.load, settings.loadThrottle);
        }
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addEvent)(dropdown, 'mousemove', () => {
            self.ignoreHover = false;
        });
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addEvent)(dropdown, 'mouseenter', (e) => {
            var target_match = (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.parentMatch)(e.target, '[data-selectable]', dropdown);
            if (target_match)
                self.onOptionHover(e, target_match);
        }, { capture: true });
        // clicking on an option should select it
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addEvent)(dropdown, 'click', (evt) => {
            const option = (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.parentMatch)(evt.target, '[data-selectable]');
            if (option) {
                self.onOptionSelect(evt, option);
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(evt, true);
            }
        });
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addEvent)(control, 'click', (evt) => {
            var target_match = (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.parentMatch)(evt.target, '[data-ts-item]', control);
            if (target_match && self.onItemSelect(evt, target_match)) {
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(evt, true);
                return;
            }
            // retain focus (see control_input mousedown)
            if (control_input.value != '') {
                return;
            }
            self.onClick();
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(evt, true);
        });
        // keydown on focus_node for arrow_down/arrow_up
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addEvent)(focus_node, 'keydown', (e) => self.onKeyDown(e));
        // keypress and input/keyup
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addEvent)(control_input, 'keypress', (e) => self.onKeyPress(e));
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addEvent)(control_input, 'input', (e) => self.onInput(e));
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addEvent)(focus_node, 'blur', (e) => self.onBlur(e));
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addEvent)(focus_node, 'focus', (e) => self.onFocus(e));
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addEvent)(control_input, 'paste', (e) => self.onPaste(e));
        const doc_mousedown = (evt) => {
            // blur if target is outside of this instance
            // dropdown is not always inside wrapper
            const target = evt.composedPath()[0];
            if (!wrapper.contains(target) && !dropdown.contains(target)) {
                if (self.isFocused) {
                    self.blur();
                }
                self.inputState();
                return;
            }
            // retain focus by preventing native handling. if the
            // event target is the input it should not be modified.
            // otherwise, text selection within the input won't work.
            // Fixes bug #212 which is no covered by tests
            if (target == control_input && self.isOpen) {
                evt.stopPropagation();
                // clicking anywhere in the control should not blur the control_input (which would close the dropdown)
            }
            else {
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(evt, true);
            }
        };
        const win_scroll = () => {
            if (self.isOpen) {
                self.positionDropdown();
            }
        };
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addEvent)(document, 'mousedown', doc_mousedown);
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addEvent)(window, 'scroll', win_scroll, passive_event);
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addEvent)(window, 'resize', win_scroll, passive_event);
        this._destroy = () => {
            document.removeEventListener('mousedown', doc_mousedown);
            window.removeEventListener('scroll', win_scroll);
            window.removeEventListener('resize', win_scroll);
            if (label)
                label.removeEventListener('click', label_click);
        };
        // store original html and tab index so that they can be
        // restored when the destroy() method is called.
        this.revertSettings = {
            innerHTML: input.innerHTML,
            tabIndex: input.tabIndex
        };
        input.tabIndex = -1;
        input.insertAdjacentElement('afterend', self.wrapper);
        self.sync(false);
        settings.items = [];
        delete settings.optgroups;
        delete settings.options;
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addEvent)(input, 'invalid', () => {
            if (self.isValid) {
                self.isValid = false;
                self.isInvalid = true;
                self.refreshState();
            }
        });
        self.updateOriginalInput();
        self.refreshItems();
        self.close(false);
        self.inputState();
        self.isSetup = true;
        if (input.disabled) {
            self.disable();
        }
        else if (input.readOnly) {
            self.setReadOnly(true);
        }
        else {
            self.enable(); //sets tabIndex
        }
        self.on('change', this.onChange);
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.addClasses)(input, 'tomselected', 'ts-hidden-accessible');
        self.trigger('initialize');
        // preload options
        if (settings.preload === true) {
            self.preload();
        }
    }
    /**
     * Register options and optgroups
     *
     */
    setupOptions(options = [], optgroups = []) {
        // build options table
        this.addOptions(options);
        // build optgroup table
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.iterate)(optgroups, (optgroup) => {
            this.registerOptionGroup(optgroup);
        });
    }
    /**
     * Sets up default rendering functions.
     */
    setupTemplates() {
        var self = this;
        var field_label = self.settings.labelField;
        var field_optgroup = self.settings.optgroupLabelField;
        var templates = {
            'optgroup': (data) => {
                let optgroup = document.createElement('div');
                optgroup.className = 'optgroup';
                optgroup.appendChild(data.options);
                return optgroup;
            },
            'optgroup_header': (data, escape) => {
                return '<div class="optgroup-header">' + escape(data[field_optgroup]) + '</div>';
            },
            'option': (data, escape) => {
                return '<div>' + escape(data[field_label]) + '</div>';
            },
            'item': (data, escape) => {
                return '<div>' + escape(data[field_label]) + '</div>';
            },
            'option_create': (data, escape) => {
                return '<div class="create">Add <strong>' + escape(data.input) + '</strong>&hellip;</div>';
            },
            'no_results': () => {
                return '<div class="no-results">No results found</div>';
            },
            'loading': () => {
                return '<div class="spinner"></div>';
            },
            'not_loading': () => { },
            'dropdown': () => {
                return '<div></div>';
            }
        };
        self.settings.render = Object.assign({}, templates, self.settings.render);
    }
    /**
     * Maps fired events to callbacks provided
     * in the settings used when creating the control.
     */
    setupCallbacks() {
        var key, fn;
        var callbacks = {
            'initialize': 'onInitialize',
            'change': 'onChange',
            'item_add': 'onItemAdd',
            'item_remove': 'onItemRemove',
            'item_select': 'onItemSelect',
            'clear': 'onClear',
            'option_add': 'onOptionAdd',
            'option_remove': 'onOptionRemove',
            'option_clear': 'onOptionClear',
            'optgroup_add': 'onOptionGroupAdd',
            'optgroup_remove': 'onOptionGroupRemove',
            'optgroup_clear': 'onOptionGroupClear',
            'dropdown_open': 'onDropdownOpen',
            'dropdown_close': 'onDropdownClose',
            'type': 'onType',
            'load': 'onLoad',
            'focus': 'onFocus',
            'blur': 'onBlur'
        };
        for (key in callbacks) {
            fn = this.settings[callbacks[key]];
            if (fn)
                this.on(key, fn);
        }
    }
    /**
     * Sync the Tom Select instance with the original input or select
     *
     */
    sync(get_settings = true) {
        const self = this;
        const settings = get_settings ? (0,_getSettings_js__WEBPACK_IMPORTED_MODULE_6__["default"])(self.input, { delimiter: self.settings.delimiter }) : self.settings;
        self.setupOptions(settings.options, settings.optgroups);
        self.setValue(settings.items || [], true); // silent prevents recursion
        self.lastQuery = null; // so updated options will be displayed in dropdown
    }
    /**
     * Triggered when the main control element
     * has a click event.
     *
     */
    onClick() {
        var self = this;
        if (self.activeItems.length > 0) {
            self.clearActiveItems();
            self.focus();
            return;
        }
        if (self.isFocused && self.isOpen) {
            self.blur();
        }
        else {
            self.focus();
        }
    }
    /**
     * @deprecated v1.7
     *
     */
    onMouseDown() { }
    /**
     * Triggered when the value of the control has been changed.
     * This should propagate the event to the original DOM
     * input / select element.
     */
    onChange() {
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.triggerEvent)(this.input, 'input');
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.triggerEvent)(this.input, 'change');
    }
    /**
     * Triggered on <input> paste.
     *
     */
    onPaste(e) {
        var self = this;
        if (self.isInputHidden || self.isLocked) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e);
            return;
        }
        // If a regex or string is included, this will split the pasted
        // input and create Items for each separate value
        if (!self.settings.splitOn) {
            return;
        }
        // Wait for pasted text to be recognized in value
        setTimeout(() => {
            var pastedText = self.inputValue();
            if (!pastedText.match(self.settings.splitOn)) {
                return;
            }
            var splitInput = pastedText.trim().split(self.settings.splitOn);
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.iterate)(splitInput, (piece) => {
                const hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.hash_key)(piece);
                if (hash) {
                    if (this.options[piece]) {
                        self.addItem(piece);
                    }
                    else {
                        self.createItem(piece);
                    }
                }
            });
        }, 0);
    }
    /**
     * Triggered on <input> keypress.
     *
     */
    onKeyPress(e) {
        var self = this;
        if (self.isLocked) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e);
            return;
        }
        var character = String.fromCharCode(e.keyCode || e.which);
        if (self.settings.create && self.settings.mode === 'multi' && character === self.settings.delimiter) {
            self.createItem();
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e);
            return;
        }
    }
    /**
     * Triggered on <input> keydown.
     *
     */
    onKeyDown(e) {
        var self = this;
        self.ignoreHover = true;
        if (self.isLocked) {
            if (e.keyCode !== _constants_js__WEBPACK_IMPORTED_MODULE_5__.KEY_TAB) {
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e);
            }
            return;
        }
        switch (e.keyCode) {
            // ctrl+A: select all
            case _constants_js__WEBPACK_IMPORTED_MODULE_5__.KEY_A:
                if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.isKeyDown)(_constants_js__WEBPACK_IMPORTED_MODULE_5__.KEY_SHORTCUT, e)) {
                    if (self.control_input.value == '') {
                        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e);
                        self.selectAll();
                        return;
                    }
                }
                break;
            // esc: close dropdown
            case _constants_js__WEBPACK_IMPORTED_MODULE_5__.KEY_ESC:
                if (self.isOpen) {
                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e, true);
                    self.close();
                }
                self.clearActiveItems();
                return;
            // down: open dropdown or move selection down
            case _constants_js__WEBPACK_IMPORTED_MODULE_5__.KEY_DOWN:
                if (!self.isOpen && self.hasOptions) {
                    self.open();
                }
                else if (self.activeOption) {
                    let next = self.getAdjacent(self.activeOption, 1);
                    if (next)
                        self.setActiveOption(next);
                }
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e);
                return;
            // up: move selection up
            case _constants_js__WEBPACK_IMPORTED_MODULE_5__.KEY_UP:
                if (self.activeOption) {
                    let prev = self.getAdjacent(self.activeOption, -1);
                    if (prev)
                        self.setActiveOption(prev);
                }
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e);
                return;
            // return: select active option
            case _constants_js__WEBPACK_IMPORTED_MODULE_5__.KEY_RETURN:
                if (self.canSelect(self.activeOption)) {
                    self.onOptionSelect(e, self.activeOption);
                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e);
                    // if the option_create=null, the dropdown might be closed
                }
                else if (self.settings.create && self.createItem()) {
                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e);
                    // don't submit form when searching for a value
                }
                else if (document.activeElement == self.control_input && self.isOpen) {
                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e);
                }
                return;
            // left: modifiy item selection to the left
            case _constants_js__WEBPACK_IMPORTED_MODULE_5__.KEY_LEFT:
                self.advanceSelection(-1, e);
                return;
            // right: modifiy item selection to the right
            case _constants_js__WEBPACK_IMPORTED_MODULE_5__.KEY_RIGHT:
                self.advanceSelection(1, e);
                return;
            // tab: select active option and/or create item
            case _constants_js__WEBPACK_IMPORTED_MODULE_5__.KEY_TAB:
                if (self.settings.selectOnTab) {
                    if (self.canSelect(self.activeOption)) {
                        self.onOptionSelect(e, self.activeOption);
                        // prevent default [tab] behaviour of jump to the next field
                        // if select isFull, then the dropdown won't be open and [tab] will work normally
                        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e);
                    }
                    if (self.settings.create && self.createItem()) {
                        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e);
                    }
                }
                return;
            // delete|backspace: delete items
            case _constants_js__WEBPACK_IMPORTED_MODULE_5__.KEY_BACKSPACE:
            case _constants_js__WEBPACK_IMPORTED_MODULE_5__.KEY_DELETE:
                self.deleteSelection(e);
                return;
        }
        // don't enter text in the control_input when active items are selected
        if (self.isInputHidden && !(0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.isKeyDown)(_constants_js__WEBPACK_IMPORTED_MODULE_5__.KEY_SHORTCUT, e)) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e);
        }
    }
    /**
     * Triggered on <input> keyup.
     *
     */
    onInput(e) {
        if (this.isLocked) {
            return;
        }
        const value = this.inputValue();
        if (this.lastValue === value)
            return;
        this.lastValue = value;
        if (value == '') {
            this._onInput();
            return;
        }
        if (this.refreshTimeout) {
            window.clearTimeout(this.refreshTimeout);
        }
        this.refreshTimeout = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.timeout)(() => {
            this.refreshTimeout = null;
            this._onInput();
        }, this.settings.refreshThrottle);
    }
    _onInput() {
        const value = this.lastValue;
        if (this.settings.shouldLoad.call(this, value)) {
            this.load(value);
        }
        this.refreshOptions();
        this.trigger('type', value);
    }
    /**
     * Triggered when the user rolls over
     * an option in the autocomplete dropdown menu.
     *
     */
    onOptionHover(evt, option) {
        if (this.ignoreHover)
            return;
        this.setActiveOption(option, false);
    }
    /**
     * Triggered on <input> focus.
     *
     */
    onFocus(e) {
        var self = this;
        var wasFocused = self.isFocused;
        if (self.isDisabled || self.isReadOnly) {
            self.blur();
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e);
            return;
        }
        if (self.ignoreFocus)
            return;
        self.isFocused = true;
        if (self.settings.preload === 'focus')
            self.preload();
        if (!wasFocused)
            self.trigger('focus');
        if (!self.activeItems.length) {
            self.inputState();
            self.refreshOptions(!!self.settings.openOnFocus);
        }
        self.refreshState();
    }
    /**
     * Triggered on <input> blur.
     *
     */
    onBlur(e) {
        if (document.hasFocus() === false)
            return;
        var self = this;
        if (!self.isFocused)
            return;
        self.isFocused = false;
        self.ignoreFocus = false;
        var deactivate = () => {
            self.close();
            self.setActiveItem();
            self.setCaret(self.items.length);
            self.trigger('blur');
        };
        if (self.settings.create && self.settings.createOnBlur) {
            self.createItem(null, deactivate);
        }
        else {
            deactivate();
        }
    }
    /**
     * Triggered when the user clicks on an option
     * in the autocomplete dropdown menu.
     *
     */
    onOptionSelect(evt, option) {
        var value, self = this;
        // should not be possible to trigger a option under a disabled optgroup
        if (option.parentElement && option.parentElement.matches('[data-disabled]')) {
            return;
        }
        if (option.classList.contains('create')) {
            self.createItem(null, () => {
                if (self.settings.closeAfterSelect) {
                    self.close();
                }
            });
        }
        else {
            value = option.dataset.value;
            if (typeof value !== 'undefined') {
                self.lastQuery = null;
                self.addItem(value);
                if (self.settings.closeAfterSelect) {
                    self.close();
                }
                if (!self.settings.hideSelected && evt.type && /click/.test(evt.type)) {
                    self.setActiveOption(option);
                }
            }
        }
    }
    /**
     * Return true if the given option can be selected
     *
     */
    canSelect(option) {
        if (this.isOpen && option && this.dropdown_content.contains(option)) {
            return true;
        }
        return false;
    }
    /**
     * Triggered when the user clicks on an item
     * that has been selected.
     *
     */
    onItemSelect(evt, item) {
        var self = this;
        if (!self.isLocked && self.settings.mode === 'multi') {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(evt);
            self.setActiveItem(item, evt);
            return true;
        }
        return false;
    }
    /**
     * Determines whether or not to invoke
     * the user-provided option provider / loader
     *
     * Note, there is a subtle difference between
     * this.canLoad() and this.settings.shouldLoad();
     *
     *	- settings.shouldLoad() is a user-input validator.
     *	When false is returned, the not_loading template
     *	will be added to the dropdown
     *
     *	- canLoad() is lower level validator that checks
     * 	the Tom Select instance. There is no inherent user
     *	feedback when canLoad returns false
     *
     */
    canLoad(value) {
        if (!this.settings.load)
            return false;
        if (this.loadedSearches.hasOwnProperty(value))
            return false;
        return true;
    }
    /**
     * Invokes the user-provided option provider / loader.
     *
     */
    load(value) {
        const self = this;
        if (!self.canLoad(value))
            return;
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.addClasses)(self.wrapper, self.settings.loadingClass);
        self.loading++;
        const callback = self.loadCallback.bind(self);
        self.settings.load.call(self, value, callback);
    }
    /**
     * Invoked by the user-provided option provider
     *
     */
    loadCallback(options, optgroups) {
        const self = this;
        self.loading = Math.max(self.loading - 1, 0);
        self.lastQuery = null;
        self.clearActiveOption(); // when new results load, focus should be on first option
        self.setupOptions(options, optgroups);
        self.refreshOptions(self.isFocused && !self.isInputHidden);
        if (!self.loading) {
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.removeClasses)(self.wrapper, self.settings.loadingClass);
        }
        self.trigger('load', options, optgroups);
    }
    preload() {
        var classList = this.wrapper.classList;
        if (classList.contains('preloaded'))
            return;
        classList.add('preloaded');
        this.load('');
    }
    /**
     * Sets the input field of the control to the specified value.
     *
     */
    setTextboxValue(value = '') {
        var input = this.control_input;
        var changed = input.value !== value;
        if (changed) {
            input.value = value;
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.triggerEvent)(input, 'update');
            this.lastValue = value;
        }
    }
    /**
     * Returns the value of the control. If multiple items
     * can be selected (e.g. <select multiple>), this returns
     * an array. If only one item can be selected, this
     * returns a string.
     *
     */
    getValue() {
        if (this.is_select_tag && this.input.hasAttribute('multiple')) {
            return this.items;
        }
        return this.items.join(this.settings.delimiter);
    }
    /**
     * Resets the selected items to the given value.
     *
     */
    setValue(value, silent) {
        var events = silent ? [] : ['change'];
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.debounce_events)(this, events, () => {
            this.clear(silent);
            this.addItems(value, silent);
        });
    }
    /**
     * Resets the number of max items to the given value
     *
     */
    setMaxItems(value) {
        if (value === 0)
            value = null; //reset to unlimited items.
        this.settings.maxItems = value;
        this.refreshState();
    }
    /**
     * Sets the selected item.
     *
     */
    setActiveItem(item, e) {
        var self = this;
        var eventName;
        var i, begin, end, swap;
        var last;
        if (self.settings.mode === 'single')
            return;
        // clear the active selection
        if (!item) {
            self.clearActiveItems();
            if (self.isFocused) {
                self.inputState();
            }
            return;
        }
        // modify selection
        eventName = e && e.type.toLowerCase();
        if (eventName === 'click' && (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.isKeyDown)('shiftKey', e) && self.activeItems.length) {
            last = self.getLastActive();
            begin = Array.prototype.indexOf.call(self.control.children, last);
            end = Array.prototype.indexOf.call(self.control.children, item);
            if (begin > end) {
                swap = begin;
                begin = end;
                end = swap;
            }
            for (i = begin; i <= end; i++) {
                item = self.control.children[i];
                if (self.activeItems.indexOf(item) === -1) {
                    self.setActiveItemClass(item);
                }
            }
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e);
        }
        else if ((eventName === 'click' && (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.isKeyDown)(_constants_js__WEBPACK_IMPORTED_MODULE_5__.KEY_SHORTCUT, e)) || (eventName === 'keydown' && (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.isKeyDown)('shiftKey', e))) {
            if (item.classList.contains('active')) {
                self.removeActiveItem(item);
            }
            else {
                self.setActiveItemClass(item);
            }
        }
        else {
            self.clearActiveItems();
            self.setActiveItemClass(item);
        }
        // ensure control has focus
        self.inputState();
        if (!self.isFocused) {
            self.focus();
        }
    }
    /**
     * Set the active and last-active classes
     *
     */
    setActiveItemClass(item) {
        const self = this;
        const last_active = self.control.querySelector('.last-active');
        if (last_active)
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.removeClasses)(last_active, 'last-active');
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.addClasses)(item, 'active last-active');
        self.trigger('item_select', item);
        if (self.activeItems.indexOf(item) == -1) {
            self.activeItems.push(item);
        }
    }
    /**
     * Remove active item
     *
     */
    removeActiveItem(item) {
        var idx = this.activeItems.indexOf(item);
        this.activeItems.splice(idx, 1);
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.removeClasses)(item, 'active');
    }
    /**
     * Clears all the active items
     *
     */
    clearActiveItems() {
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.removeClasses)(this.activeItems, 'active');
        this.activeItems = [];
    }
    /**
     * Sets the selected item in the dropdown menu
     * of available options.
     *
     */
    setActiveOption(option, scroll = true) {
        if (option === this.activeOption) {
            return;
        }
        this.clearActiveOption();
        if (!option)
            return;
        this.activeOption = option;
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(this.focus_node, { 'aria-activedescendant': option.getAttribute('id') });
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(option, { 'aria-selected': 'true' });
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.addClasses)(option, 'active');
        if (scroll)
            this.scrollToOption(option);
    }
    /**
     * Sets the dropdown_content scrollTop to display the option
     *
     */
    scrollToOption(option, behavior) {
        if (!option)
            return;
        const content = this.dropdown_content;
        const height_menu = content.clientHeight;
        const scrollTop = content.scrollTop || 0;
        const height_item = option.offsetHeight;
        const y = option.getBoundingClientRect().top - content.getBoundingClientRect().top + scrollTop;
        if (y + height_item > height_menu + scrollTop) {
            this.scroll(y - height_menu + height_item, behavior);
        }
        else if (y < scrollTop) {
            this.scroll(y, behavior);
        }
    }
    /**
     * Scroll the dropdown to the given position
     *
     */
    scroll(scrollTop, behavior) {
        const content = this.dropdown_content;
        if (behavior) {
            content.style.scrollBehavior = behavior;
        }
        content.scrollTop = scrollTop;
        content.style.scrollBehavior = '';
    }
    /**
     * Clears the active option
     *
     */
    clearActiveOption() {
        if (this.activeOption) {
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.removeClasses)(this.activeOption, 'active');
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(this.activeOption, { 'aria-selected': null });
        }
        this.activeOption = null;
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(this.focus_node, { 'aria-activedescendant': null });
    }
    /**
     * Selects all items (CTRL + A).
     */
    selectAll() {
        const self = this;
        if (self.settings.mode === 'single')
            return;
        const activeItems = self.controlChildren();
        if (!activeItems.length)
            return;
        self.inputState();
        self.close();
        self.activeItems = activeItems;
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.iterate)(activeItems, (item) => {
            self.setActiveItemClass(item);
        });
    }
    /**
     * Determines if the control_input should be in a hidden or visible state
     *
     */
    inputState() {
        var self = this;
        if (!self.control.contains(self.control_input))
            return;
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(self.control_input, { placeholder: self.settings.placeholder });
        if (self.activeItems.length > 0 || (!self.isFocused && self.settings.hidePlaceholder && self.items.length > 0)) {
            self.setTextboxValue();
            self.isInputHidden = true;
        }
        else {
            if (self.settings.hidePlaceholder && self.items.length > 0) {
                (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(self.control_input, { placeholder: '' });
            }
            self.isInputHidden = false;
        }
        self.wrapper.classList.toggle('input-hidden', self.isInputHidden);
    }
    /**
     * Get the input value
     */
    inputValue() {
        return this.control_input.value.trim();
    }
    /**
     * Gives the control focus.
     */
    focus() {
        var self = this;
        if (self.isDisabled || self.isReadOnly)
            return;
        self.ignoreFocus = true;
        if (self.control_input.offsetWidth) {
            self.control_input.focus();
        }
        else {
            self.focus_node.focus();
        }
        setTimeout(() => {
            self.ignoreFocus = false;
            self.onFocus();
        }, 0);
    }
    /**
     * Forces the control out of focus.
     *
     */
    blur() {
        this.focus_node.blur();
        this.onBlur();
    }
    /**
     * Returns a function that scores an object
     * to show how good of a match it is to the
     * provided query.
     *
     * @return {function}
     */
    getScoreFunction(query) {
        return this.sifter.getScoreFunction(query, this.getSearchOptions());
    }
    /**
     * Returns search options for sifter (the system
     * for scoring and sorting results).
     *
     * @see https://github.com/orchidjs/sifter.js
     * @return {object}
     */
    getSearchOptions() {
        var settings = this.settings;
        var sort = settings.sortField;
        if (typeof settings.sortField === 'string') {
            sort = [{ field: settings.sortField }];
        }
        return {
            fields: settings.searchField,
            conjunction: settings.searchConjunction,
            sort: sort,
            nesting: settings.nesting
        };
    }
    /**
     * Searches through available options and returns
     * a sorted array of matches.
     *
     */
    search(query) {
        var result, calculateScore;
        var self = this;
        var options = this.getSearchOptions();
        // validate user-provided result scoring function
        if (self.settings.score) {
            calculateScore = self.settings.score.call(self, query);
            if (typeof calculateScore !== 'function') {
                throw new Error('Tom Select "score" setting must be a function that returns a function');
            }
        }
        // perform search
        if (query !== self.lastQuery) {
            self.lastQuery = query;
            result = self.sifter.search(query, Object.assign(options, { score: calculateScore }));
            self.currentResults = result;
        }
        else {
            result = Object.assign({}, self.currentResults);
        }
        // filter out selected items
        if (self.settings.hideSelected) {
            result.items = result.items.filter((item) => {
                let hashed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.hash_key)(item.id);
                return !(hashed && self.items.indexOf(hashed) !== -1);
            });
        }
        return result;
    }
    /**
     * Refreshes the list of available options shown
     * in the autocomplete dropdown menu.
     *
     */
    refreshOptions(triggerDropdown = true) {
        var i, j, k, n, optgroup, optgroups, html, has_create_option, active_group;
        var create;
        const groups = {};
        const groups_order = [];
        var self = this;
        var query = self.inputValue();
        const same_query = query === self.lastQuery || (query == '' && self.lastQuery == null);
        var results = self.search(query);
        var active_option = null;
        var show_dropdown = self.settings.shouldOpen || false;
        var dropdown_content = self.dropdown_content;
        if (same_query) {
            active_option = self.activeOption;
            if (active_option) {
                active_group = active_option.closest('[data-group]');
            }
        }
        // build markup
        n = results.items.length;
        if (typeof self.settings.maxOptions === 'number') {
            n = Math.min(n, self.settings.maxOptions);
        }
        if (n > 0) {
            show_dropdown = true;
        }
        // get fragment for group and the position of the group in group_order
        const getGroupFragment = (optgroup, order) => {
            let group_order_i = groups[optgroup];
            if (group_order_i !== undefined) {
                let order_group = groups_order[group_order_i];
                if (order_group !== undefined) {
                    return [group_order_i, order_group.fragment];
                }
            }
            let group_fragment = document.createDocumentFragment();
            group_order_i = groups_order.length;
            groups_order.push({ fragment: group_fragment, order, optgroup });
            return [group_order_i, group_fragment];
        };
        // render and group available options individually
        for (i = 0; i < n; i++) {
            // get option dom element
            let item = results.items[i];
            if (!item)
                continue;
            let opt_value = item.id;
            let option = self.options[opt_value];
            if (option === undefined)
                continue;
            let opt_hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.get_hash)(opt_value);
            let option_el = self.getOption(opt_hash, true);
            // toggle 'selected' class
            if (!self.settings.hideSelected) {
                option_el.classList.toggle('selected', self.items.includes(opt_hash));
            }
            optgroup = option[self.settings.optgroupField] || '';
            optgroups = Array.isArray(optgroup) ? optgroup : [optgroup];
            for (j = 0, k = optgroups && optgroups.length; j < k; j++) {
                optgroup = optgroups[j];
                let order = option.$order;
                let self_optgroup = self.optgroups[optgroup];
                if (self_optgroup === undefined) {
                    optgroup = '';
                }
                else {
                    order = self_optgroup.$order;
                }
                const [group_order_i, group_fragment] = getGroupFragment(optgroup, order);
                // nodes can only have one parent, so if the option is in mutple groups, we need a clone
                if (j > 0) {
                    option_el = option_el.cloneNode(true);
                    (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(option_el, { id: option.$id + '-clone-' + j, 'aria-selected': null });
                    option_el.classList.add('ts-cloned');
                    (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.removeClasses)(option_el, 'active');
                    // make sure we keep the activeOption in the same group
                    if (self.activeOption && self.activeOption.dataset.value == opt_value) {
                        if (active_group && active_group.dataset.group === optgroup.toString()) {
                            active_option = option_el;
                        }
                    }
                }
                group_fragment.appendChild(option_el);
                if (optgroup != '') {
                    groups[optgroup] = group_order_i;
                }
            }
        }
        // sort optgroups
        if (self.settings.lockOptgroupOrder) {
            groups_order.sort((a, b) => {
                return a.order - b.order;
            });
        }
        // render optgroup headers & join groups
        html = document.createDocumentFragment();
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.iterate)(groups_order, (group_order) => {
            let group_fragment = group_order.fragment;
            let optgroup = group_order.optgroup;
            if (!group_fragment || !group_fragment.children.length)
                return;
            let group_heading = self.optgroups[optgroup];
            if (group_heading !== undefined) {
                let group_options = document.createDocumentFragment();
                let header = self.render('optgroup_header', group_heading);
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.append)(group_options, header);
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.append)(group_options, group_fragment);
                let group_html = self.render('optgroup', { group: group_heading, options: group_options });
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.append)(html, group_html);
            }
            else {
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.append)(html, group_fragment);
            }
        });
        dropdown_content.innerHTML = '';
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.append)(dropdown_content, html);
        // highlight matching terms inline
        if (self.settings.highlight) {
            (0,_contrib_highlight_js__WEBPACK_IMPORTED_MODULE_4__.removeHighlight)(dropdown_content);
            if (results.query.length && results.tokens.length) {
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.iterate)(results.tokens, (tok) => {
                    (0,_contrib_highlight_js__WEBPACK_IMPORTED_MODULE_4__.highlight)(dropdown_content, tok.regex);
                });
            }
        }
        // helper method for adding templates to dropdown
        var add_template = (template) => {
            let content = self.render(template, { input: query });
            if (content) {
                show_dropdown = true;
                dropdown_content.insertBefore(content, dropdown_content.firstChild);
            }
            return content;
        };
        // add loading message
        if (self.loading) {
            add_template('loading');
            // invalid query
        }
        else if (!self.settings.shouldLoad.call(self, query)) {
            add_template('not_loading');
            // add no_results message
        }
        else if (results.items.length === 0) {
            add_template('no_results');
        }
        // add create option
        has_create_option = self.canCreate(query);
        if (has_create_option) {
            create = add_template('option_create');
        }
        // activate
        self.hasOptions = results.items.length > 0 || has_create_option;
        if (show_dropdown) {
            if (results.items.length > 0) {
                if (!active_option && self.settings.mode === 'single' && self.items[0] != undefined) {
                    active_option = self.getOption(self.items[0]);
                }
                if (!dropdown_content.contains(active_option)) {
                    let active_index = 0;
                    if (create && !self.settings.addPrecedence) {
                        active_index = 1;
                    }
                    active_option = self.selectable()[active_index];
                }
            }
            else if (create) {
                active_option = create;
            }
            if (triggerDropdown && !self.isOpen) {
                self.open();
                self.scrollToOption(active_option, 'auto');
            }
            self.setActiveOption(active_option);
        }
        else {
            self.clearActiveOption();
            if (triggerDropdown && self.isOpen) {
                self.close(false); // if create_option=null, we want the dropdown to close but not reset the textbox value
            }
        }
    }
    /**
     * Return list of selectable options
     *
     */
    selectable() {
        return this.dropdown_content.querySelectorAll('[data-selectable]');
    }
    /**
     * Adds an available option. If it already exists,
     * nothing will happen. Note: this does not refresh
     * the options list dropdown (use `refreshOptions`
     * for that).
     *
     * Usage:
     *
     *   this.addOption(data)
     *
     */
    addOption(data, user_created = false) {
        const self = this;
        // @deprecated 1.7.7
        // use addOptions( array, user_created ) for adding multiple options
        if (Array.isArray(data)) {
            self.addOptions(data, user_created);
            return false;
        }
        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.hash_key)(data[self.settings.valueField]);
        if (key === null || self.options.hasOwnProperty(key)) {
            return false;
        }
        data.$order = data.$order || ++self.order;
        data.$id = self.inputId + '-opt-' + data.$order;
        self.options[key] = data;
        self.lastQuery = null;
        if (user_created) {
            self.userOptions[key] = user_created;
            self.trigger('option_add', key, data);
        }
        return key;
    }
    /**
     * Add multiple options
     *
     */
    addOptions(data, user_created = false) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.iterate)(data, (dat) => {
            this.addOption(dat, user_created);
        });
    }
    /**
     * @deprecated 1.7.7
     */
    registerOption(data) {
        return this.addOption(data);
    }
    /**
     * Registers an option group to the pool of option groups.
     *
     * @return {boolean|string}
     */
    registerOptionGroup(data) {
        var key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.hash_key)(data[this.settings.optgroupValueField]);
        if (key === null)
            return false;
        data.$order = data.$order || ++this.order;
        this.optgroups[key] = data;
        return key;
    }
    /**
     * Registers a new optgroup for options
     * to be bucketed into.
     *
     */
    addOptionGroup(id, data) {
        var hashed_id;
        data[this.settings.optgroupValueField] = id;
        if (hashed_id = this.registerOptionGroup(data)) {
            this.trigger('optgroup_add', hashed_id, data);
        }
    }
    /**
     * Removes an existing option group.
     *
     */
    removeOptionGroup(id) {
        if (this.optgroups.hasOwnProperty(id)) {
            delete this.optgroups[id];
            this.clearCache();
            this.trigger('optgroup_remove', id);
        }
    }
    /**
     * Clears all existing option groups.
     */
    clearOptionGroups() {
        this.optgroups = {};
        this.clearCache();
        this.trigger('optgroup_clear');
    }
    /**
     * Updates an option available for selection. If
     * it is visible in the selected items or options
     * dropdown, it will be re-rendered automatically.
     *
     */
    updateOption(value, data) {
        const self = this;
        var item_new;
        var index_item;
        const value_old = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.hash_key)(value);
        const value_new = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.hash_key)(data[self.settings.valueField]);
        // sanity checks
        if (value_old === null)
            return;
        const data_old = self.options[value_old];
        if (data_old == undefined)
            return;
        if (typeof value_new !== 'string')
            throw new Error('Value must be set in option data');
        const option = self.getOption(value_old);
        const item = self.getItem(value_old);
        data.$order = data.$order || data_old.$order;
        delete self.options[value_old];
        // invalidate render cache
        // don't remove existing node yet, we'll remove it after replacing it
        self.uncacheValue(value_new);
        self.options[value_new] = data;
        // update the option if it's in the dropdown
        if (option) {
            if (self.dropdown_content.contains(option)) {
                const option_new = self._render('option', data);
                (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.replaceNode)(option, option_new);
                if (self.activeOption === option) {
                    self.setActiveOption(option_new);
                }
            }
            option.remove();
        }
        // update the item if we have one
        if (item) {
            index_item = self.items.indexOf(value_old);
            if (index_item !== -1) {
                self.items.splice(index_item, 1, value_new);
            }
            item_new = self._render('item', data);
            if (item.classList.contains('active'))
                (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.addClasses)(item_new, 'active');
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.replaceNode)(item, item_new);
        }
        // invalidate last query because we might have updated the sortField
        self.lastQuery = null;
    }
    /**
     * Removes a single option.
     *
     */
    removeOption(value, silent) {
        const self = this;
        value = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.get_hash)(value);
        self.uncacheValue(value);
        delete self.userOptions[value];
        delete self.options[value];
        self.lastQuery = null;
        self.trigger('option_remove', value);
        self.removeItem(value, silent);
    }
    /**
     * Clears all options.
     */
    clearOptions(filter) {
        const boundFilter = (filter || this.clearFilter).bind(this);
        this.loadedSearches = {};
        this.userOptions = {};
        this.clearCache();
        const selected = {};
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.iterate)(this.options, (option, key) => {
            if (boundFilter(option, key)) {
                selected[key] = option;
            }
        });
        this.options = this.sifter.items = selected;
        this.lastQuery = null;
        this.trigger('option_clear');
    }
    /**
     * Used by clearOptions() to decide whether or not an option should be removed
     * Return true to keep an option, false to remove
     *
     */
    clearFilter(option, value) {
        if (this.items.indexOf(value) >= 0) {
            return true;
        }
        return false;
    }
    /**
     * Returns the dom element of the option
     * matching the given value.
     *
     */
    getOption(value, create = false) {
        const hashed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.hash_key)(value);
        if (hashed === null)
            return null;
        const option = this.options[hashed];
        if (option != undefined) {
            if (option.$div) {
                return option.$div;
            }
            if (create) {
                return this._render('option', option);
            }
        }
        return null;
    }
    /**
     * Returns the dom element of the next or previous dom element of the same type
     * Note: adjacent options may not be adjacent DOM elements (optgroups)
     *
     */
    getAdjacent(option, direction, type = 'option') {
        var self = this, all;
        if (!option) {
            return null;
        }
        if (type == 'item') {
            all = self.controlChildren();
        }
        else {
            all = self.dropdown_content.querySelectorAll('[data-selectable]');
        }
        for (let i = 0; i < all.length; i++) {
            if (all[i] != option) {
                continue;
            }
            if (direction > 0) {
                return all[i + 1];
            }
            return all[i - 1];
        }
        return null;
    }
    /**
     * Returns the dom element of the item
     * matching the given value.
     *
     */
    getItem(item) {
        if (typeof item == 'object') {
            return item;
        }
        var value = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.hash_key)(item);
        return value !== null
            ? this.control.querySelector(`[data-value="${(0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addSlashes)(value)}"]`)
            : null;
    }
    /**
     * "Selects" multiple items at once. Adds them to the list
     * at the current caret position.
     *
     */
    addItems(values, silent) {
        var self = this;
        var items = Array.isArray(values) ? values : [values];
        items = items.filter(x => self.items.indexOf(x) === -1);
        const last_item = items[items.length - 1];
        items.forEach(item => {
            self.isPending = (item !== last_item);
            self.addItem(item, silent);
        });
    }
    /**
     * "Selects" an item. Adds it to the list
     * at the current caret position.
     *
     */
    addItem(value, silent) {
        var events = silent ? [] : ['change', 'dropdown_close'];
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.debounce_events)(this, events, () => {
            var item, wasFull;
            const self = this;
            const inputMode = self.settings.mode;
            const hashed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.hash_key)(value);
            if (hashed && self.items.indexOf(hashed) !== -1) {
                if (inputMode === 'single') {
                    self.close();
                }
                if (inputMode === 'single' || !self.settings.duplicates) {
                    return;
                }
            }
            if (hashed === null || !self.options.hasOwnProperty(hashed))
                return;
            if (inputMode === 'single')
                self.clear(silent);
            if (inputMode === 'multi' && self.isFull())
                return;
            item = self._render('item', self.options[hashed]);
            if (self.control.contains(item)) { // duplicates
                item = item.cloneNode(true);
            }
            wasFull = self.isFull();
            self.items.splice(self.caretPos, 0, hashed);
            self.insertAtCaret(item);
            if (self.isSetup) {
                // update menu / remove the option (if this is not one item being added as part of series)
                if (!self.isPending && self.settings.hideSelected) {
                    let option = self.getOption(hashed);
                    let next = self.getAdjacent(option, 1);
                    if (next) {
                        self.setActiveOption(next);
                    }
                }
                // refreshOptions after setActiveOption(),
                // otherwise setActiveOption() will be called by refreshOptions() with the wrong value
                if (!self.isPending && !self.settings.closeAfterSelect) {
                    self.refreshOptions(self.isFocused && inputMode !== 'single');
                }
                // hide the menu if the maximum number of items have been selected or no options are left
                if (self.settings.closeAfterSelect != false && self.isFull()) {
                    self.close();
                }
                else if (!self.isPending) {
                    self.positionDropdown();
                }
                self.trigger('item_add', hashed, item);
                if (!self.isPending) {
                    self.updateOriginalInput({ silent: silent });
                }
            }
            if (!self.isPending || (!wasFull && self.isFull())) {
                self.inputState();
                self.refreshState();
            }
        });
    }
    /**
     * Removes the selected item matching
     * the provided value.
     *
     */
    removeItem(item = null, silent) {
        const self = this;
        item = self.getItem(item);
        if (!item)
            return;
        var i, idx;
        const value = item.dataset.value;
        i = (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.nodeIndex)(item);
        item.remove();
        if (item.classList.contains('active')) {
            idx = self.activeItems.indexOf(item);
            self.activeItems.splice(idx, 1);
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.removeClasses)(item, 'active');
        }
        self.items.splice(i, 1);
        self.lastQuery = null;
        if (!self.settings.persist && self.userOptions.hasOwnProperty(value)) {
            self.removeOption(value, silent);
        }
        if (i < self.caretPos) {
            self.setCaret(self.caretPos - 1);
        }
        self.updateOriginalInput({ silent: silent });
        self.refreshState();
        self.positionDropdown();
        self.trigger('item_remove', value, item);
    }
    /**
     * Invokes the `create` method provided in the
     * TomSelect options that should provide the data
     * for the new item, given the user input.
     *
     * Once this completes, it will be added
     * to the item list.
     *
     */
    createItem(input = null, callback = () => { }) {
        // triggerDropdown parameter @deprecated 2.1.1
        if (arguments.length === 3) {
            callback = arguments[2];
        }
        if (typeof callback != 'function') {
            callback = () => { };
        }
        var self = this;
        var caret = self.caretPos;
        var output;
        input = input || self.inputValue();
        if (!self.canCreate(input)) {
            callback();
            return false;
        }
        self.lock();
        var created = false;
        var create = (data) => {
            self.unlock();
            if (!data || typeof data !== 'object')
                return callback();
            var value = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.hash_key)(data[self.settings.valueField]);
            if (typeof value !== 'string') {
                return callback();
            }
            self.setTextboxValue();
            self.addOption(data, true);
            self.setCaret(caret);
            self.addItem(value);
            callback(data);
            created = true;
        };
        if (typeof self.settings.create === 'function') {
            output = self.settings.create.call(this, input, create);
        }
        else {
            output = {
                [self.settings.labelField]: input,
                [self.settings.valueField]: input,
            };
        }
        if (!created) {
            create(output);
        }
        return true;
    }
    /**
     * Re-renders the selected item lists.
     */
    refreshItems() {
        var self = this;
        self.lastQuery = null;
        if (self.isSetup) {
            self.addItems(self.items);
        }
        self.updateOriginalInput();
        self.refreshState();
    }
    /**
     * Updates all state-dependent attributes
     * and CSS classes.
     */
    refreshState() {
        const self = this;
        self.refreshValidityState();
        const isFull = self.isFull();
        const isLocked = self.isLocked;
        self.wrapper.classList.toggle('rtl', self.rtl);
        const wrap_classList = self.wrapper.classList;
        wrap_classList.toggle('focus', self.isFocused);
        wrap_classList.toggle('disabled', self.isDisabled);
        wrap_classList.toggle('readonly', self.isReadOnly);
        wrap_classList.toggle('required', self.isRequired);
        wrap_classList.toggle('invalid', !self.isValid);
        wrap_classList.toggle('locked', isLocked);
        wrap_classList.toggle('full', isFull);
        wrap_classList.toggle('input-active', self.isFocused && !self.isInputHidden);
        wrap_classList.toggle('dropdown-active', self.isOpen);
        wrap_classList.toggle('has-options', (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.isEmptyObject)(self.options));
        wrap_classList.toggle('has-items', self.items.length > 0);
    }
    /**
     * Update the `required` attribute of both input and control input.
     *
     * The `required` property needs to be activated on the control input
     * for the error to be displayed at the right place. `required` also
     * needs to be temporarily deactivated on the input since the input is
     * hidden and can't show errors.
     */
    refreshValidityState() {
        var self = this;
        if (!self.input.validity) {
            return;
        }
        self.isValid = self.input.validity.valid;
        self.isInvalid = !self.isValid;
    }
    /**
     * Determines whether or not more items can be added
     * to the control without exceeding the user-defined maximum.
     *
     * @returns {boolean}
     */
    isFull() {
        return this.settings.maxItems !== null && this.items.length >= this.settings.maxItems;
    }
    /**
     * Refreshes the original <select> or <input>
     * element to reflect the current state.
     *
     */
    updateOriginalInput(opts = {}) {
        const self = this;
        var option, label;
        const empty_option = self.input.querySelector('option[value=""]');
        if (self.is_select_tag) {
            const selected = [];
            const has_selected = self.input.querySelectorAll('option:checked').length;
            function AddSelected(option_el, value, label) {
                if (!option_el) {
                    option_el = (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.getDom)('<option value="' + (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.escape_html)(value) + '">' + (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.escape_html)(label) + '</option>');
                }
                // don't move empty option from top of list
                // fixes bug in firefox https://bugzilla.mozilla.org/show_bug.cgi?id=1725293
                if (option_el != empty_option) {
                    self.input.append(option_el);
                }
                selected.push(option_el);
                // marking empty option as selected can break validation
                // fixes https://github.com/orchidjs/tom-select/issues/303
                if (option_el != empty_option || has_selected > 0) {
                    option_el.selected = true;
                }
                return option_el;
            }
            // unselect all selected options
            self.input.querySelectorAll('option:checked').forEach((option_el) => {
                option_el.selected = false;
            });
            // nothing selected?
            if (self.items.length == 0 && self.settings.mode == 'single') {
                AddSelected(empty_option, "", "");
                // order selected <option> tags for values in self.items
            }
            else {
                self.items.forEach((value) => {
                    option = self.options[value];
                    label = option[self.settings.labelField] || '';
                    if (selected.includes(option.$option)) {
                        const reuse_opt = self.input.querySelector(`option[value="${(0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addSlashes)(value)}"]:not(:checked)`);
                        AddSelected(reuse_opt, value, label);
                    }
                    else {
                        option.$option = AddSelected(option.$option, value, label);
                    }
                });
            }
        }
        else {
            self.input.value = self.getValue();
        }
        if (self.isSetup) {
            if (!opts.silent) {
                self.trigger('change', self.getValue());
            }
        }
    }
    /**
     * Shows the autocomplete dropdown containing
     * the available options.
     */
    open() {
        var self = this;
        if (self.isLocked || self.isOpen || (self.settings.mode === 'multi' && self.isFull()))
            return;
        self.isOpen = true;
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(self.focus_node, { 'aria-expanded': 'true' });
        self.refreshState();
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.applyCSS)(self.dropdown, { visibility: 'hidden', display: 'block' });
        self.positionDropdown();
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.applyCSS)(self.dropdown, { visibility: 'visible', display: 'block' });
        self.focus();
        self.trigger('dropdown_open', self.dropdown);
    }
    /**
     * Closes the autocomplete dropdown menu.
     */
    close(setTextboxValue = true) {
        var self = this;
        var trigger = self.isOpen;
        if (setTextboxValue) {
            // before blur() to prevent form onchange event
            self.setTextboxValue();
            if (self.settings.mode === 'single' && self.items.length) {
                self.inputState();
            }
        }
        self.isOpen = false;
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(self.focus_node, { 'aria-expanded': 'false' });
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.applyCSS)(self.dropdown, { display: 'none' });
        if (self.settings.hideSelected) {
            self.clearActiveOption();
        }
        self.refreshState();
        if (trigger)
            self.trigger('dropdown_close', self.dropdown);
    }
    /**
     * Calculates and applies the appropriate
     * position of the dropdown if dropdownParent = 'body'.
     * Otherwise, position is determined by css
     */
    positionDropdown() {
        if (this.settings.dropdownParent !== 'body') {
            return;
        }
        var context = this.control;
        var rect = context.getBoundingClientRect();
        var top = context.offsetHeight + rect.top + window.scrollY;
        var left = rect.left + window.scrollX;
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.applyCSS)(this.dropdown, {
            width: rect.width + 'px',
            top: top + 'px',
            left: left + 'px'
        });
    }
    /**
     * Resets / clears all selected items
     * from the control.
     *
     */
    clear(silent) {
        var self = this;
        if (!self.items.length)
            return;
        var items = self.controlChildren();
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.iterate)(items, (item) => {
            self.removeItem(item, true);
        });
        self.inputState();
        if (!silent)
            self.updateOriginalInput();
        self.trigger('clear');
    }
    /**
     * A helper method for inserting an element
     * at the current caret position.
     *
     */
    insertAtCaret(el) {
        const self = this;
        const caret = self.caretPos;
        const target = self.control;
        target.insertBefore(el, target.children[caret] || null);
        self.setCaret(caret + 1);
    }
    /**
     * Removes the current selected item(s).
     *
     */
    deleteSelection(e) {
        var direction, selection, caret, tail;
        var self = this;
        direction = (e && e.keyCode === _constants_js__WEBPACK_IMPORTED_MODULE_5__.KEY_BACKSPACE) ? -1 : 1;
        selection = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.getSelection)(self.control_input);
        // determine items that will be removed
        const rm_items = [];
        if (self.activeItems.length) {
            tail = (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.getTail)(self.activeItems, direction);
            caret = (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.nodeIndex)(tail);
            if (direction > 0) {
                caret++;
            }
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.iterate)(self.activeItems, (item) => rm_items.push(item));
        }
        else if ((self.isFocused || self.settings.mode === 'single') && self.items.length) {
            const items = self.controlChildren();
            let rm_item;
            if (direction < 0 && selection.start === 0 && selection.length === 0) {
                rm_item = items[self.caretPos - 1];
            }
            else if (direction > 0 && selection.start === self.inputValue().length) {
                rm_item = items[self.caretPos];
            }
            if (rm_item !== undefined) {
                rm_items.push(rm_item);
            }
        }
        if (!self.shouldDelete(rm_items, e)) {
            return false;
        }
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e, true);
        // perform removal
        if (typeof caret !== 'undefined') {
            self.setCaret(caret);
        }
        while (rm_items.length) {
            self.removeItem(rm_items.pop());
        }
        self.inputState();
        self.positionDropdown();
        self.refreshOptions(false);
        return true;
    }
    /**
     * Return true if the items should be deleted
     */
    shouldDelete(items, evt) {
        const values = items.map(item => item.dataset.value);
        // allow the callback to abort
        if (!values.length || (typeof this.settings.onDelete === 'function' && this.settings.onDelete(values, evt) === false)) {
            return false;
        }
        return true;
    }
    /**
     * Selects the previous / next item (depending on the `direction` argument).
     *
     * > 0 - right
     * < 0 - left
     *
     */
    advanceSelection(direction, e) {
        var last_active, adjacent, self = this;
        if (self.rtl)
            direction *= -1;
        if (self.inputValue().length)
            return;
        // add or remove to active items
        if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.isKeyDown)(_constants_js__WEBPACK_IMPORTED_MODULE_5__.KEY_SHORTCUT, e) || (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.isKeyDown)('shiftKey', e)) {
            last_active = self.getLastActive(direction);
            if (last_active) {
                if (!last_active.classList.contains('active')) {
                    adjacent = last_active;
                }
                else {
                    adjacent = self.getAdjacent(last_active, direction, 'item');
                }
                // if no active item, get items adjacent to the control input
            }
            else if (direction > 0) {
                adjacent = self.control_input.nextElementSibling;
            }
            else {
                adjacent = self.control_input.previousElementSibling;
            }
            if (adjacent) {
                if (adjacent.classList.contains('active')) {
                    self.removeActiveItem(last_active);
                }
                self.setActiveItemClass(adjacent); // mark as last_active !! after removeActiveItem() on last_active
            }
            // move caret to the left or right
        }
        else {
            self.moveCaret(direction);
        }
    }
    moveCaret(direction) { }
    /**
     * Get the last active item
     *
     */
    getLastActive(direction) {
        let last_active = this.control.querySelector('.last-active');
        if (last_active) {
            return last_active;
        }
        var result = this.control.querySelectorAll('.active');
        if (result) {
            return (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.getTail)(result, direction);
        }
    }
    /**
     * Moves the caret to the specified index.
     *
     * The input must be moved by leaving it in place and moving the
     * siblings, due to the fact that focus cannot be restored once lost
     * on mobile webkit devices
     *
     */
    setCaret(new_pos) {
        this.caretPos = this.items.length;
    }
    /**
     * Return list of item dom elements
     *
     */
    controlChildren() {
        return Array.from(this.control.querySelectorAll('[data-ts-item]'));
    }
    /**
     * Disables user input on the control. Used while
     * items are being asynchronously created.
     */
    lock() {
        this.setLocked(true);
    }
    /**
     * Re-enables user input on the control.
     */
    unlock() {
        this.setLocked(false);
    }
    /**
     * Disable or enable user input on the control
     */
    setLocked(lock = this.isReadOnly || this.isDisabled) {
        this.isLocked = lock;
        this.refreshState();
    }
    /**
     * Disables user input on the control completely.
     * While disabled, it cannot receive focus.
     */
    disable() {
        this.setDisabled(true);
        this.close();
    }
    /**
     * Enables the control so that it can respond
     * to focus and user input.
     */
    enable() {
        this.setDisabled(false);
    }
    setDisabled(disabled) {
        this.focus_node.tabIndex = disabled ? -1 : this.tabIndex;
        this.isDisabled = disabled;
        this.input.disabled = disabled;
        this.control_input.disabled = disabled;
        this.setLocked();
    }
    setReadOnly(isReadOnly) {
        this.isReadOnly = isReadOnly;
        this.input.readOnly = isReadOnly;
        this.control_input.readOnly = isReadOnly;
        this.setLocked();
    }
    /**
     * Completely destroys the control and
     * unbinds all event listeners so that it can
     * be garbage collected.
     */
    destroy() {
        var self = this;
        var revertSettings = self.revertSettings;
        self.trigger('destroy');
        self.off();
        self.wrapper.remove();
        self.dropdown.remove();
        self.input.innerHTML = revertSettings.innerHTML;
        self.input.tabIndex = revertSettings.tabIndex;
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.removeClasses)(self.input, 'tomselected', 'ts-hidden-accessible');
        self._destroy();
        delete self.input.tomselect;
    }
    /**
     * A helper method for rendering "item" and
     * "option" templates, given the data.
     *
     */
    render(templateName, data) {
        var id, html;
        const self = this;
        if (typeof this.settings.render[templateName] !== 'function') {
            return null;
        }
        // render markup
        html = self.settings.render[templateName].call(this, data, _utils_js__WEBPACK_IMPORTED_MODULE_7__.escape_html);
        if (!html) {
            return null;
        }
        html = (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.getDom)(html);
        // add mandatory attributes
        if (templateName === 'option' || templateName === 'option_create') {
            if (data[self.settings.disabledField]) {
                (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(html, { 'aria-disabled': 'true' });
            }
            else {
                (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(html, { 'data-selectable': '' });
            }
        }
        else if (templateName === 'optgroup') {
            id = data.group[self.settings.optgroupValueField];
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(html, { 'data-group': id });
            if (data.group[self.settings.disabledField]) {
                (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(html, { 'data-disabled': '' });
            }
        }
        if (templateName === 'option' || templateName === 'item') {
            const value = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.get_hash)(data[self.settings.valueField]);
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(html, { 'data-value': value });
            // make sure we have some classes if a template is overwritten
            if (templateName === 'item') {
                (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.addClasses)(html, self.settings.itemClass);
                (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(html, { 'data-ts-item': '' });
            }
            else {
                (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.addClasses)(html, self.settings.optionClass);
                (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(html, {
                    role: 'option',
                    id: data.$id
                });
                // update cache
                data.$div = html;
                self.options[value] = data;
            }
        }
        return html;
    }
    /**
     * Type guarded rendering
     *
     */
    _render(templateName, data) {
        const html = this.render(templateName, data);
        if (html == null) {
            throw 'HTMLElement expected';
        }
        return html;
    }
    /**
     * Clears the render cache for a template. If
     * no template is given, clears all render
     * caches.
     *
     */
    clearCache() {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.iterate)(this.options, (option) => {
            if (option.$div) {
                option.$div.remove();
                delete option.$div;
            }
        });
    }
    /**
     * Removes a value from item and option caches
     *
     */
    uncacheValue(value) {
        const option_el = this.getOption(value);
        if (option_el)
            option_el.remove();
    }
    /**
     * Determines whether or not to display the
     * create item prompt, given a user input.
     *
     */
    canCreate(input) {
        return this.settings.create && (input.length > 0) && this.settings.createFilter.call(this, input);
    }
    /**
     * Wraps this.`method` so that `new_fn` can be invoked 'before', 'after', or 'instead' of the original method
     *
     * this.hook('instead','onKeyDown',function( arg1, arg2 ...){
     *
     * });
     */
    hook(when, method, new_fn) {
        var self = this;
        var orig_method = self[method];
        self[method] = function () {
            var result, result_new;
            if (when === 'after') {
                result = orig_method.apply(self, arguments);
            }
            result_new = new_fn.apply(self, arguments);
            if (when === 'instead') {
                return result_new;
            }
            if (when === 'before') {
                result = orig_method.apply(self, arguments);
            }
            return result;
        };
    }
}
;
//# sourceMappingURL=tom-select.js.map

/***/ }),

/***/ "./node_modules/tom-select/dist/esm/utils.js":
/*!***************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/utils.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addEvent: function() { return /* binding */ addEvent; },
/* harmony export */   addSlashes: function() { return /* binding */ addSlashes; },
/* harmony export */   append: function() { return /* binding */ append; },
/* harmony export */   debounce_events: function() { return /* binding */ debounce_events; },
/* harmony export */   escape_html: function() { return /* binding */ escape_html; },
/* harmony export */   getId: function() { return /* binding */ getId; },
/* harmony export */   getSelection: function() { return /* binding */ getSelection; },
/* harmony export */   get_hash: function() { return /* binding */ get_hash; },
/* harmony export */   hash_key: function() { return /* binding */ hash_key; },
/* harmony export */   isKeyDown: function() { return /* binding */ isKeyDown; },
/* harmony export */   iterate: function() { return /* binding */ iterate; },
/* harmony export */   loadDebounce: function() { return /* binding */ loadDebounce; },
/* harmony export */   preventDefault: function() { return /* binding */ preventDefault; },
/* harmony export */   timeout: function() { return /* binding */ timeout; }
/* harmony export */ });
/**
 * Converts a scalar to its best string representation
 * for hash keys and HTML attribute values.
 *
 * Transformations:
 *   'str'     -> 'str'
 *   null      -> ''
 *   undefined -> ''
 *   true      -> '1'
 *   false     -> '0'
 *   0         -> '0'
 *   1         -> '1'
 *
 */
const hash_key = (value) => {
    if (typeof value === 'undefined' || value === null)
        return null;
    return get_hash(value);
};
const get_hash = (value) => {
    if (typeof value === 'boolean')
        return value ? '1' : '0';
    return value + '';
};
/**
 * Escapes a string for use within HTML.
 *
 */
const escape_html = (str) => {
    return (str + '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;');
};
/**
 * use setTimeout if timeout > 0
 */
const timeout = (fn, timeout) => {
    if (timeout > 0) {
        return window.setTimeout(fn, timeout);
    }
    fn.call(null);
    return null;
};
/**
 * Debounce the user provided load function
 *
 */
const loadDebounce = (fn, delay) => {
    var timeout;
    return function (value, callback) {
        var self = this;
        if (timeout) {
            self.loading = Math.max(self.loading - 1, 0);
            clearTimeout(timeout);
        }
        timeout = setTimeout(function () {
            timeout = null;
            self.loadedSearches[value] = true;
            fn.call(self, value, callback);
        }, delay);
    };
};
/**
 * Debounce all fired events types listed in `types`
 * while executing the provided `fn`.
 *
 */
const debounce_events = (self, types, fn) => {
    var type;
    var trigger = self.trigger;
    var event_args = {};
    // override trigger method
    self.trigger = function () {
        var type = arguments[0];
        if (types.indexOf(type) !== -1) {
            event_args[type] = arguments;
        }
        else {
            return trigger.apply(self, arguments);
        }
    };
    // invoke provided function
    fn.apply(self, []);
    self.trigger = trigger;
    // trigger queued events
    for (type of types) {
        if (type in event_args) {
            trigger.apply(self, event_args[type]);
        }
    }
};
/**
 * Determines the current selection within a text input control.
 * Returns an object containing:
 *   - start
 *   - length
 *
 * Note: "selectionStart, selectionEnd ... apply only to inputs of types text, search, URL, tel and password"
 * 	- https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/setSelectionRange
 */
const getSelection = (input) => {
    return {
        start: input.selectionStart || 0,
        length: (input.selectionEnd || 0) - (input.selectionStart || 0),
    };
};
/**
 * Prevent default
 *
 */
const preventDefault = (evt, stop = false) => {
    if (evt) {
        evt.preventDefault();
        if (stop) {
            evt.stopPropagation();
        }
    }
};
/**
 * Add event helper
 *
 */
const addEvent = (target, type, callback, options) => {
    target.addEventListener(type, callback, options);
};
/**
 * Return true if the requested key is down
 * Will return false if more than one control character is pressed ( when [ctrl+shift+a] != [ctrl+a] )
 * The current evt may not always set ( eg calling advanceSelection() )
 *
 */
const isKeyDown = (key_name, evt) => {
    if (!evt) {
        return false;
    }
    if (!evt[key_name]) {
        return false;
    }
    var count = (evt.altKey ? 1 : 0) + (evt.ctrlKey ? 1 : 0) + (evt.shiftKey ? 1 : 0) + (evt.metaKey ? 1 : 0);
    if (count === 1) {
        return true;
    }
    return false;
};
/**
 * Get the id of an element
 * If the id attribute is not set, set the attribute with the given id
 *
 */
const getId = (el, id) => {
    const existing_id = el.getAttribute('id');
    if (existing_id) {
        return existing_id;
    }
    el.setAttribute('id', id);
    return id;
};
/**
 * Returns a string with backslashes added before characters that need to be escaped.
 */
const addSlashes = (str) => {
    return str.replace(/[\\"']/g, '\\$&');
};
/**
 *
 */
const append = (parent, node) => {
    if (node)
        parent.append(node);
};
/**
 * Iterates over arrays and hashes.
 *
 * ```
 * iterate(this.items, function(item, id) {
 *    // invoked for each item
 * });
 * ```
 *
 */
const iterate = (object, callback) => {
    if (Array.isArray(object)) {
        object.forEach(callback);
    }
    else {
        for (var key in object) {
            if (object.hasOwnProperty(key)) {
                callback(object[key], key);
            }
        }
    }
};
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/tom-select/dist/esm/vanilla.js":
/*!*****************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/vanilla.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addClasses: function() { return /* binding */ addClasses; },
/* harmony export */   applyCSS: function() { return /* binding */ applyCSS; },
/* harmony export */   castAsArray: function() { return /* binding */ castAsArray; },
/* harmony export */   classesArray: function() { return /* binding */ classesArray; },
/* harmony export */   escapeQuery: function() { return /* binding */ escapeQuery; },
/* harmony export */   getDom: function() { return /* binding */ getDom; },
/* harmony export */   getTail: function() { return /* binding */ getTail; },
/* harmony export */   isEmptyObject: function() { return /* binding */ isEmptyObject; },
/* harmony export */   isHtmlString: function() { return /* binding */ isHtmlString; },
/* harmony export */   nodeIndex: function() { return /* binding */ nodeIndex; },
/* harmony export */   parentMatch: function() { return /* binding */ parentMatch; },
/* harmony export */   removeClasses: function() { return /* binding */ removeClasses; },
/* harmony export */   replaceNode: function() { return /* binding */ replaceNode; },
/* harmony export */   setAttr: function() { return /* binding */ setAttr; },
/* harmony export */   triggerEvent: function() { return /* binding */ triggerEvent; }
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/tom-select/dist/esm/utils.js");

/**
 * Return a dom element from either a dom query string, jQuery object, a dom element or html string
 * https://stackoverflow.com/questions/494143/creating-a-new-dom-element-from-an-html-string-using-built-in-dom-methods-or-pro/35385518#35385518
 *
 * param query should be {}
 */
const getDom = (query) => {
    if (query.jquery) {
        return query[0];
    }
    if (query instanceof HTMLElement) {
        return query;
    }
    if (isHtmlString(query)) {
        var tpl = document.createElement('template');
        tpl.innerHTML = query.trim(); // Never return a text node of whitespace as the result
        return tpl.content.firstChild;
    }
    return document.querySelector(query);
};
const isHtmlString = (arg) => {
    if (typeof arg === 'string' && arg.indexOf('<') > -1) {
        return true;
    }
    return false;
};
const escapeQuery = (query) => {
    return query.replace(/['"\\]/g, '\\$&');
};
/**
 * Dispatch an event
 *
 */
const triggerEvent = (dom_el, event_name) => {
    var event = document.createEvent('HTMLEvents');
    event.initEvent(event_name, true, false);
    dom_el.dispatchEvent(event);
};
/**
 * Apply CSS rules to a dom element
 *
 */
const applyCSS = (dom_el, css) => {
    Object.assign(dom_el.style, css);
};
/**
 * Add css classes
 *
 */
const addClasses = (elmts, ...classes) => {
    var norm_classes = classesArray(classes);
    elmts = castAsArray(elmts);
    elmts.map(el => {
        norm_classes.map(cls => {
            el.classList.add(cls);
        });
    });
};
/**
 * Remove css classes
 *
 */
const removeClasses = (elmts, ...classes) => {
    var norm_classes = classesArray(classes);
    elmts = castAsArray(elmts);
    elmts.map(el => {
        norm_classes.map(cls => {
            el.classList.remove(cls);
        });
    });
};
/**
 * Return arguments
 *
 */
const classesArray = (args) => {
    var classes = [];
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.iterate)(args, (_classes) => {
        if (typeof _classes === 'string') {
            _classes = _classes.trim().split(/[\t\n\f\r\s]/);
        }
        if (Array.isArray(_classes)) {
            classes = classes.concat(_classes);
        }
    });
    return classes.filter(Boolean);
};
/**
 * Create an array from arg if it's not already an array
 *
 */
const castAsArray = (arg) => {
    if (!Array.isArray(arg)) {
        arg = [arg];
    }
    return arg;
};
/**
 * Get the closest node to the evt.target matching the selector
 * Stops at wrapper
 *
 */
const parentMatch = (target, selector, wrapper) => {
    if (wrapper && !wrapper.contains(target)) {
        return;
    }
    while (target && target.matches) {
        if (target.matches(selector)) {
            return target;
        }
        target = target.parentNode;
    }
};
/**
 * Get the first or last item from an array
 *
 * > 0 - right (last)
 * <= 0 - left (first)
 *
 */
const getTail = (list, direction = 0) => {
    if (direction > 0) {
        return list[list.length - 1];
    }
    return list[0];
};
/**
 * Return true if an object is empty
 *
 */
const isEmptyObject = (obj) => {
    return (Object.keys(obj).length === 0);
};
/**
 * Get the index of an element amongst sibling nodes of the same type
 *
 */
const nodeIndex = (el, amongst) => {
    if (!el)
        return -1;
    amongst = amongst || el.nodeName;
    var i = 0;
    while (el = el.previousElementSibling) {
        if (el.matches(amongst)) {
            i++;
        }
    }
    return i;
};
/**
 * Set attributes of an element
 *
 */
const setAttr = (el, attrs) => {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.iterate)(attrs, (val, attr) => {
        if (val == null) {
            el.removeAttribute(attr);
        }
        else {
            el.setAttribute(attr, '' + val);
        }
    });
};
/**
 * Replace a node
 */
const replaceNode = (existing, replacement) => {
    if (existing.parentNode)
        existing.parentNode.replaceChild(replacement, existing);
};
//# sourceMappingURL=vanilla.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfY29yZS1qc19tb2R1bGVzX2VzX2FycmF5X2ZpbmRfanMtbm9kZV9tb2R1bGVzX2NvcmUtanNfbW9kdWxlc19lc193ZWFrLXNlLTk4YmUxNy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzRGO0FBQ3RCO0FBQ3RFO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLG9FQUFZO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzRUFBVTtBQUN0QztBQUNBO0FBQ0EsNEJBQTRCLHdFQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscURBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxREFBVTtBQUN6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QUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUU2QjtBQUM3Qjs7Ozs7Ozs7Ozs7Ozs7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFNkI7QUFDN0I7Ozs7Ozs7Ozs7Ozs7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFD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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRTZCO0FBQzdCOzs7Ozs7Ozs7Ozs7Ozs7QUNyTkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsY0FBYyxl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QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFNkI7QUFDN0I7Ozs7Ozs7Ozs7Ozs7OztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xNcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxJQUFJLGtEQUFPO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksa0RBQU87QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vamphLWRldi8uL25vZGVfbW9kdWxlcy9Ab3JjaGlkanMvc2lmdGVyL2Rpc3QvZXNtL3NpZnRlci5qcyIsIndlYnBhY2s6Ly9qamEtZGV2Ly4vbm9kZV9tb2R1bGVzL0BvcmNoaWRqcy9zaWZ0ZXIvZGlzdC9lc20vdHlwZXMuanMiLCJ3ZWJwYWNrOi8vamphLWRldi8uL25vZGVfbW9kdWxlcy9Ab3JjaGlkanMvc2lmdGVyL2Rpc3QvZXNtL3V0aWxzLmpzIiwid2VicGFjazovL2pqYS1kZXYvLi9ub2RlX21vZHVsZXMvQG9yY2hpZGpzL3VuaWNvZGUtdmFyaWFudHMvZGlzdC9lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vamphLWRldi8uL25vZGVfbW9kdWxlcy9Ab3JjaGlkanMvdW5pY29kZS12YXJpYW50cy9kaXN0L2VzbS9yZWdleC5qcyIsIndlYnBhY2s6Ly9qamEtZGV2Ly4vbm9kZV9tb2R1bGVzL0BvcmNoaWRqcy91bmljb2RlLXZhcmlhbnRzL2Rpc3QvZXNtL3N0cmluZ3MuanMiLCJ3ZWJwYWNrOi8vamphLWRldi8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmluZC5qcyIsIndlYnBhY2s6Ly9qamEtZGV2Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy53ZWFrLXNldC5jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly9qamEtZGV2Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy53ZWFrLXNldC5qcyIsIndlYnBhY2s6Ly9qamEtZGV2Ly4vbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3QvZGlzdC9lc20vY29uc3RhbnRzLmpzIiwid2VicGFjazovL2pqYS1kZXYvLi9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9kaXN0L2VzbS9jb250cmliL2hpZ2hsaWdodC5qcyIsIndlYnBhY2s6Ly9qamEtZGV2Ly4vbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3QvZGlzdC9lc20vY29udHJpYi9taWNyb2V2ZW50LmpzIiwid2VicGFjazovL2pqYS1kZXYvLi9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9kaXN0L2VzbS9jb250cmliL21pY3JvcGx1Z2luLmpzIiwid2VicGFjazovL2pqYS1kZXYvLi9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9kaXN0L2VzbS9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly9qamEtZGV2Ly4vbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3QvZGlzdC9lc20vZ2V0U2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vamphLWRldi8uL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L2Rpc3QvZXNtL3BsdWdpbnMvY2FyZXRfcG9zaXRpb24vcGx1Z2luLmpzIiwid2VicGFjazovL2pqYS1kZXYvLi9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9kaXN0L2VzbS9wbHVnaW5zL2NoYW5nZV9saXN0ZW5lci9wbHVnaW4uanMiLCJ3ZWJwYWNrOi8vamphLWRldi8uL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L2Rpc3QvZXNtL3BsdWdpbnMvY2hlY2tib3hfb3B0aW9ucy9wbHVnaW4uanMiLCJ3ZWJwYWNrOi8vamphLWRldi8uL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L2Rpc3QvZXNtL3BsdWdpbnMvY2xlYXJfYnV0dG9uL3BsdWdpbi5qcyIsIndlYnBhY2s6Ly9qamEtZGV2Ly4vbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3QvZGlzdC9lc20vcGx1Z2lucy9kcmFnX2Ryb3AvcGx1Z2luLmpzIiwid2VicGFjazovL2pqYS1kZXYvLi9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9kaXN0L2VzbS9wbHVnaW5zL2Ryb3Bkb3duX2hlYWRlci9wbHVnaW4uanMiLCJ3ZWJwYWNrOi8vamphLWRldi8uL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L2Rpc3QvZXNtL3BsdWdpbnMvZHJvcGRvd25faW5wdXQvcGx1Z2luLmpzIiwid2VicGFjazovL2pqYS1kZXYvLi9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9kaXN0L2VzbS9wbHVnaW5zL2lucHV0X2F1dG9ncm93L3BsdWdpbi5qcyIsIndlYnBhY2s6Ly9qamEtZGV2Ly4vbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3QvZGlzdC9lc20vcGx1Z2lucy9ub19hY3RpdmVfaXRlbXMvcGx1Z2luLmpzIiwid2VicGFjazovL2pqYS1kZXYvLi9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9kaXN0L2VzbS9wbHVnaW5zL25vX2JhY2tzcGFjZV9kZWxldGUvcGx1Z2luLmpzIiwid2VicGFjazovL2pqYS1kZXYvLi9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9kaXN0L2VzbS9wbHVnaW5zL29wdGdyb3VwX2NvbHVtbnMvcGx1Z2luLmpzIiwid2VicGFjazovL2pqYS1kZXYvLi9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9kaXN0L2VzbS9wbHVnaW5zL3JlbW92ZV9idXR0b24vcGx1Z2luLmpzIiwid2VicGFjazovL2pqYS1kZXYvLi9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9kaXN0L2VzbS9wbHVnaW5zL3Jlc3RvcmVfb25fYmFja3NwYWNlL3BsdWdpbi5qcyIsIndlYnBhY2s6Ly9qamEtZGV2Ly4vbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3QvZGlzdC9lc20vcGx1Z2lucy92aXJ0dWFsX3Njcm9sbC9wbHVnaW4uanMiLCJ3ZWJwYWNrOi8vamphLWRldi8uL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L2Rpc3QvZXNtL3RvbS1zZWxlY3QuY29tcGxldGUuanMiLCJ3ZWJwYWNrOi8vamphLWRldi8uL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L2Rpc3QvZXNtL3RvbS1zZWxlY3QuanMiLCJ3ZWJwYWNrOi8vamphLWRldi8uL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L2Rpc3QvZXNtL3V0aWxzLmpzIiwid2VicGFjazovL2pqYS1kZXYvLi9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9kaXN0L2VzbS92YW5pbGxhLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogc2lmdGVyLmpzXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTPigJMyMDIwIEJyaWFuIFJlYXZpcyAmIGNvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAYXV0aG9yIEJyaWFuIFJlYXZpcyA8YnJpYW5AdGhpcmRyb3V0ZS5jb20+XG4gKi9cbmltcG9ydCB7IHNjb3JlVmFsdWUsIGdldEF0dHIsIGdldEF0dHJOZXN0aW5nLCBwcm9wVG9BcnJheSwgaXRlcmF0ZSwgY21wIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IGdldFBhdHRlcm4sIGVzY2FwZV9yZWdleCB9IGZyb20gJ0BvcmNoaWRqcy91bmljb2RlLXZhcmlhbnRzJztcbmNsYXNzIFNpZnRlciB7XG4gICAgaXRlbXM7IC8vIFtdfHt9O1xuICAgIHNldHRpbmdzO1xuICAgIC8qKlxuICAgICAqIFRleHR1YWxseSBzZWFyY2hlcyBhcnJheXMgYW5kIGhhc2hlcyBvZiBvYmplY3RzXG4gICAgICogYnkgcHJvcGVydHkgKG9yIG11bHRpcGxlIHByb3BlcnRpZXMpLiBEZXNpZ25lZFxuICAgICAqIHNwZWNpZmljYWxseSBmb3IgYXV0b2NvbXBsZXRlLlxuICAgICAqXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaXRlbXMsIHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBpdGVtcztcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzIHx8IHsgZGlhY3JpdGljczogdHJ1ZSB9O1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU3BsaXRzIGEgc2VhcmNoIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIGluZGl2aWR1YWxcbiAgICAgKiByZWdleHBzIHRvIGJlIHVzZWQgdG8gbWF0Y2ggcmVzdWx0cy5cbiAgICAgKlxuICAgICAqL1xuICAgIHRva2VuaXplKHF1ZXJ5LCByZXNwZWN0X3dvcmRfYm91bmRhcmllcywgd2VpZ2h0cykge1xuICAgICAgICBpZiAoIXF1ZXJ5IHx8ICFxdWVyeS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgICAgICBjb25zdCB3b3JkcyA9IHF1ZXJ5LnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIHZhciBmaWVsZF9yZWdleDtcbiAgICAgICAgaWYgKHdlaWdodHMpIHtcbiAgICAgICAgICAgIGZpZWxkX3JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgT2JqZWN0LmtleXMod2VpZ2h0cykubWFwKGVzY2FwZV9yZWdleCkuam9pbignfCcpICsgJylcXDooLiopJCcpO1xuICAgICAgICB9XG4gICAgICAgIHdvcmRzLmZvckVhY2goKHdvcmQpID0+IHtcbiAgICAgICAgICAgIGxldCBmaWVsZF9tYXRjaDtcbiAgICAgICAgICAgIGxldCBmaWVsZCA9IG51bGw7XG4gICAgICAgICAgICBsZXQgcmVnZXggPSBudWxsO1xuICAgICAgICAgICAgLy8gbG9vayBmb3IgXCJmaWVsZDpxdWVyeVwiIHRva2Vuc1xuICAgICAgICAgICAgaWYgKGZpZWxkX3JlZ2V4ICYmIChmaWVsZF9tYXRjaCA9IHdvcmQubWF0Y2goZmllbGRfcmVnZXgpKSkge1xuICAgICAgICAgICAgICAgIGZpZWxkID0gZmllbGRfbWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgd29yZCA9IGZpZWxkX21hdGNoWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdvcmQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmRpYWNyaXRpY3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVnZXggPSBnZXRQYXR0ZXJuKHdvcmQpIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWdleCA9IGVzY2FwZV9yZWdleCh3b3JkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlZ2V4ICYmIHJlc3BlY3Rfd29yZF9ib3VuZGFyaWVzKVxuICAgICAgICAgICAgICAgICAgICByZWdleCA9IFwiXFxcXGJcIiArIHJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIHN0cmluZzogd29yZCxcbiAgICAgICAgICAgICAgICByZWdleDogcmVnZXggPyBuZXcgUmVnRXhwKHJlZ2V4LCAnaXUnKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIGJlIHVzZWQgdG8gc2NvcmUgaW5kaXZpZHVhbCByZXN1bHRzLlxuICAgICAqXG4gICAgICogR29vZCBtYXRjaGVzIHdpbGwgaGF2ZSBhIGhpZ2hlciBzY29yZSB0aGFuIHBvb3IgbWF0Y2hlcy5cbiAgICAgKiBJZiBhbiBpdGVtIGlzIG5vdCBhIG1hdGNoLCAwIHdpbGwgYmUgcmV0dXJuZWQgYnkgdGhlIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1QuU2NvcmVGbn1cbiAgICAgKi9cbiAgICBnZXRTY29yZUZ1bmN0aW9uKHF1ZXJ5LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBzZWFyY2ggPSB0aGlzLnByZXBhcmVTZWFyY2gocXVlcnksIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U2NvcmVGdW5jdGlvbihzZWFyY2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VC5TY29yZUZufVxuICAgICAqXG4gICAgICovXG4gICAgX2dldFNjb3JlRnVuY3Rpb24oc2VhcmNoKSB7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IHNlYXJjaC50b2tlbnMsIHRva2VuX2NvdW50ID0gdG9rZW5zLmxlbmd0aDtcbiAgICAgICAgaWYgKCF0b2tlbl9jb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIDA7IH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmllbGRzID0gc2VhcmNoLm9wdGlvbnMuZmllbGRzLCB3ZWlnaHRzID0gc2VhcmNoLndlaWdodHMsIGZpZWxkX2NvdW50ID0gZmllbGRzLmxlbmd0aCwgZ2V0QXR0ckZuID0gc2VhcmNoLmdldEF0dHJGbjtcbiAgICAgICAgaWYgKCFmaWVsZF9jb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIDE7IH07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIHNjb3JlIG9mIGFuIG9iamVjdFxuICAgICAgICAgKiBhZ2FpbnN0IHRoZSBzZWFyY2ggcXVlcnkuXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBzY29yZU9iamVjdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZmllbGRfY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRva2VuLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZmllbGRzWzBdLmZpZWxkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NvcmVWYWx1ZShnZXRBdHRyRm4oZGF0YSwgZmllbGQpLCB0b2tlbiwgd2VpZ2h0c1tmaWVsZF0gfHwgMSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodG9rZW4sIGRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICAgICAgICAvLyBpcyB0aGUgdG9rZW4gc3BlY2lmaWMgdG8gYSBmaWVsZD9cbiAgICAgICAgICAgICAgICBpZiAodG9rZW4uZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRBdHRyRm4oZGF0YSwgdG9rZW4uZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRva2VuLnJlZ2V4ICYmIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdW0gKz0gKDEgLyBmaWVsZF9jb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdW0gKz0gc2NvcmVWYWx1ZSh2YWx1ZSwgdG9rZW4sIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRlKHdlaWdodHMsICh3ZWlnaHQsIGZpZWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdW0gKz0gc2NvcmVWYWx1ZShnZXRBdHRyRm4oZGF0YSwgZmllbGQpLCB0b2tlbiwgd2VpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzdW0gLyBmaWVsZF9jb3VudDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKCk7XG4gICAgICAgIGlmICh0b2tlbl9jb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3JlT2JqZWN0KHRva2Vuc1swXSwgZGF0YSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWFyY2gub3B0aW9ucy5jb25qdW5jdGlvbiA9PT0gJ2FuZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBzY29yZSwgc3VtID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcmUgPSBzY29yZU9iamVjdCh0b2tlbiwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY29yZSA8PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBzY29yZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1bSAvIHRva2VuX2NvdW50O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICAgICAgICAgIGl0ZXJhdGUodG9rZW5zLCAodG9rZW4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3VtICs9IHNjb3JlT2JqZWN0KHRva2VuLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VtIC8gdG9rZW5fY291bnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjb21wYXJlIHR3b1xuICAgICAqIHJlc3VsdHMsIGZvciBzb3J0aW5nIHB1cnBvc2VzLiBJZiBubyBzb3J0aW5nIHNob3VsZFxuICAgICAqIGJlIHBlcmZvcm1lZCwgYG51bGxgIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGZ1bmN0aW9uKGEsYilcbiAgICAgKi9cbiAgICBnZXRTb3J0RnVuY3Rpb24ocXVlcnksIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHNlYXJjaCA9IHRoaXMucHJlcGFyZVNlYXJjaChxdWVyeSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRTb3J0RnVuY3Rpb24oc2VhcmNoKTtcbiAgICB9XG4gICAgX2dldFNvcnRGdW5jdGlvbihzZWFyY2gpIHtcbiAgICAgICAgdmFyIGltcGxpY2l0X3Njb3JlLCBzb3J0X2ZsZHMgPSBbXTtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXMsIG9wdGlvbnMgPSBzZWFyY2gub3B0aW9ucywgc29ydCA9ICghc2VhcmNoLnF1ZXJ5ICYmIG9wdGlvbnMuc29ydF9lbXB0eSkgPyBvcHRpb25zLnNvcnRfZW1wdHkgOiBvcHRpb25zLnNvcnQ7XG4gICAgICAgIGlmICh0eXBlb2Ygc29ydCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gc29ydC5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaGVzIHRoZSBzcGVjaWZpZWQgc29ydCBmaWVsZCB2YWx1ZVxuICAgICAgICAgKiBmcm9tIGEgc2VhcmNoIHJlc3VsdCBpdGVtLlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgZ2V0X2ZpZWxkID0gZnVuY3Rpb24gKG5hbWUsIHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICckc2NvcmUnKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuc2NvcmU7XG4gICAgICAgICAgICByZXR1cm4gc2VhcmNoLmdldEF0dHJGbihzZWxmLml0ZW1zW3Jlc3VsdC5pZF0sIG5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBwYXJzZSBvcHRpb25zXG4gICAgICAgIGlmIChzb3J0KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBzIG9mIHNvcnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VhcmNoLnF1ZXJ5IHx8IHMuZmllbGQgIT09ICckc2NvcmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvcnRfZmxkcy5wdXNoKHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgXCIkc2NvcmVcIiBmaWVsZCBpcyBpbXBsaWVkIHRvIGJlIHRoZSBwcmltYXJ5XG4gICAgICAgIC8vIHNvcnQgZmllbGQsIHVubGVzcyBpdCdzIG1hbnVhbGx5IHNwZWNpZmllZFxuICAgICAgICBpZiAoc2VhcmNoLnF1ZXJ5KSB7XG4gICAgICAgICAgICBpbXBsaWNpdF9zY29yZSA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGxldCBmbGQgb2Ygc29ydF9mbGRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsZC5maWVsZCA9PT0gJyRzY29yZScpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1wbGljaXRfc2NvcmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGltcGxpY2l0X3Njb3JlKSB7XG4gICAgICAgICAgICAgICAgc29ydF9mbGRzLnVuc2hpZnQoeyBmaWVsZDogJyRzY29yZScsIGRpcmVjdGlvbjogJ2Rlc2MnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd2l0aG91dCBhIHNlYXJjaC5xdWVyeSwgYWxsIGl0ZW1zIHdpbGwgaGF2ZSB0aGUgc2FtZSBzY29yZVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc29ydF9mbGRzID0gc29ydF9mbGRzLmZpbHRlcigoZmxkKSA9PiBmbGQuZmllbGQgIT09ICckc2NvcmUnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBidWlsZCBmdW5jdGlvblxuICAgICAgICBjb25zdCBzb3J0X2ZsZHNfY291bnQgPSBzb3J0X2ZsZHMubGVuZ3RoO1xuICAgICAgICBpZiAoIXNvcnRfZmxkc19jb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBmaWVsZDtcbiAgICAgICAgICAgIGZvciAobGV0IHNvcnRfZmxkIG9mIHNvcnRfZmxkcykge1xuICAgICAgICAgICAgICAgIGZpZWxkID0gc29ydF9mbGQuZmllbGQ7XG4gICAgICAgICAgICAgICAgbGV0IG11bHRpcGxpZXIgPSBzb3J0X2ZsZC5kaXJlY3Rpb24gPT09ICdkZXNjJyA/IC0xIDogMTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtdWx0aXBsaWVyICogY21wKGdldF9maWVsZChmaWVsZCwgYSksIGdldF9maWVsZChmaWVsZCwgYikpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIHNlYXJjaCBxdWVyeSBhbmQgcmV0dXJucyBhbiBvYmplY3RcbiAgICAgKiB3aXRoIHRva2VucyBhbmQgZmllbGRzIHJlYWR5IHRvIGJlIHBvcHVsYXRlZFxuICAgICAqIHdpdGggcmVzdWx0cy5cbiAgICAgKlxuICAgICAqL1xuICAgIHByZXBhcmVTZWFyY2gocXVlcnksIG9wdHNVc2VyKSB7XG4gICAgICAgIGNvbnN0IHdlaWdodHMgPSB7fTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRzVXNlcik7XG4gICAgICAgIHByb3BUb0FycmF5KG9wdGlvbnMsICdzb3J0Jyk7XG4gICAgICAgIHByb3BUb0FycmF5KG9wdGlvbnMsICdzb3J0X2VtcHR5Jyk7XG4gICAgICAgIC8vIGNvbnZlcnQgZmllbGRzIHRvIG5ldyBmb3JtYXRcbiAgICAgICAgaWYgKG9wdGlvbnMuZmllbGRzKSB7XG4gICAgICAgICAgICBwcm9wVG9BcnJheShvcHRpb25zLCAnZmllbGRzJyk7XG4gICAgICAgICAgICBjb25zdCBmaWVsZHMgPSBbXTtcbiAgICAgICAgICAgIG9wdGlvbnMuZmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWVsZCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZCA9IHsgZmllbGQ6IGZpZWxkLCB3ZWlnaHQ6IDEgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmllbGRzLnB1c2goZmllbGQpO1xuICAgICAgICAgICAgICAgIHdlaWdodHNbZmllbGQuZmllbGRdID0gKCd3ZWlnaHQnIGluIGZpZWxkKSA/IGZpZWxkLndlaWdodCA6IDE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9wdGlvbnMuZmllbGRzID0gZmllbGRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LnRvTG93ZXJDYXNlKCkudHJpbSgpLFxuICAgICAgICAgICAgdG9rZW5zOiB0aGlzLnRva2VuaXplKHF1ZXJ5LCBvcHRpb25zLnJlc3BlY3Rfd29yZF9ib3VuZGFyaWVzLCB3ZWlnaHRzKSxcbiAgICAgICAgICAgIHRvdGFsOiAwLFxuICAgICAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICAgICAgd2VpZ2h0czogd2VpZ2h0cyxcbiAgICAgICAgICAgIGdldEF0dHJGbjogKG9wdGlvbnMubmVzdGluZykgPyBnZXRBdHRyTmVzdGluZyA6IGdldEF0dHIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyB0aHJvdWdoIGFsbCBpdGVtcyBhbmQgcmV0dXJucyBhIHNvcnRlZCBhcnJheSBvZiBtYXRjaGVzLlxuICAgICAqXG4gICAgICovXG4gICAgc2VhcmNoKHF1ZXJ5LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcywgc2NvcmUsIHNlYXJjaDtcbiAgICAgICAgc2VhcmNoID0gdGhpcy5wcmVwYXJlU2VhcmNoKHF1ZXJ5LCBvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucyA9IHNlYXJjaC5vcHRpb25zO1xuICAgICAgICBxdWVyeSA9IHNlYXJjaC5xdWVyeTtcbiAgICAgICAgLy8gZ2VuZXJhdGUgcmVzdWx0IHNjb3JpbmcgZnVuY3Rpb25cbiAgICAgICAgY29uc3QgZm5fc2NvcmUgPSBvcHRpb25zLnNjb3JlIHx8IHNlbGYuX2dldFNjb3JlRnVuY3Rpb24oc2VhcmNoKTtcbiAgICAgICAgLy8gcGVyZm9ybSBzZWFyY2ggYW5kIHNvcnRcbiAgICAgICAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuICAgICAgICAgICAgaXRlcmF0ZShzZWxmLml0ZW1zLCAoaXRlbSwgaWQpID0+IHtcbiAgICAgICAgICAgICAgICBzY29yZSA9IGZuX3Njb3JlKGl0ZW0pO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmZpbHRlciA9PT0gZmFsc2UgfHwgc2NvcmUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaC5pdGVtcy5wdXNoKHsgJ3Njb3JlJzogc2NvcmUsICdpZCc6IGlkIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0ZShzZWxmLml0ZW1zLCAoXywgaWQpID0+IHtcbiAgICAgICAgICAgICAgICBzZWFyY2guaXRlbXMucHVzaCh7ICdzY29yZSc6IDEsICdpZCc6IGlkIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm5fc29ydCA9IHNlbGYuX2dldFNvcnRGdW5jdGlvbihzZWFyY2gpO1xuICAgICAgICBpZiAoZm5fc29ydClcbiAgICAgICAgICAgIHNlYXJjaC5pdGVtcy5zb3J0KGZuX3NvcnQpO1xuICAgICAgICAvLyBhcHBseSBsaW1pdHNcbiAgICAgICAgc2VhcmNoLnRvdGFsID0gc2VhcmNoLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxpbWl0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgc2VhcmNoLml0ZW1zID0gc2VhcmNoLml0ZW1zLnNsaWNlKDAsIG9wdGlvbnMubGltaXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWFyY2g7XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydCB7IFNpZnRlciwgc2NvcmVWYWx1ZSwgZ2V0QXR0ciwgZ2V0QXR0ck5lc3RpbmcsIHByb3BUb0FycmF5LCBpdGVyYXRlLCBjbXAsIGdldFBhdHRlcm4gfTtcbmV4cG9ydCAqIGZyb20gXCIuL3R5cGVzLmpzXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWZ0ZXIuanMubWFwIiwiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIiwiaW1wb3J0IHsgYXNjaWlmb2xkIH0gZnJvbSAnQG9yY2hpZGpzL3VuaWNvZGUtdmFyaWFudHMnO1xuLyoqXG4gKiBBIHByb3BlcnR5IGdldHRlciByZXNvbHZpbmcgZG90LW5vdGF0aW9uXG4gKiBAcGFyYW0gIHtPYmplY3R9ICBvYmogICAgIFRoZSByb290IG9iamVjdCB0byBmZXRjaCBwcm9wZXJ0eSBvblxuICogQHBhcmFtICB7U3RyaW5nfSAgbmFtZSAgICBUaGUgb3B0aW9uYWxseSBkb3R0ZWQgcHJvcGVydHkgbmFtZSB0byBmZXRjaFxuICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICBUaGUgcmVzb2x2ZWQgcHJvcGVydHkgdmFsdWVcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEF0dHIgPSAob2JqLCBuYW1lKSA9PiB7XG4gICAgaWYgKCFvYmopXG4gICAgICAgIHJldHVybjtcbiAgICByZXR1cm4gb2JqW25hbWVdO1xufTtcbi8qKlxuICogQSBwcm9wZXJ0eSBnZXR0ZXIgcmVzb2x2aW5nIGRvdC1ub3RhdGlvblxuICogQHBhcmFtICB7T2JqZWN0fSAgb2JqICAgICBUaGUgcm9vdCBvYmplY3QgdG8gZmV0Y2ggcHJvcGVydHkgb25cbiAqIEBwYXJhbSAge1N0cmluZ30gIG5hbWUgICAgVGhlIG9wdGlvbmFsbHkgZG90dGVkIHByb3BlcnR5IG5hbWUgdG8gZmV0Y2hcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgVGhlIHJlc29sdmVkIHByb3BlcnR5IHZhbHVlXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRBdHRyTmVzdGluZyA9IChvYmosIG5hbWUpID0+IHtcbiAgICBpZiAoIW9iailcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciBwYXJ0LCBuYW1lcyA9IG5hbWUuc3BsaXQoXCIuXCIpO1xuICAgIHdoaWxlICgocGFydCA9IG5hbWVzLnNoaWZ0KCkpICYmIChvYmogPSBvYmpbcGFydF0pKVxuICAgICAgICA7XG4gICAgcmV0dXJuIG9iajtcbn07XG4vKipcbiAqIENhbGN1bGF0ZXMgaG93IGNsb3NlIG9mIGEgbWF0Y2ggdGhlXG4gKiBnaXZlbiB2YWx1ZSBpcyBhZ2FpbnN0IGEgc2VhcmNoIHRva2VuLlxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IHNjb3JlVmFsdWUgPSAodmFsdWUsIHRva2VuLCB3ZWlnaHQpID0+IHtcbiAgICB2YXIgc2NvcmUsIHBvcztcbiAgICBpZiAoIXZhbHVlKVxuICAgICAgICByZXR1cm4gMDtcbiAgICB2YWx1ZSA9IHZhbHVlICsgJyc7XG4gICAgaWYgKHRva2VuLnJlZ2V4ID09IG51bGwpXG4gICAgICAgIHJldHVybiAwO1xuICAgIHBvcyA9IHZhbHVlLnNlYXJjaCh0b2tlbi5yZWdleCk7XG4gICAgaWYgKHBvcyA9PT0gLTEpXG4gICAgICAgIHJldHVybiAwO1xuICAgIHNjb3JlID0gdG9rZW4uc3RyaW5nLmxlbmd0aCAvIHZhbHVlLmxlbmd0aDtcbiAgICBpZiAocG9zID09PSAwKVxuICAgICAgICBzY29yZSArPSAwLjU7XG4gICAgcmV0dXJuIHNjb3JlICogd2VpZ2h0O1xufTtcbi8qKlxuICogQ2FzdCBvYmplY3QgcHJvcGVydHkgdG8gYW4gYXJyYXkgaWYgaXQgZXhpc3RzIGFuZCBoYXMgYSB2YWx1ZVxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IHByb3BUb0FycmF5ID0gKG9iaiwga2V5KSA9PiB7XG4gICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgaWYgKHZhbHVlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBvYmpba2V5XSA9IFt2YWx1ZV07XG4gICAgfVxufTtcbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBhcnJheXMgYW5kIGhhc2hlcy5cbiAqXG4gKiBgYGBcbiAqIGl0ZXJhdGUodGhpcy5pdGVtcywgZnVuY3Rpb24oaXRlbSwgaWQpIHtcbiAqICAgIC8vIGludm9rZWQgZm9yIGVhY2ggaXRlbVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBpdGVyYXRlID0gKG9iamVjdCwgY2FsbGJhY2spID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIG9iamVjdC5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG9iamVjdFtrZXldLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBjbXAgPSAoYSwgYikgPT4ge1xuICAgIGlmICh0eXBlb2YgYSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGIgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBhID4gYiA/IDEgOiAoYSA8IGIgPyAtMSA6IDApO1xuICAgIH1cbiAgICBhID0gYXNjaWlmb2xkKGEgKyAnJykudG9Mb3dlckNhc2UoKTtcbiAgICBiID0gYXNjaWlmb2xkKGIgKyAnJykudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoYSA+IGIpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmIChiID4gYSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIHJldHVybiAwO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsImltcG9ydCB7IHNldFRvUGF0dGVybiwgYXJyYXlUb1BhdHRlcm4sIGVzY2FwZV9yZWdleCwgc2VxdWVuY2VQYXR0ZXJuIH0gZnJvbSBcIi4vcmVnZXguanNcIjtcbmltcG9ydCB7IGFsbFN1YnN0cmluZ3MgfSBmcm9tIFwiLi9zdHJpbmdzLmpzXCI7XG5leHBvcnQgY29uc3QgY29kZV9wb2ludHMgPSBbWzAsIDY1NTM1XV07XG5jb25zdCBhY2NlbnRfcGF0ID0gJ1tcXHUwMzAwLVxcdTAzNkZcXHV7Yjd9XFx1ezJiZX1cXHV7MmJjfV0nO1xuZXhwb3J0IGxldCB1bmljb2RlX21hcDtcbmxldCBtdWx0aV9jaGFyX3JlZztcbmNvbnN0IG1heF9jaGFyX2xlbmd0aCA9IDM7XG5jb25zdCBsYXRpbl9jb252ZXJ0ID0ge307XG5jb25zdCBsYXRpbl9jb25kZW5zZWQgPSB7XG4gICAgJy8nOiAn4oGE4oiVJyxcbiAgICAnMCc6ICffgCcsXG4gICAgXCJhXCI6IFwi4rGlyZDJkVwiLFxuICAgIFwiYWFcIjogXCLqnLNcIixcbiAgICBcImFlXCI6IFwiw6bHvcejXCIsXG4gICAgXCJhb1wiOiBcIuqctVwiLFxuICAgIFwiYXVcIjogXCLqnLdcIixcbiAgICBcImF2XCI6IFwi6py56py7XCIsXG4gICAgXCJheVwiOiBcIuqcvVwiLFxuICAgIFwiYlwiOiBcIsaAyZPGg1wiLFxuICAgIFwiY1wiOiBcIuqcv8aIyLzihoRcIixcbiAgICBcImRcIjogXCLEkcmXyZbhtIXGjOqut9SByaZcIixcbiAgICBcImVcIjogXCLJm8ed4bSHyYdcIixcbiAgICBcImZcIjogXCLqnbzGklwiLFxuICAgIFwiZ1wiOiBcIselyaDqnqHhtbnqnb/JolwiLFxuICAgIFwiaFwiOiBcIsSn4rGo4rG2yaVcIixcbiAgICBcImlcIjogXCLJqMSxXCIsXG4gICAgXCJqXCI6IFwiyYnIt1wiLFxuICAgIFwia1wiOiBcIsaZ4rGq6p2B6p2D6p2F6p6jXCIsXG4gICAgXCJsXCI6IFwixYLGmsmr4rGh6p2J6p2H6p6Bya1cIixcbiAgICBcIm1cIjogXCLJscmvz7tcIixcbiAgICBcIm5cIjogXCLqnqXGnsmy6p6R4bSO0LvUiVwiLFxuICAgIFwib1wiOiBcIsO4x7/JlMm16p2L6p2N4bSRXCIsXG4gICAgXCJvZVwiOiBcIsWTXCIsXG4gICAgXCJvaVwiOiBcIsajXCIsXG4gICAgXCJvb1wiOiBcIuqdj1wiLFxuICAgIFwib3VcIjogXCLIo1wiLFxuICAgIFwicFwiOiBcIsal4bW96p2R6p2T6p2Vz4FcIixcbiAgICBcInFcIjogXCLqnZfqnZnJi1wiLFxuICAgIFwiclwiOiBcIsmNyb3qnZvqnqfqnoNcIixcbiAgICBcInNcIjogXCLDn8i/6p6p6p6FyoJcIixcbiAgICBcInRcIjogXCLFp8atyojisabqnodcIixcbiAgICBcInRoXCI6IFwiw75cIixcbiAgICBcInR6XCI6IFwi6pypXCIsXG4gICAgXCJ1XCI6IFwiyolcIixcbiAgICBcInZcIjogXCLKi+qdn8qMXCIsXG4gICAgXCJ2eVwiOiBcIuqdoVwiLFxuICAgIFwid1wiOiBcIuKxs1wiLFxuICAgIFwieVwiOiBcIsa0yY/hu79cIixcbiAgICBcInpcIjogXCLGtsilyYDisazqnaNcIixcbiAgICBcImh2XCI6IFwixpVcIlxufTtcbmZvciAobGV0IGxhdGluIGluIGxhdGluX2NvbmRlbnNlZCkge1xuICAgIGxldCB1bmljb2RlID0gbGF0aW5fY29uZGVuc2VkW2xhdGluXSB8fCAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVuaWNvZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGNoYXIgPSB1bmljb2RlLnN1YnN0cmluZyhpLCBpICsgMSk7XG4gICAgICAgIGxhdGluX2NvbnZlcnRbY2hhcl0gPSBsYXRpbjtcbiAgICB9XG59XG5jb25zdCBjb252ZXJ0X3BhdCA9IG5ldyBSZWdFeHAoT2JqZWN0LmtleXMobGF0aW5fY29udmVydCkuam9pbignfCcpICsgJ3wnICsgYWNjZW50X3BhdCwgJ2d1Jyk7XG4vKipcbiAqIEluaXRpYWxpemUgdGhlIHVuaWNvZGVfbWFwIGZyb20gdGhlIGdpdmUgY29kZSBwb2ludCByYW5nZXNcbiAqL1xuZXhwb3J0IGNvbnN0IGluaXRpYWxpemUgPSAoX2NvZGVfcG9pbnRzKSA9PiB7XG4gICAgaWYgKHVuaWNvZGVfbWFwICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICB1bmljb2RlX21hcCA9IGdlbmVyYXRlTWFwKF9jb2RlX3BvaW50cyB8fCBjb2RlX3BvaW50cyk7XG59O1xuLyoqXG4gKiBIZWxwZXIgbWV0aG9kIGZvciBub3JtYWxpemUgYSBzdHJpbmdcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9ub3JtYWxpemVcbiAqL1xuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZSA9IChzdHIsIGZvcm0gPSAnTkZLRCcpID0+IHN0ci5ub3JtYWxpemUoZm9ybSk7XG4vKipcbiAqIFJlbW92ZSBhY2NlbnRzIHdpdGhvdXQgcmVvcmRlcmluZyBzdHJpbmdcbiAqIGNhbGxpbmcgc3RyLm5vcm1hbGl6ZSgnTkZLRCcpIG9uIFxcdXs1OTR9XFx1ezU5NX1cXHV7NTk2fSBiZWNvbWVzIFxcdXs1OTZ9XFx1ezU5NH1cXHV7NTk1fVxuICogdmlhIGh0dHBzOi8vZ2l0aHViLmNvbS9rcmlzay9GdXNlL2lzc3Vlcy8xMzMjaXNzdWVjb21tZW50LTMxODY5MjcwM1xuICovXG5leHBvcnQgY29uc3QgYXNjaWlmb2xkID0gKHN0cikgPT4ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHN0cikucmVkdWNlKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXN1bHRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhclxuICAgICAqL1xuICAgIChyZXN1bHQsIGNoYXIpID0+IHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIF9hc2NpaWZvbGQoY2hhcik7XG4gICAgfSwgJycpO1xufTtcbmV4cG9ydCBjb25zdCBfYXNjaWlmb2xkID0gKHN0cikgPT4ge1xuICAgIHN0ciA9IG5vcm1hbGl6ZShzdHIpXG4gICAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAgIC5yZXBsYWNlKGNvbnZlcnRfcGF0LCAoLyoqIEB0eXBlIHtzdHJpbmd9ICovIGNoYXIpID0+IHtcbiAgICAgICAgcmV0dXJuIGxhdGluX2NvbnZlcnRbY2hhcl0gfHwgJyc7XG4gICAgfSk7XG4gICAgLy9yZXR1cm4gc3RyO1xuICAgIHJldHVybiBub3JtYWxpemUoc3RyLCAnTkZDJyk7XG59O1xuLyoqXG4gKiBHZW5lcmF0ZSBhIGxpc3Qgb2YgdW5pY29kZSB2YXJpYW50cyBmcm9tIHRoZSBsaXN0IG9mIGNvZGUgcG9pbnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiogZ2VuZXJhdG9yKGNvZGVfcG9pbnRzKSB7XG4gICAgZm9yIChjb25zdCBbY29kZV9wb2ludF9taW4sIGNvZGVfcG9pbnRfbWF4XSBvZiBjb2RlX3BvaW50cykge1xuICAgICAgICBmb3IgKGxldCBpID0gY29kZV9wb2ludF9taW47IGkgPD0gY29kZV9wb2ludF9tYXg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNvbXBvc2VkID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcbiAgICAgICAgICAgIGxldCBmb2xkZWQgPSBhc2NpaWZvbGQoY29tcG9zZWQpO1xuICAgICAgICAgICAgaWYgKGZvbGRlZCA9PSBjb21wb3NlZC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBza2lwIHdoZW4gZm9sZGVkIGlzIGEgc3RyaW5nIGxvbmdlciB0aGFuIDMgY2hhcmFjdGVycyBsb25nXG4gICAgICAgICAgICAvLyBiYyB0aGUgcmVzdWx0aW5nIHJlZ2V4IHBhdHRlcm5zIHdpbGwgYmUgbG9uZ1xuICAgICAgICAgICAgLy8gZWc6XG4gICAgICAgICAgICAvLyBmb2xkZWQg2LXZhNmJINin2YTZhNmHINi52YTZitmHINmI2LPZhNmFIGxlbmd0aCAxOCBjb2RlIHBvaW50IDY1MDE4XG4gICAgICAgICAgICAvLyBmb2xkZWQg2KzZhCDYrNmE2KfZhNmHIGxlbmd0aCA4IGNvZGUgcG9pbnQgNjUwMTlcbiAgICAgICAgICAgIGlmIChmb2xkZWQubGVuZ3RoID4gbWF4X2NoYXJfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9sZGVkLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCB7IGZvbGRlZDogZm9sZGVkLCBjb21wb3NlZDogY29tcG9zZWQsIGNvZGVfcG9pbnQ6IGkgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogR2VuZXJhdGUgYSB1bmljb2RlIG1hcCBmcm9tIHRoZSBsaXN0IG9mIGNvZGUgcG9pbnRzXG4gKi9cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZVNldHMgPSAoY29kZV9wb2ludHMpID0+IHtcbiAgICBjb25zdCB1bmljb2RlX3NldHMgPSB7fTtcbiAgICBjb25zdCBhZGRNYXRjaGluZyA9IChmb2xkZWQsIHRvX2FkZCkgPT4ge1xuICAgICAgICAvKiogQHR5cGUge1NldDxzdHJpbmc+fSAqL1xuICAgICAgICBjb25zdCBmb2xkZWRfc2V0ID0gdW5pY29kZV9zZXRzW2ZvbGRlZF0gfHwgbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBwYXR0ID0gbmV3IFJlZ0V4cCgnXicgKyBzZXRUb1BhdHRlcm4oZm9sZGVkX3NldCkgKyAnJCcsICdpdScpO1xuICAgICAgICBpZiAodG9fYWRkLm1hdGNoKHBhdHQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9sZGVkX3NldC5hZGQoZXNjYXBlX3JlZ2V4KHRvX2FkZCkpO1xuICAgICAgICB1bmljb2RlX3NldHNbZm9sZGVkXSA9IGZvbGRlZF9zZXQ7XG4gICAgfTtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiBnZW5lcmF0b3IoY29kZV9wb2ludHMpKSB7XG4gICAgICAgIGFkZE1hdGNoaW5nKHZhbHVlLmZvbGRlZCwgdmFsdWUuZm9sZGVkKTtcbiAgICAgICAgYWRkTWF0Y2hpbmcodmFsdWUuZm9sZGVkLCB2YWx1ZS5jb21wb3NlZCk7XG4gICAgfVxuICAgIHJldHVybiB1bmljb2RlX3NldHM7XG59O1xuLyoqXG4gKiBHZW5lcmF0ZSBhIHVuaWNvZGUgbWFwIGZyb20gdGhlIGxpc3Qgb2YgY29kZSBwb2ludHNcbiAqIGFlID0+ICg/Oig/OmFlfMOGfMe8fMeiKXwoPzpBfOKStnzvvKEuLi4pKD86RXzJm3zikrouLi4pKVxuICovXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVNYXAgPSAoY29kZV9wb2ludHMpID0+IHtcbiAgICBjb25zdCB1bmljb2RlX3NldHMgPSBnZW5lcmF0ZVNldHMoY29kZV9wb2ludHMpO1xuICAgIGNvbnN0IHVuaWNvZGVfbWFwID0ge307XG4gICAgbGV0IG11bHRpX2NoYXIgPSBbXTtcbiAgICBmb3IgKGxldCBmb2xkZWQgaW4gdW5pY29kZV9zZXRzKSB7XG4gICAgICAgIGxldCBzZXQgPSB1bmljb2RlX3NldHNbZm9sZGVkXTtcbiAgICAgICAgaWYgKHNldCkge1xuICAgICAgICAgICAgdW5pY29kZV9tYXBbZm9sZGVkXSA9IHNldFRvUGF0dGVybihzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb2xkZWQubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbXVsdGlfY2hhci5wdXNoKGVzY2FwZV9yZWdleChmb2xkZWQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtdWx0aV9jaGFyLnNvcnQoKGEsIGIpID0+IGIubGVuZ3RoIC0gYS5sZW5ndGgpO1xuICAgIGNvbnN0IG11bHRpX2NoYXJfcGF0dCA9IGFycmF5VG9QYXR0ZXJuKG11bHRpX2NoYXIpO1xuICAgIG11bHRpX2NoYXJfcmVnID0gbmV3IFJlZ0V4cCgnXicgKyBtdWx0aV9jaGFyX3BhdHQsICd1Jyk7XG4gICAgcmV0dXJuIHVuaWNvZGVfbWFwO1xufTtcbi8qKlxuICogTWFwIGVhY2ggZWxlbWVudCBvZiBhbiBhcnJheSBmcm9tIGl0cyBmb2xkZWQgdmFsdWUgdG8gYWxsIHBvc3NpYmxlIHVuaWNvZGUgbWF0Y2hlc1xuICovXG5leHBvcnQgY29uc3QgbWFwU2VxdWVuY2UgPSAoc3RyaW5ncywgbWluX3JlcGxhY2VtZW50ID0gMSkgPT4ge1xuICAgIGxldCBjaGFyc19yZXBsYWNlZCA9IDA7XG4gICAgc3RyaW5ncyA9IHN0cmluZ3MubWFwKChzdHIpID0+IHtcbiAgICAgICAgaWYgKHVuaWNvZGVfbWFwW3N0cl0pIHtcbiAgICAgICAgICAgIGNoYXJzX3JlcGxhY2VkICs9IHN0ci5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuaWNvZGVfbWFwW3N0cl0gfHwgc3RyO1xuICAgIH0pO1xuICAgIGlmIChjaGFyc19yZXBsYWNlZCA+PSBtaW5fcmVwbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHNlcXVlbmNlUGF0dGVybihzdHJpbmdzKTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufTtcbi8qKlxuICogQ29udmVydCBhIHNob3J0IHN0cmluZyBhbmQgc3BsaXQgaXQgaW50byBhbGwgcG9zc2libGUgcGF0dGVybnNcbiAqIEtlZXAgYSBwYXR0ZXJuIG9ubHkgaWYgbWluX3JlcGxhY2VtZW50IGlzIG1ldFxuICpcbiAqICdhYmMnXG4gKiBcdFx0PT4gW1snYWJjJ10sWydhYicsJ2MnXSxbJ2EnLCdiYyddLFsnYScsJ2InLCdjJ11dXG4gKlx0XHQ9PiBbJ2FiYy1wYXR0ZXJuJywnYWItYy1wYXR0ZXJuJy4uLl1cbiAqL1xuZXhwb3J0IGNvbnN0IHN1YnN0cmluZ3NUb1BhdHRlcm4gPSAoc3RyLCBtaW5fcmVwbGFjZW1lbnQgPSAxKSA9PiB7XG4gICAgbWluX3JlcGxhY2VtZW50ID0gTWF0aC5tYXgobWluX3JlcGxhY2VtZW50LCBzdHIubGVuZ3RoIC0gMSk7XG4gICAgcmV0dXJuIGFycmF5VG9QYXR0ZXJuKGFsbFN1YnN0cmluZ3Moc3RyKS5tYXAoKHN1Yl9wYXQpID0+IHtcbiAgICAgICAgcmV0dXJuIG1hcFNlcXVlbmNlKHN1Yl9wYXQsIG1pbl9yZXBsYWNlbWVudCk7XG4gICAgfSkpO1xufTtcbi8qKlxuICogQ29udmVydCBhbiBhcnJheSBvZiBzZXF1ZW5jZXMgaW50byBhIHBhdHRlcm5cbiAqIFt7c3RhcnQ6MCxlbmQ6MyxsZW5ndGg6MyxzdWJzdHI6J2lpaSd9Li4uXSA9PiAoPzppaWkuLi4pXG4gKi9cbmNvbnN0IHNlcXVlbmNlc1RvUGF0dGVybiA9IChzZXF1ZW5jZXMsIGFsbCA9IHRydWUpID0+IHtcbiAgICBsZXQgbWluX3JlcGxhY2VtZW50ID0gc2VxdWVuY2VzLmxlbmd0aCA+IDEgPyAxIDogMDtcbiAgICByZXR1cm4gYXJyYXlUb1BhdHRlcm4oc2VxdWVuY2VzLm1hcCgoc2VxdWVuY2UpID0+IHtcbiAgICAgICAgbGV0IHNlcSA9IFtdO1xuICAgICAgICBjb25zdCBsZW4gPSBhbGwgPyBzZXF1ZW5jZS5sZW5ndGgoKSA6IHNlcXVlbmNlLmxlbmd0aCgpIC0gMTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgc2VxLnB1c2goc3Vic3RyaW5nc1RvUGF0dGVybihzZXF1ZW5jZS5zdWJzdHJzW2pdIHx8ICcnLCBtaW5fcmVwbGFjZW1lbnQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VxdWVuY2VQYXR0ZXJuKHNlcSk7XG4gICAgfSkpO1xufTtcbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIHNlcXVlbmNlIGlzIGFscmVhZHkgaW4gdGhlIHNlcXVlbmNlc1xuICovXG5jb25zdCBpblNlcXVlbmNlcyA9IChuZWVkbGVfc2VxLCBzZXF1ZW5jZXMpID0+IHtcbiAgICBmb3IgKGNvbnN0IHNlcSBvZiBzZXF1ZW5jZXMpIHtcbiAgICAgICAgaWYgKHNlcS5zdGFydCAhPSBuZWVkbGVfc2VxLnN0YXJ0IHx8IHNlcS5lbmQgIT0gbmVlZGxlX3NlcS5lbmQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXEuc3Vic3Rycy5qb2luKCcnKSAhPT0gbmVlZGxlX3NlcS5zdWJzdHJzLmpvaW4oJycpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmVlZGxlX3BhcnRzID0gbmVlZGxlX3NlcS5wYXJ0cztcbiAgICAgICAgY29uc3QgZmlsdGVyID0gKHBhcnQpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmVlZGxlX3BhcnQgb2YgbmVlZGxlX3BhcnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5lZWRsZV9wYXJ0LnN0YXJ0ID09PSBwYXJ0LnN0YXJ0ICYmIG5lZWRsZV9wYXJ0LnN1YnN0ciA9PT0gcGFydC5zdWJzdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFydC5sZW5ndGggPT0gMSB8fCBuZWVkbGVfcGFydC5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIG92ZXJsYXBwaW5nIHBhcnRzXG4gICAgICAgICAgICAgICAgLy8gYSA9IFsnOjo9JywnPT0nXVxuICAgICAgICAgICAgICAgIC8vIGIgPSBbJzo6JywnPT09J11cbiAgICAgICAgICAgICAgICAvLyBhID0gWydyJywnc20nXVxuICAgICAgICAgICAgICAgIC8vIGIgPSBbJ3JzJywnbSddXG4gICAgICAgICAgICAgICAgaWYgKHBhcnQuc3RhcnQgPCBuZWVkbGVfcGFydC5zdGFydCAmJiBwYXJ0LmVuZCA+IG5lZWRsZV9wYXJ0LnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmVlZGxlX3BhcnQuc3RhcnQgPCBwYXJ0LnN0YXJ0ICYmIG5lZWRsZV9wYXJ0LmVuZCA+IHBhcnQuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgZmlsdGVyZWQgPSBzZXEucGFydHMuZmlsdGVyKGZpbHRlcik7XG4gICAgICAgIGlmIChmaWx0ZXJlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmNsYXNzIFNlcXVlbmNlIHtcbiAgICBwYXJ0cztcbiAgICBzdWJzdHJzO1xuICAgIHN0YXJ0O1xuICAgIGVuZDtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wYXJ0cyA9IFtdO1xuICAgICAgICB0aGlzLnN1YnN0cnMgPSBbXTtcbiAgICAgICAgdGhpcy5zdGFydCA9IDA7XG4gICAgICAgIHRoaXMuZW5kID0gMDtcbiAgICB9XG4gICAgYWRkKHBhcnQpIHtcbiAgICAgICAgaWYgKHBhcnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgICAgIHRoaXMuc3Vic3Rycy5wdXNoKHBhcnQuc3Vic3RyKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSBNYXRoLm1pbihwYXJ0LnN0YXJ0LCB0aGlzLnN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gTWF0aC5tYXgocGFydC5lbmQsIHRoaXMuZW5kKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsYXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJ0c1t0aGlzLnBhcnRzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnRzLmxlbmd0aDtcbiAgICB9XG4gICAgY2xvbmUocG9zaXRpb24sIGxhc3RfcGllY2UpIHtcbiAgICAgICAgbGV0IGNsb25lID0gbmV3IFNlcXVlbmNlKCk7XG4gICAgICAgIGxldCBwYXJ0cyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5wYXJ0cykpO1xuICAgICAgICBsZXQgbGFzdF9wYXJ0ID0gcGFydHMucG9wKCk7XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICAgICAgY2xvbmUuYWRkKHBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsYXN0X3N1YnN0ciA9IGxhc3RfcGllY2Uuc3Vic3RyLnN1YnN0cmluZygwLCBwb3NpdGlvbiAtIGxhc3RfcGFydC5zdGFydCk7XG4gICAgICAgIGxldCBjbG9uZV9sYXN0X2xlbiA9IGxhc3Rfc3Vic3RyLmxlbmd0aDtcbiAgICAgICAgY2xvbmUuYWRkKHsgc3RhcnQ6IGxhc3RfcGFydC5zdGFydCwgZW5kOiBsYXN0X3BhcnQuc3RhcnQgKyBjbG9uZV9sYXN0X2xlbiwgbGVuZ3RoOiBjbG9uZV9sYXN0X2xlbiwgc3Vic3RyOiBsYXN0X3N1YnN0ciB9KTtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cbn1cbi8qKlxuICogRXhwYW5kIGEgcmVndWxhciBleHByZXNzaW9uIHBhdHRlcm4gdG8gaW5jbHVkZSB1bmljb2RlIHZhcmlhbnRzXG4gKiBcdGVnIC9hLyBiZWNvbWVzIC9h4pOQ772B4bqaw6DDocOi4bqn4bql4bqr4bqpw6PEgcSD4bqx4bqv4bq14bqzyKfHocOkx5/huqPDpce7x47IgciD4bqh4bqt4bq34biBxIXisaXJkMmRQeKStu+8ocOAw4HDguG6puG6pOG6quG6qMODxIDEguG6sOG6ruG6tOG6ssimx6DDhMee4bqiw4XHuseNyIDIguG6oOG6rOG6tuG4gMSEyLrisa8vXG4gKlxuICogSXNzdWU6XG4gKiAg77qK77qLIFsgJ++6iiA9IFxcXFx1e2ZlOGF9JywgJ++6iyA9IFxcXFx1e2ZlOGJ9JyBdXG4gKlx0YmVjb21lczpcdNmK2ZTZitmUIFsgJ9mKID0gXFxcXHV7NjRhfScsICfZlCA9IFxcXFx1ezY1NH0nLCAn2YogPSBcXFxcdXs2NGF9JywgJ9mUID0gXFxcXHV7NjU0fScgXVxuICpcbiAqXHTEsMSyID0gSUlKID0g4oWhSlxuICpcbiAqIFx0MS8yLzRcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFBhdHRlcm4gPSAoc3RyKSA9PiB7XG4gICAgaW5pdGlhbGl6ZSgpO1xuICAgIHN0ciA9IGFzY2lpZm9sZChzdHIpO1xuICAgIGxldCBwYXR0ZXJuID0gJyc7XG4gICAgbGV0IHNlcXVlbmNlcyA9IFtuZXcgU2VxdWVuY2UoKV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHN1YnN0ciA9IHN0ci5zdWJzdHJpbmcoaSk7XG4gICAgICAgIGxldCBtYXRjaCA9IHN1YnN0ci5tYXRjaChtdWx0aV9jaGFyX3JlZyk7XG4gICAgICAgIGNvbnN0IGNoYXIgPSBzdHIuc3Vic3RyaW5nKGksIGkgKyAxKTtcbiAgICAgICAgY29uc3QgbWF0Y2hfc3RyID0gbWF0Y2ggPyBtYXRjaFswXSA6IG51bGw7XG4gICAgICAgIC8vIGxvb3AgdGhyb3VnaCBzZXF1ZW5jZXNcbiAgICAgICAgLy8gYWRkIGVpdGhlciB0aGUgY2hhciBvciBtdWx0aV9tYXRjaFxuICAgICAgICBsZXQgb3ZlcmxhcHBpbmcgPSBbXTtcbiAgICAgICAgbGV0IGFkZGVkX3R5cGVzID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IHNlcXVlbmNlIG9mIHNlcXVlbmNlcykge1xuICAgICAgICAgICAgY29uc3QgbGFzdF9waWVjZSA9IHNlcXVlbmNlLmxhc3QoKTtcbiAgICAgICAgICAgIGlmICghbGFzdF9waWVjZSB8fCBsYXN0X3BpZWNlLmxlbmd0aCA9PSAxIHx8IGxhc3RfcGllY2UuZW5kIDw9IGkpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgbXVsdGkgbWF0Y2hcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hfc3RyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlbiA9IG1hdGNoX3N0ci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHNlcXVlbmNlLmFkZCh7IHN0YXJ0OiBpLCBlbmQ6IGkgKyBsZW4sIGxlbmd0aDogbGVuLCBzdWJzdHI6IG1hdGNoX3N0ciB9KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkZWRfdHlwZXMuYWRkKCcxJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXF1ZW5jZS5hZGQoeyBzdGFydDogaSwgZW5kOiBpICsgMSwgbGVuZ3RoOiAxLCBzdWJzdHI6IGNoYXIgfSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZGVkX3R5cGVzLmFkZCgnMicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoX3N0cikge1xuICAgICAgICAgICAgICAgIGxldCBjbG9uZSA9IHNlcXVlbmNlLmNsb25lKGksIGxhc3RfcGllY2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbiA9IG1hdGNoX3N0ci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY2xvbmUuYWRkKHsgc3RhcnQ6IGksIGVuZDogaSArIGxlbiwgbGVuZ3RoOiBsZW4sIHN1YnN0cjogbWF0Y2hfc3RyIH0pO1xuICAgICAgICAgICAgICAgIG92ZXJsYXBwaW5nLnB1c2goY2xvbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgYWRkIGNoYXJcbiAgICAgICAgICAgICAgICAvLyBhZGRpbmcgd291bGQgY3JlYXRlIGludmFsaWQgcGF0dGVybnM6IDIzNCA9PiBbMiwzNCw0XVxuICAgICAgICAgICAgICAgIGFkZGVkX3R5cGVzLmFkZCgnMycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlIGhhdmUgb3ZlcmxhcHBpbmdcbiAgICAgICAgaWYgKG92ZXJsYXBwaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIFsnaWknLCdpaWknXSBiZWZvcmUgWydpJywnaScsJ2lpaSddXG4gICAgICAgICAgICBvdmVybGFwcGluZyA9IG92ZXJsYXBwaW5nLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5sZW5ndGgoKSAtIGIubGVuZ3RoKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvciAobGV0IGNsb25lIG9mIG92ZXJsYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgYWRkIGlmIHdlIGFscmVhZHkgaGF2ZSBhbiBlcXVpdmFsZW50IHNlcXVlbmNlXG4gICAgICAgICAgICAgICAgaWYgKGluU2VxdWVuY2VzKGNsb25lLCBzZXF1ZW5jZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXF1ZW5jZXMucHVzaChjbG9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3ZSBoYXZlbid0IGRvbmUgYW55dGhpbmcgdW5pcXVlXG4gICAgICAgIC8vIGNsZWFuIHVwIHRoZSBwYXR0ZXJuc1xuICAgICAgICAvLyBoZWxwcyBrZWVwIHBhdHRlcm5zIHNtYWxsZXJcbiAgICAgICAgLy8gaWYgc3RyID0gJ3LigqjjjqdhYXJzcycsIHBhdHRlcm4gd2lsbCBiZSA0NDYgaW5zdGVhZCBvZiA2NTVcbiAgICAgICAgaWYgKGkgPiAwICYmIGFkZGVkX3R5cGVzLnNpemUgPT0gMSAmJiAhYWRkZWRfdHlwZXMuaGFzKCczJykpIHtcbiAgICAgICAgICAgIHBhdHRlcm4gKz0gc2VxdWVuY2VzVG9QYXR0ZXJuKHNlcXVlbmNlcywgZmFsc2UpO1xuICAgICAgICAgICAgbGV0IG5ld19zZXEgPSBuZXcgU2VxdWVuY2UoKTtcbiAgICAgICAgICAgIGNvbnN0IG9sZF9zZXEgPSBzZXF1ZW5jZXNbMF07XG4gICAgICAgICAgICBpZiAob2xkX3NlcSkge1xuICAgICAgICAgICAgICAgIG5ld19zZXEuYWRkKG9sZF9zZXEubGFzdCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlcXVlbmNlcyA9IFtuZXdfc2VxXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXR0ZXJuICs9IHNlcXVlbmNlc1RvUGF0dGVybihzZXF1ZW5jZXMsIHRydWUpO1xuICAgIHJldHVybiBwYXR0ZXJuO1xufTtcbmV4cG9ydCB7IGVzY2FwZV9yZWdleCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIHN0cmluZ3MgdG8gYSByZWd1bGFyIGV4cHJlc3Npb25cbiAqXHRleCBbJ2FiJywnYSddID0+ICg/OmFifGEpXG4gKiBcdGV4IFsnYScsJ2InXSA9PiBbYWJdXG4gKi9cbmV4cG9ydCBjb25zdCBhcnJheVRvUGF0dGVybiA9IChjaGFycykgPT4ge1xuICAgIGNoYXJzID0gY2hhcnMuZmlsdGVyKEJvb2xlYW4pO1xuICAgIGlmIChjaGFycy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBjaGFyc1swXSB8fCAnJztcbiAgICB9XG4gICAgcmV0dXJuIChtYXhWYWx1ZUxlbmd0aChjaGFycykgPT0gMSkgPyAnWycgKyBjaGFycy5qb2luKCcnKSArICddJyA6ICcoPzonICsgY2hhcnMuam9pbignfCcpICsgJyknO1xufTtcbmV4cG9ydCBjb25zdCBzZXF1ZW5jZVBhdHRlcm4gPSAoYXJyYXkpID0+IHtcbiAgICBpZiAoIWhhc0R1cGxpY2F0ZXMoYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiBhcnJheS5qb2luKCcnKTtcbiAgICB9XG4gICAgbGV0IHBhdHRlcm4gPSAnJztcbiAgICBsZXQgcHJldl9jaGFyX2NvdW50ID0gMDtcbiAgICBjb25zdCBwcmV2X3BhdHRlcm4gPSAoKSA9PiB7XG4gICAgICAgIGlmIChwcmV2X2NoYXJfY291bnQgPiAxKSB7XG4gICAgICAgICAgICBwYXR0ZXJuICs9ICd7JyArIHByZXZfY2hhcl9jb3VudCArICd9JztcbiAgICAgICAgfVxuICAgIH07XG4gICAgYXJyYXkuZm9yRWFjaCgoY2hhciwgaSkgPT4ge1xuICAgICAgICBpZiAoY2hhciA9PT0gYXJyYXlbaSAtIDFdKSB7XG4gICAgICAgICAgICBwcmV2X2NoYXJfY291bnQrKztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcmV2X3BhdHRlcm4oKTtcbiAgICAgICAgcGF0dGVybiArPSBjaGFyO1xuICAgICAgICBwcmV2X2NoYXJfY291bnQgPSAxO1xuICAgIH0pO1xuICAgIHByZXZfcGF0dGVybigpO1xuICAgIHJldHVybiBwYXR0ZXJuO1xufTtcbi8qKlxuICogQ29udmVydCBhcnJheSBvZiBzdHJpbmdzIHRvIGEgcmVndWxhciBleHByZXNzaW9uXG4gKlx0ZXggWydhYicsJ2EnXSA9PiAoPzphYnxhKVxuICogXHRleCBbJ2EnLCdiJ10gPT4gW2FiXVxuICovXG5leHBvcnQgY29uc3Qgc2V0VG9QYXR0ZXJuID0gKGNoYXJzKSA9PiB7XG4gICAgbGV0IGFycmF5ID0gQXJyYXkuZnJvbShjaGFycyk7XG4gICAgcmV0dXJuIGFycmF5VG9QYXR0ZXJuKGFycmF5KTtcbn07XG4vKipcbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzczNzY1OTgvaW4tamF2YXNjcmlwdC1ob3ctZG8taS1jaGVjay1pZi1hbi1hcnJheS1oYXMtZHVwbGljYXRlLXZhbHVlc1xuICovXG5leHBvcnQgY29uc3QgaGFzRHVwbGljYXRlcyA9IChhcnJheSkgPT4ge1xuICAgIHJldHVybiAobmV3IFNldChhcnJheSkpLnNpemUgIT09IGFycmF5Lmxlbmd0aDtcbn07XG4vKipcbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzYzMDA2NjAxL3doeS1kb2VzLXUtdGhyb3ctYW4taW52YWxpZC1lc2NhcGUtZXJyb3JcbiAqL1xuZXhwb3J0IGNvbnN0IGVzY2FwZV9yZWdleCA9IChzdHIpID0+IHtcbiAgICByZXR1cm4gKHN0ciArICcnKS5yZXBsYWNlKC8oW1xcJFxcKFxcKVxcKlxcK1xcLlxcP1xcW1xcXVxcXlxce1xcfFxcfVxcXFxdKS9ndSwgJ1xcXFwkMScpO1xufTtcbi8qKlxuICogUmV0dXJuIHRoZSBtYXggbGVuZ3RoIG9mIGFycmF5IHZhbHVlc1xuICovXG5leHBvcnQgY29uc3QgbWF4VmFsdWVMZW5ndGggPSAoYXJyYXkpID0+IHtcbiAgICByZXR1cm4gYXJyYXkucmVkdWNlKChsb25nZXN0LCB2YWx1ZSkgPT4gTWF0aC5tYXgobG9uZ2VzdCwgdW5pY29kZUxlbmd0aCh2YWx1ZSkpLCAwKTtcbn07XG5leHBvcnQgY29uc3QgdW5pY29kZUxlbmd0aCA9IChzdHIpID0+IHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShzdHIpLmxlbmd0aDtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWdleC5qcy5tYXAiLCIvKipcbiAqIEdldCBhbGwgcG9zc2libGUgY29tYmluYXRpb25zIG9mIHN1YnN0cmluZ3MgdGhhdCBhZGQgdXAgdG8gdGhlIGdpdmVuIHN0cmluZ1xuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzAxNjk1ODcvZmluZC1hbGwtdGhlLWNvbWJpbmF0aW9uLW9mLXN1YnN0cmluZ3MtdGhhdC1hZGQtdXAtdG8tdGhlLWdpdmVuLXN0cmluZ1xuICovXG5leHBvcnQgY29uc3QgYWxsU3Vic3RyaW5ncyA9IChpbnB1dCkgPT4ge1xuICAgIGlmIChpbnB1dC5sZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybiBbW2lucHV0XV07XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IHN0YXJ0ID0gaW5wdXQuc3Vic3RyaW5nKDEpO1xuICAgIGNvbnN0IHN1YmEgPSBhbGxTdWJzdHJpbmdzKHN0YXJ0KTtcbiAgICBzdWJhLmZvckVhY2goZnVuY3Rpb24gKHN1YnJlc3VsdCkge1xuICAgICAgICBsZXQgdG1wID0gc3VicmVzdWx0LnNsaWNlKDApO1xuICAgICAgICB0bXBbMF0gPSBpbnB1dC5jaGFyQXQoMCkgKyB0bXBbMF07XG4gICAgICAgIHJlc3VsdC5wdXNoKHRtcCk7XG4gICAgICAgIHRtcCA9IHN1YnJlc3VsdC5zbGljZSgwKTtcbiAgICAgICAgdG1wLnVuc2hpZnQoaW5wdXQuY2hhckF0KDApKTtcbiAgICAgICAgcmVzdWx0LnB1c2godG1wKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmluZ3MuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgJGZpbmQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uJykuZmluZDtcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcycpO1xuXG52YXIgRklORCA9ICdmaW5kJztcbnZhciBTS0lQU19IT0xFUyA9IHRydWU7XG5cbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktcHJvdG90eXBlLWZpbmQgLS0gdGVzdGluZ1xuaWYgKEZJTkQgaW4gW10pIEFycmF5KDEpW0ZJTkRdKGZ1bmN0aW9uICgpIHsgU0tJUFNfSE9MRVMgPSBmYWxzZTsgfSk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZmluZGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBTS0lQU19IT0xFUyB9LCB7XG4gIGZpbmQ6IGZ1bmN0aW9uIGZpbmQoY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICByZXR1cm4gJGZpbmQodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuYWRkVG9VbnNjb3BhYmxlcyhGSU5EKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvbGxlY3Rpb24nKTtcbnZhciBjb2xsZWN0aW9uV2VhayA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jb2xsZWN0aW9uLXdlYWsnKTtcblxuLy8gYFdlYWtTZXRgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXdlYWtzZXQtY29uc3RydWN0b3JcbmNvbGxlY3Rpb24oJ1dlYWtTZXQnLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gV2Vha1NldCgpIHsgcmV0dXJuIGluaXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCBjb2xsZWN0aW9uV2Vhayk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBUT0RPOiBSZW1vdmUgdGhpcyBtb2R1bGUgZnJvbSBgY29yZS1qc0A0YCBzaW5jZSBpdCdzIHJlcGxhY2VkIHRvIG1vZHVsZSBiZWxvd1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy53ZWFrLXNldC5jb25zdHJ1Y3RvcicpO1xuIiwiZXhwb3J0IGNvbnN0IEtFWV9BID0gNjU7XG5leHBvcnQgY29uc3QgS0VZX1JFVFVSTiA9IDEzO1xuZXhwb3J0IGNvbnN0IEtFWV9FU0MgPSAyNztcbmV4cG9ydCBjb25zdCBLRVlfTEVGVCA9IDM3O1xuZXhwb3J0IGNvbnN0IEtFWV9VUCA9IDM4O1xuZXhwb3J0IGNvbnN0IEtFWV9SSUdIVCA9IDM5O1xuZXhwb3J0IGNvbnN0IEtFWV9ET1dOID0gNDA7XG5leHBvcnQgY29uc3QgS0VZX0JBQ0tTUEFDRSA9IDg7XG5leHBvcnQgY29uc3QgS0VZX0RFTEVURSA9IDQ2O1xuZXhwb3J0IGNvbnN0IEtFWV9UQUIgPSA5O1xuZXhwb3J0IGNvbnN0IElTX01BQyA9IHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnID8gZmFsc2UgOiAvTWFjLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuZXhwb3J0IGNvbnN0IEtFWV9TSE9SVENVVCA9IElTX01BQyA/ICdtZXRhS2V5JyA6ICdjdHJsS2V5JzsgLy8gY3RybCBrZXkgb3IgYXBwbGUga2V5IGZvciBtYVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCIsIi8qKlxuICogaGlnaGxpZ2h0IHYzIHwgTUlUIGxpY2Vuc2UgfCBKb2hhbm4gQnVya2FyZCA8amJAZWFpby5jb20+XG4gKiBIaWdobGlnaHRzIGFyYml0cmFyeSB0ZXJtcyBpbiBhIG5vZGUuXG4gKlxuICogLSBNb2RpZmllZCBieSBNYXJzaGFsIDxiZWF0Z2F0ZXNAZ21haWwuY29tPiAyMDExLTYtMjQgKGFkZGVkIHJlZ2V4KVxuICogLSBNb2RpZmllZCBieSBCcmlhbiBSZWF2aXMgPGJyaWFuQHRoaXJkcm91dGUuY29tPiAyMDEyLTgtMjcgKGNsZWFudXApXG4gKi9cbmltcG9ydCB7IHJlcGxhY2VOb2RlIH0gZnJvbSBcIi4uL3ZhbmlsbGEuanNcIjtcbmV4cG9ydCBjb25zdCBoaWdobGlnaHQgPSAoZWxlbWVudCwgcmVnZXgpID0+IHtcbiAgICBpZiAocmVnZXggPT09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBjb252ZXQgc3RyaW5nIHRvIHJlZ2V4XG4gICAgaWYgKHR5cGVvZiByZWdleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKCFyZWdleC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChyZWdleCwgJ2knKTtcbiAgICB9XG4gICAgLy8gV3JhcCBtYXRjaGluZyBwYXJ0IG9mIHRleHQgbm9kZSB3aXRoIGhpZ2hsaWdodGluZyA8c3Bhbj4sIGUuZy5cbiAgICAvLyBTb2NjZXIgIC0+ICA8c3BhbiBjbGFzcz1cImhpZ2hsaWdodFwiPlNvYzwvc3Bhbj5jZXIgIGZvciByZWdleCA9IC9zb2MvaVxuICAgIGNvbnN0IGhpZ2hsaWdodFRleHQgPSAobm9kZSkgPT4ge1xuICAgICAgICB2YXIgbWF0Y2ggPSBub2RlLmRhdGEubWF0Y2gocmVnZXgpO1xuICAgICAgICBpZiAobWF0Y2ggJiYgbm9kZS5kYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBzcGFubm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIHNwYW5ub2RlLmNsYXNzTmFtZSA9ICdoaWdobGlnaHQnO1xuICAgICAgICAgICAgdmFyIG1pZGRsZWJpdCA9IG5vZGUuc3BsaXRUZXh0KG1hdGNoLmluZGV4KTtcbiAgICAgICAgICAgIG1pZGRsZWJpdC5zcGxpdFRleHQobWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBtaWRkbGVjbG9uZSA9IG1pZGRsZWJpdC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICAgICBzcGFubm9kZS5hcHBlbmRDaGlsZChtaWRkbGVjbG9uZSk7XG4gICAgICAgICAgICByZXBsYWNlTm9kZShtaWRkbGViaXQsIHNwYW5ub2RlKTtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgLy8gUmVjdXJzZSBlbGVtZW50IG5vZGUsIGxvb2tpbmcgZm9yIGNoaWxkIHRleHQgbm9kZXMgdG8gaGlnaGxpZ2h0LCB1bmxlc3MgZWxlbWVudFxuICAgIC8vIGlzIGNoaWxkbGVzcywgPHNjcmlwdD4sIDxzdHlsZT4sIG9yIGFscmVhZHkgaGlnaGxpZ2h0ZWQ6IDxzcGFuIGNsYXNzPVwiaGlnaHRsaWdodFwiPlxuICAgIGNvbnN0IGhpZ2hsaWdodENoaWxkcmVuID0gKG5vZGUpID0+IHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgJiYgbm9kZS5jaGlsZE5vZGVzICYmICEvKHNjcmlwdHxzdHlsZSkvaS50ZXN0KG5vZGUudGFnTmFtZSkgJiYgKG5vZGUuY2xhc3NOYW1lICE9PSAnaGlnaGxpZ2h0JyB8fCBub2RlLnRhZ05hbWUgIT09ICdTUEFOJykpIHtcbiAgICAgICAgICAgIEFycmF5LmZyb20obm9kZS5jaGlsZE5vZGVzKS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgIGhpZ2hsaWdodFJlY3Vyc2l2ZShlbGVtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBoaWdobGlnaHRSZWN1cnNpdmUgPSAobm9kZSkgPT4ge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgICAgICAgcmV0dXJuIGhpZ2hsaWdodFRleHQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaGlnaGxpZ2h0Q2hpbGRyZW4obm9kZSk7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgaGlnaGxpZ2h0UmVjdXJzaXZlKGVsZW1lbnQpO1xufTtcbi8qKlxuICogcmVtb3ZlSGlnaGxpZ2h0IGZuIGNvcGllZCBmcm9tIGhpZ2hsaWdodCB2NSBhbmRcbiAqIGVkaXRlZCB0byByZW1vdmUgd2l0aCgpLCBwYXNzIGpzIHN0cmljdCBtb2RlLCBhbmQgdXNlIHdpdGhvdXQganF1ZXJ5XG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVIaWdobGlnaHQgPSAoZWwpID0+IHtcbiAgICB2YXIgZWxlbWVudHMgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKFwic3Bhbi5oaWdobGlnaHRcIik7XG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChlbGVtZW50cywgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKGVsLmZpcnN0Q2hpbGQsIGVsKTtcbiAgICAgICAgcGFyZW50Lm5vcm1hbGl6ZSgpO1xuICAgIH0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhpZ2hsaWdodC5qcy5tYXAiLCIvKipcbiAqIE1pY3JvRXZlbnQgLSB0byBtYWtlIGFueSBqcyBvYmplY3QgYW4gZXZlbnQgZW1pdHRlclxuICpcbiAqIC0gcHVyZSBqYXZhc2NyaXB0IC0gc2VydmVyIGNvbXBhdGlibGUsIGJyb3dzZXIgY29tcGF0aWJsZVxuICogLSBkb250IHJlbHkgb24gdGhlIGJyb3dzZXIgZG9tc1xuICogLSBzdXBlciBzaW1wbGUgLSB5b3UgZ2V0IGl0IGltbWVkaWF0bHksIG5vIG1pc3RlcnksIG5vIG1hZ2ljIGludm9sdmVkXG4gKlxuICogQGF1dGhvciBKZXJvbWUgRXRpZW5uZSAoaHR0cHM6Ly9naXRodWIuY29tL2plcm9tZWV0aWVubmUpXG4gKi9cbi8qKlxuICogRXhlY3V0ZSBjYWxsYmFjayBmb3IgZWFjaCBldmVudCBpbiBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBldmVudCBuYW1lc1xuICpcbiAqL1xuZnVuY3Rpb24gZm9yRXZlbnRzKGV2ZW50cywgY2FsbGJhY2spIHtcbiAgICBldmVudHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgICAgICBjYWxsYmFjayhldmVudCk7XG4gICAgfSk7XG59XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNaWNyb0V2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgfVxuICAgIG9uKGV2ZW50cywgZmN0KSB7XG4gICAgICAgIGZvckV2ZW50cyhldmVudHMsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRfYXJyYXkgPSB0aGlzLl9ldmVudHNbZXZlbnRdIHx8IFtdO1xuICAgICAgICAgICAgZXZlbnRfYXJyYXkucHVzaChmY3QpO1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50XSA9IGV2ZW50X2FycmF5O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgb2ZmKGV2ZW50cywgZmN0KSB7XG4gICAgICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvckV2ZW50cyhldmVudHMsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKG4gPT09IDEpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW2V2ZW50XTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBldmVudF9hcnJheSA9IHRoaXMuX2V2ZW50c1tldmVudF07XG4gICAgICAgICAgICBpZiAoZXZlbnRfYXJyYXkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBldmVudF9hcnJheS5zcGxpY2UoZXZlbnRfYXJyYXkuaW5kZXhPZihmY3QpLCAxKTtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50c1tldmVudF0gPSBldmVudF9hcnJheTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRyaWdnZXIoZXZlbnRzLCAuLi5hcmdzKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgZm9yRXZlbnRzKGV2ZW50cywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBldmVudF9hcnJheSA9IHNlbGYuX2V2ZW50c1tldmVudF07XG4gICAgICAgICAgICBpZiAoZXZlbnRfYXJyYXkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBldmVudF9hcnJheS5mb3JFYWNoKGZjdCA9PiB7XG4gICAgICAgICAgICAgICAgZmN0LmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pY3JvZXZlbnQuanMubWFwIiwiLyoqXG4gKiBtaWNyb3BsdWdpbi5qc1xuICogQ29weXJpZ2h0IChjKSAyMDEzIEJyaWFuIFJlYXZpcyAmIGNvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAYXV0aG9yIEJyaWFuIFJlYXZpcyA8YnJpYW5AdGhpcmRyb3V0ZS5jb20+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1pY3JvUGx1Z2luKEludGVyZmFjZSkge1xuICAgIEludGVyZmFjZS5wbHVnaW5zID0ge307XG4gICAgcmV0dXJuIGNsYXNzIGV4dGVuZHMgSW50ZXJmYWNlIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5zID0ge1xuICAgICAgICAgICAgICAgIG5hbWVzOiBbXSxcbiAgICAgICAgICAgICAgICBzZXR0aW5nczoge30sXG4gICAgICAgICAgICAgICAgcmVxdWVzdGVkOiB7fSxcbiAgICAgICAgICAgICAgICBsb2FkZWQ6IHt9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlcnMgYSBwbHVnaW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZGVmaW5lKG5hbWUsIGZuKSB7XG4gICAgICAgICAgICBJbnRlcmZhY2UucGx1Z2luc1tuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAnbmFtZSc6IG5hbWUsXG4gICAgICAgICAgICAgICAgJ2ZuJzogZm5cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWxpemVzIHRoZSBsaXN0ZWQgcGx1Z2lucyAod2l0aCBvcHRpb25zKS5cbiAgICAgICAgICogQWNjZXB0YWJsZSBmb3JtYXRzOlxuICAgICAgICAgKlxuICAgICAgICAgKiBMaXN0ICh3aXRob3V0IG9wdGlvbnMpOlxuICAgICAgICAgKiAgIFsnYScsICdiJywgJ2MnXVxuICAgICAgICAgKlxuICAgICAgICAgKiBMaXN0ICh3aXRoIG9wdGlvbnMpOlxuICAgICAgICAgKiAgIFt7J25hbWUnOiAnYScsIG9wdGlvbnM6IHt9fSwgeyduYW1lJzogJ2InLCBvcHRpb25zOiB7fX1dXG4gICAgICAgICAqXG4gICAgICAgICAqIEhhc2ggKHdpdGggb3B0aW9ucyk6XG4gICAgICAgICAqICAgeydhJzogeyAuLi4gfSwgJ2InOiB7IC4uLiB9LCAnYyc6IHsgLi4uIH19XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7YXJyYXl8b2JqZWN0fSBwbHVnaW5zXG4gICAgICAgICAqL1xuICAgICAgICBpbml0aWFsaXplUGx1Z2lucyhwbHVnaW5zKSB7XG4gICAgICAgICAgICB2YXIga2V5LCBuYW1lO1xuICAgICAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBxdWV1ZSA9IFtdO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGx1Z2lucykpIHtcbiAgICAgICAgICAgICAgICBwbHVnaW5zLmZvckVhY2goKHBsdWdpbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2gocGx1Z2luKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucGx1Z2lucy5zZXR0aW5nc1twbHVnaW4ubmFtZV0gPSBwbHVnaW4ub3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2gocGx1Z2luLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwbHVnaW5zKSB7XG4gICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gcGx1Z2lucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnBsdWdpbnMuc2V0dGluZ3Nba2V5XSA9IHBsdWdpbnNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChuYW1lID0gcXVldWUuc2hpZnQoKSkge1xuICAgICAgICAgICAgICAgIHNlbGYucmVxdWlyZShuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsb2FkUGx1Z2luKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBwbHVnaW5zID0gc2VsZi5wbHVnaW5zO1xuICAgICAgICAgICAgdmFyIHBsdWdpbiA9IEludGVyZmFjZS5wbHVnaW5zW25hbWVdO1xuICAgICAgICAgICAgaWYgKCFJbnRlcmZhY2UucGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgXCInICsgbmFtZSArICdcIiBwbHVnaW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBsdWdpbnMucmVxdWVzdGVkW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIHBsdWdpbnMubG9hZGVkW25hbWVdID0gcGx1Z2luLmZuLmFwcGx5KHNlbGYsIFtzZWxmLnBsdWdpbnMuc2V0dGluZ3NbbmFtZV0gfHwge31dKTtcbiAgICAgICAgICAgIHBsdWdpbnMubmFtZXMucHVzaChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBwbHVnaW4uXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICByZXF1aXJlKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBwbHVnaW5zID0gc2VsZi5wbHVnaW5zO1xuICAgICAgICAgICAgaWYgKCFzZWxmLnBsdWdpbnMubG9hZGVkLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbnMucmVxdWVzdGVkW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGx1Z2luIGhhcyBjaXJjdWxhciBkZXBlbmRlbmN5IChcIicgKyBuYW1lICsgJ1wiKScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLmxvYWRQbHVnaW4obmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGx1Z2lucy5sb2FkZWRbbmFtZV07XG4gICAgICAgIH1cbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWljcm9wbHVnaW4uanMubWFwIiwiZXhwb3J0IGRlZmF1bHQge1xuICAgIG9wdGlvbnM6IFtdLFxuICAgIG9wdGdyb3VwczogW10sXG4gICAgcGx1Z2luczogW10sXG4gICAgZGVsaW1pdGVyOiAnLCcsXG4gICAgc3BsaXRPbjogbnVsbCwgLy8gcmVnZXhwIG9yIHN0cmluZyBmb3Igc3BsaXR0aW5nIHVwIHZhbHVlcyBmcm9tIGEgcGFzdGUgY29tbWFuZFxuICAgIHBlcnNpc3Q6IHRydWUsXG4gICAgZGlhY3JpdGljczogdHJ1ZSxcbiAgICBjcmVhdGU6IG51bGwsXG4gICAgY3JlYXRlT25CbHVyOiBmYWxzZSxcbiAgICBjcmVhdGVGaWx0ZXI6IG51bGwsXG4gICAgaGlnaGxpZ2h0OiB0cnVlLFxuICAgIG9wZW5PbkZvY3VzOiB0cnVlLFxuICAgIHNob3VsZE9wZW46IG51bGwsXG4gICAgbWF4T3B0aW9uczogNTAsXG4gICAgbWF4SXRlbXM6IG51bGwsXG4gICAgaGlkZVNlbGVjdGVkOiBudWxsLFxuICAgIGR1cGxpY2F0ZXM6IGZhbHNlLFxuICAgIGFkZFByZWNlZGVuY2U6IGZhbHNlLFxuICAgIHNlbGVjdE9uVGFiOiBmYWxzZSxcbiAgICBwcmVsb2FkOiBudWxsLFxuICAgIGFsbG93RW1wdHlPcHRpb246IGZhbHNlLFxuICAgIC8vY2xvc2VBZnRlclNlbGVjdDogZmFsc2UsXG4gICAgcmVmcmVzaFRocm90dGxlOiAzMDAsXG4gICAgbG9hZFRocm90dGxlOiAzMDAsXG4gICAgbG9hZGluZ0NsYXNzOiAnbG9hZGluZycsXG4gICAgZGF0YUF0dHI6IG51bGwsIC8vJ2RhdGEtZGF0YScsXG4gICAgb3B0Z3JvdXBGaWVsZDogJ29wdGdyb3VwJyxcbiAgICB2YWx1ZUZpZWxkOiAndmFsdWUnLFxuICAgIGxhYmVsRmllbGQ6ICd0ZXh0JyxcbiAgICBkaXNhYmxlZEZpZWxkOiAnZGlzYWJsZWQnLFxuICAgIG9wdGdyb3VwTGFiZWxGaWVsZDogJ2xhYmVsJyxcbiAgICBvcHRncm91cFZhbHVlRmllbGQ6ICd2YWx1ZScsXG4gICAgbG9ja09wdGdyb3VwT3JkZXI6IGZhbHNlLFxuICAgIHNvcnRGaWVsZDogJyRvcmRlcicsXG4gICAgc2VhcmNoRmllbGQ6IFsndGV4dCddLFxuICAgIHNlYXJjaENvbmp1bmN0aW9uOiAnYW5kJyxcbiAgICBtb2RlOiBudWxsLFxuICAgIHdyYXBwZXJDbGFzczogJ3RzLXdyYXBwZXInLFxuICAgIGNvbnRyb2xDbGFzczogJ3RzLWNvbnRyb2wnLFxuICAgIGRyb3Bkb3duQ2xhc3M6ICd0cy1kcm9wZG93bicsXG4gICAgZHJvcGRvd25Db250ZW50Q2xhc3M6ICd0cy1kcm9wZG93bi1jb250ZW50JyxcbiAgICBpdGVtQ2xhc3M6ICdpdGVtJyxcbiAgICBvcHRpb25DbGFzczogJ29wdGlvbicsXG4gICAgZHJvcGRvd25QYXJlbnQ6IG51bGwsXG4gICAgY29udHJvbElucHV0OiAnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgYXV0b2NvbXBsZXRlPVwib2ZmXCIgc2l6ZT1cIjFcIiAvPicsXG4gICAgY29weUNsYXNzZXNUb0Ryb3Bkb3duOiBmYWxzZSxcbiAgICBwbGFjZWhvbGRlcjogbnVsbCxcbiAgICBoaWRlUGxhY2Vob2xkZXI6IG51bGwsXG4gICAgc2hvdWxkTG9hZDogZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiBxdWVyeS5sZW5ndGggPiAwO1xuICAgIH0sXG4gICAgLypcbiAgICBsb2FkICAgICAgICAgICAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKHF1ZXJ5LCBjYWxsYmFjaykgeyAuLi4gfVxuICAgIHNjb3JlICAgICAgICAgICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24oc2VhcmNoKSB7IC4uLiB9XG4gICAgb25Jbml0aWFsaXplICAgICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICBvbkNoYW5nZSAgICAgICAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKHZhbHVlKSB7IC4uLiB9XG4gICAgb25JdGVtQWRkICAgICAgICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbih2YWx1ZSwgJGl0ZW0pIHsgLi4uIH1cbiAgICBvbkl0ZW1SZW1vdmUgICAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKHZhbHVlKSB7IC4uLiB9XG4gICAgb25DbGVhciAgICAgICAgICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICBvbk9wdGlvbkFkZCAgICAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKHZhbHVlLCBkYXRhKSB7IC4uLiB9XG4gICAgb25PcHRpb25SZW1vdmUgICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbih2YWx1ZSkgeyAuLi4gfVxuICAgIG9uT3B0aW9uQ2xlYXIgICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAgb25PcHRpb25Hcm91cEFkZCAgICAgOiBudWxsLCAvLyBmdW5jdGlvbihpZCwgZGF0YSkgeyAuLi4gfVxuICAgIG9uT3B0aW9uR3JvdXBSZW1vdmUgIDogbnVsbCwgLy8gZnVuY3Rpb24oaWQpIHsgLi4uIH1cbiAgICBvbk9wdGlvbkdyb3VwQ2xlYXIgICA6IG51bGwsIC8vIGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgIG9uRHJvcGRvd25PcGVuICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24oZHJvcGRvd24pIHsgLi4uIH1cbiAgICBvbkRyb3Bkb3duQ2xvc2UgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKGRyb3Bkb3duKSB7IC4uLiB9XG4gICAgb25UeXBlICAgICAgICAgICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbihzdHIpIHsgLi4uIH1cbiAgICBvbkRlbGV0ZSAgICAgICAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKHZhbHVlcykgeyAuLi4gfVxuICAgICovXG4gICAgcmVuZGVyOiB7XG4gICAgLypcbiAgICBpdGVtOiBudWxsLFxuICAgIG9wdGdyb3VwOiBudWxsLFxuICAgIG9wdGdyb3VwX2hlYWRlcjogbnVsbCxcbiAgICBvcHRpb246IG51bGwsXG4gICAgb3B0aW9uX2NyZWF0ZTogbnVsbFxuICAgICovXG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRzLmpzLm1hcCIsImltcG9ydCBkZWZhdWx0cyBmcm9tIFwiLi9kZWZhdWx0cy5qc1wiO1xuaW1wb3J0IHsgaGFzaF9rZXksIGl0ZXJhdGUgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U2V0dGluZ3MoaW5wdXQsIHNldHRpbmdzX3VzZXIpIHtcbiAgICB2YXIgc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cywgc2V0dGluZ3NfdXNlcik7XG4gICAgdmFyIGF0dHJfZGF0YSA9IHNldHRpbmdzLmRhdGFBdHRyO1xuICAgIHZhciBmaWVsZF9sYWJlbCA9IHNldHRpbmdzLmxhYmVsRmllbGQ7XG4gICAgdmFyIGZpZWxkX3ZhbHVlID0gc2V0dGluZ3MudmFsdWVGaWVsZDtcbiAgICB2YXIgZmllbGRfZGlzYWJsZWQgPSBzZXR0aW5ncy5kaXNhYmxlZEZpZWxkO1xuICAgIHZhciBmaWVsZF9vcHRncm91cCA9IHNldHRpbmdzLm9wdGdyb3VwRmllbGQ7XG4gICAgdmFyIGZpZWxkX29wdGdyb3VwX2xhYmVsID0gc2V0dGluZ3Mub3B0Z3JvdXBMYWJlbEZpZWxkO1xuICAgIHZhciBmaWVsZF9vcHRncm91cF92YWx1ZSA9IHNldHRpbmdzLm9wdGdyb3VwVmFsdWVGaWVsZDtcbiAgICB2YXIgdGFnX25hbWUgPSBpbnB1dC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHBsYWNlaG9sZGVyID0gaW5wdXQuZ2V0QXR0cmlidXRlKCdwbGFjZWhvbGRlcicpIHx8IGlucHV0LmdldEF0dHJpYnV0ZSgnZGF0YS1wbGFjZWhvbGRlcicpO1xuICAgIGlmICghcGxhY2Vob2xkZXIgJiYgIXNldHRpbmdzLmFsbG93RW1wdHlPcHRpb24pIHtcbiAgICAgICAgbGV0IG9wdGlvbiA9IGlucHV0LnF1ZXJ5U2VsZWN0b3IoJ29wdGlvblt2YWx1ZT1cIlwiXScpO1xuICAgICAgICBpZiAob3B0aW9uKSB7XG4gICAgICAgICAgICBwbGFjZWhvbGRlciA9IG9wdGlvbi50ZXh0Q29udGVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgc2V0dGluZ3NfZWxlbWVudCA9IHtcbiAgICAgICAgcGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyLFxuICAgICAgICBvcHRpb25zOiBbXSxcbiAgICAgICAgb3B0Z3JvdXBzOiBbXSxcbiAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICBtYXhJdGVtczogbnVsbCxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgZnJvbSBhIDxzZWxlY3Q+IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKi9cbiAgICB2YXIgaW5pdF9zZWxlY3QgPSAoKSA9PiB7XG4gICAgICAgIHZhciB0YWdOYW1lO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHNldHRpbmdzX2VsZW1lbnQub3B0aW9ucztcbiAgICAgICAgdmFyIG9wdGlvbnNNYXAgPSB7fTtcbiAgICAgICAgdmFyIGdyb3VwX2NvdW50ID0gMTtcbiAgICAgICAgbGV0ICRvcmRlciA9IDA7XG4gICAgICAgIHZhciByZWFkRGF0YSA9IChlbCkgPT4ge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBPYmplY3QuYXNzaWduKHt9LCBlbC5kYXRhc2V0KTsgLy8gZ2V0IHBsYWluIG9iamVjdCBmcm9tIERPTVN0cmluZ01hcFxuICAgICAgICAgICAgdmFyIGpzb24gPSBhdHRyX2RhdGEgJiYgZGF0YVthdHRyX2RhdGFdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uID09PSAnc3RyaW5nJyAmJiBqc29uLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBPYmplY3QuYXNzaWduKGRhdGEsIEpTT04ucGFyc2UoanNvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBhZGRPcHRpb24gPSAob3B0aW9uLCBncm91cCkgPT4ge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gaGFzaF9rZXkob3B0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICghdmFsdWUgJiYgIXNldHRpbmdzLmFsbG93RW1wdHlPcHRpb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gaWYgdGhlIG9wdGlvbiBhbHJlYWR5IGV4aXN0cywgaXQncyBwcm9iYWJseSBiZWVuXG4gICAgICAgICAgICAvLyBkdXBsaWNhdGVkIGluIGFub3RoZXIgb3B0Z3JvdXAuIGluIHRoaXMgY2FzZSwgcHVzaFxuICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgZ3JvdXAgdG8gdGhlIFwib3B0Z3JvdXBcIiBwcm9wZXJ0eSBvbiB0aGVcbiAgICAgICAgICAgIC8vIGV4aXN0aW5nIG9wdGlvbiBzbyB0aGF0IGl0J3MgcmVuZGVyZWQgaW4gYm90aCBwbGFjZXMuXG4gICAgICAgICAgICBpZiAob3B0aW9uc01hcC5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyciA9IG9wdGlvbnNNYXBbdmFsdWVdW2ZpZWxkX29wdGdyb3VwXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNNYXBbdmFsdWVdW2ZpZWxkX29wdGdyb3VwXSA9IGdyb3VwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNNYXBbdmFsdWVdW2ZpZWxkX29wdGdyb3VwXSA9IFthcnIsIGdyb3VwXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKGdyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25fZGF0YSA9IHJlYWREYXRhKG9wdGlvbik7XG4gICAgICAgICAgICAgICAgb3B0aW9uX2RhdGFbZmllbGRfbGFiZWxdID0gb3B0aW9uX2RhdGFbZmllbGRfbGFiZWxdIHx8IG9wdGlvbi50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICBvcHRpb25fZGF0YVtmaWVsZF92YWx1ZV0gPSBvcHRpb25fZGF0YVtmaWVsZF92YWx1ZV0gfHwgdmFsdWU7XG4gICAgICAgICAgICAgICAgb3B0aW9uX2RhdGFbZmllbGRfZGlzYWJsZWRdID0gb3B0aW9uX2RhdGFbZmllbGRfZGlzYWJsZWRdIHx8IG9wdGlvbi5kaXNhYmxlZDtcbiAgICAgICAgICAgICAgICBvcHRpb25fZGF0YVtmaWVsZF9vcHRncm91cF0gPSBvcHRpb25fZGF0YVtmaWVsZF9vcHRncm91cF0gfHwgZ3JvdXA7XG4gICAgICAgICAgICAgICAgb3B0aW9uX2RhdGEuJG9wdGlvbiA9IG9wdGlvbjtcbiAgICAgICAgICAgICAgICBvcHRpb25fZGF0YS4kb3JkZXIgPSBvcHRpb25fZGF0YS4kb3JkZXIgfHwgKyskb3JkZXI7XG4gICAgICAgICAgICAgICAgb3B0aW9uc01hcFt2YWx1ZV0gPSBvcHRpb25fZGF0YTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnB1c2gob3B0aW9uX2RhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzX2VsZW1lbnQuaXRlbXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBhZGRHcm91cCA9IChvcHRncm91cCkgPT4ge1xuICAgICAgICAgICAgdmFyIGlkLCBvcHRncm91cF9kYXRhO1xuICAgICAgICAgICAgb3B0Z3JvdXBfZGF0YSA9IHJlYWREYXRhKG9wdGdyb3VwKTtcbiAgICAgICAgICAgIG9wdGdyb3VwX2RhdGFbZmllbGRfb3B0Z3JvdXBfbGFiZWxdID0gb3B0Z3JvdXBfZGF0YVtmaWVsZF9vcHRncm91cF9sYWJlbF0gfHwgb3B0Z3JvdXAuZ2V0QXR0cmlidXRlKCdsYWJlbCcpIHx8ICcnO1xuICAgICAgICAgICAgb3B0Z3JvdXBfZGF0YVtmaWVsZF9vcHRncm91cF92YWx1ZV0gPSBvcHRncm91cF9kYXRhW2ZpZWxkX29wdGdyb3VwX3ZhbHVlXSB8fCBncm91cF9jb3VudCsrO1xuICAgICAgICAgICAgb3B0Z3JvdXBfZGF0YVtmaWVsZF9kaXNhYmxlZF0gPSBvcHRncm91cF9kYXRhW2ZpZWxkX2Rpc2FibGVkXSB8fCBvcHRncm91cC5kaXNhYmxlZDtcbiAgICAgICAgICAgIG9wdGdyb3VwX2RhdGEuJG9yZGVyID0gb3B0Z3JvdXBfZGF0YS4kb3JkZXIgfHwgKyskb3JkZXI7XG4gICAgICAgICAgICBzZXR0aW5nc19lbGVtZW50Lm9wdGdyb3Vwcy5wdXNoKG9wdGdyb3VwX2RhdGEpO1xuICAgICAgICAgICAgaWQgPSBvcHRncm91cF9kYXRhW2ZpZWxkX29wdGdyb3VwX3ZhbHVlXTtcbiAgICAgICAgICAgIGl0ZXJhdGUob3B0Z3JvdXAuY2hpbGRyZW4sIChvcHRpb24pID0+IHtcbiAgICAgICAgICAgICAgICBhZGRPcHRpb24ob3B0aW9uLCBpZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgc2V0dGluZ3NfZWxlbWVudC5tYXhJdGVtcyA9IGlucHV0Lmhhc0F0dHJpYnV0ZSgnbXVsdGlwbGUnKSA/IG51bGwgOiAxO1xuICAgICAgICBpdGVyYXRlKGlucHV0LmNoaWxkcmVuLCAoY2hpbGQpID0+IHtcbiAgICAgICAgICAgIHRhZ05hbWUgPSBjaGlsZC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ29wdGdyb3VwJykge1xuICAgICAgICAgICAgICAgIGFkZEdyb3VwKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRhZ05hbWUgPT09ICdvcHRpb24nKSB7XG4gICAgICAgICAgICAgICAgYWRkT3B0aW9uKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGZyb20gYSA8aW5wdXQgdHlwZT1cInRleHRcIj4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqL1xuICAgIHZhciBpbml0X3RleHRib3ggPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGFfcmF3ID0gaW5wdXQuZ2V0QXR0cmlidXRlKGF0dHJfZGF0YSk7XG4gICAgICAgIGlmICghZGF0YV9yYXcpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGlucHV0LnZhbHVlLnRyaW0oKSB8fCAnJztcbiAgICAgICAgICAgIGlmICghc2V0dGluZ3MuYWxsb3dFbXB0eU9wdGlvbiAmJiAhdmFsdWUubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IHZhbHVlLnNwbGl0KHNldHRpbmdzLmRlbGltaXRlcik7XG4gICAgICAgICAgICBpdGVyYXRlKHZhbHVlcywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9uID0ge307XG4gICAgICAgICAgICAgICAgb3B0aW9uW2ZpZWxkX2xhYmVsXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIG9wdGlvbltmaWVsZF92YWx1ZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBzZXR0aW5nc19lbGVtZW50Lm9wdGlvbnMucHVzaChvcHRpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXR0aW5nc19lbGVtZW50Lml0ZW1zID0gdmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0dGluZ3NfZWxlbWVudC5vcHRpb25zID0gSlNPTi5wYXJzZShkYXRhX3Jhdyk7XG4gICAgICAgICAgICBpdGVyYXRlKHNldHRpbmdzX2VsZW1lbnQub3B0aW9ucywgKG9wdCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzX2VsZW1lbnQuaXRlbXMucHVzaChvcHRbZmllbGRfdmFsdWVdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpZiAodGFnX25hbWUgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgIGluaXRfc2VsZWN0KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpbml0X3RleHRib3goKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCBzZXR0aW5nc19lbGVtZW50LCBzZXR0aW5nc191c2VyKTtcbn1cbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldFNldHRpbmdzLmpzLm1hcCIsIi8qKlxuKiBUb20gU2VsZWN0IHYyLjQuM1xuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKi9cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHNjYWxhciB0byBpdHMgYmVzdCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAqIGZvciBoYXNoIGtleXMgYW5kIEhUTUwgYXR0cmlidXRlIHZhbHVlcy5cbiAqXG4gKiBUcmFuc2Zvcm1hdGlvbnM6XG4gKiAgICdzdHInICAgICAtPiAnc3RyJ1xuICogICBudWxsICAgICAgLT4gJydcbiAqICAgdW5kZWZpbmVkIC0+ICcnXG4gKiAgIHRydWUgICAgICAtPiAnMSdcbiAqICAgZmFsc2UgICAgIC0+ICcwJ1xuICogICAwICAgICAgICAgLT4gJzAnXG4gKiAgIDEgICAgICAgICAtPiAnMSdcbiAqXG4gKi9cblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGFycmF5cyBhbmQgaGFzaGVzLlxuICpcbiAqIGBgYFxuICogaXRlcmF0ZSh0aGlzLml0ZW1zLCBmdW5jdGlvbihpdGVtLCBpZCkge1xuICogICAgLy8gaW52b2tlZCBmb3IgZWFjaCBpdGVtXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqL1xuY29uc3QgaXRlcmF0ZSA9IChvYmplY3QsIGNhbGxiYWNrKSA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICBvYmplY3QuZm9yRWFjaChjYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGNhbGxiYWNrKG9iamVjdFtrZXldLCBrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgY3NzIGNsYXNzZXNcbiAqXG4gKi9cbmNvbnN0IHJlbW92ZUNsYXNzZXMgPSAoZWxtdHMsIC4uLmNsYXNzZXMpID0+IHtcbiAgdmFyIG5vcm1fY2xhc3NlcyA9IGNsYXNzZXNBcnJheShjbGFzc2VzKTtcbiAgZWxtdHMgPSBjYXN0QXNBcnJheShlbG10cyk7XG4gIGVsbXRzLm1hcChlbCA9PiB7XG4gICAgbm9ybV9jbGFzc2VzLm1hcChjbHMgPT4ge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGFyZ3VtZW50c1xuICpcbiAqL1xuY29uc3QgY2xhc3Nlc0FycmF5ID0gYXJncyA9PiB7XG4gIHZhciBjbGFzc2VzID0gW107XG4gIGl0ZXJhdGUoYXJncywgX2NsYXNzZXMgPT4ge1xuICAgIGlmICh0eXBlb2YgX2NsYXNzZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBfY2xhc3NlcyA9IF9jbGFzc2VzLnRyaW0oKS5zcGxpdCgvW1xcdFxcblxcZlxcclxcc10vKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoX2NsYXNzZXMpKSB7XG4gICAgICBjbGFzc2VzID0gY2xhc3Nlcy5jb25jYXQoX2NsYXNzZXMpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjbGFzc2VzLmZpbHRlcihCb29sZWFuKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuIGFycmF5IGZyb20gYXJnIGlmIGl0J3Mgbm90IGFscmVhZHkgYW4gYXJyYXlcbiAqXG4gKi9cbmNvbnN0IGNhc3RBc0FycmF5ID0gYXJnID0+IHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICBhcmcgPSBbYXJnXTtcbiAgfVxuICByZXR1cm4gYXJnO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGluZGV4IG9mIGFuIGVsZW1lbnQgYW1vbmdzdCBzaWJsaW5nIG5vZGVzIG9mIHRoZSBzYW1lIHR5cGVcbiAqXG4gKi9cbmNvbnN0IG5vZGVJbmRleCA9IChlbCwgYW1vbmdzdCkgPT4ge1xuICBpZiAoIWVsKSByZXR1cm4gLTE7XG4gIGFtb25nc3QgPSBhbW9uZ3N0IHx8IGVsLm5vZGVOYW1lO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChlbCA9IGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpIHtcbiAgICBpZiAoZWwubWF0Y2hlcyhhbW9uZ3N0KSkge1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaTtcbn07XG5cbi8qKlxuICogUGx1Z2luOiBcImRyb3Bkb3duX2lucHV0XCIgKFRvbSBTZWxlY3QpXG4gKiBDb3B5cmlnaHQgKGMpIGNvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gcGx1Z2luICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8qKlxuICAgKiBNb3ZlcyB0aGUgY2FyZXQgdG8gdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICpcbiAgICogVGhlIGlucHV0IG11c3QgYmUgbW92ZWQgYnkgbGVhdmluZyBpdCBpbiBwbGFjZSBhbmQgbW92aW5nIHRoZVxuICAgKiBzaWJsaW5ncywgZHVlIHRvIHRoZSBmYWN0IHRoYXQgZm9jdXMgY2Fubm90IGJlIHJlc3RvcmVkIG9uY2UgbG9zdFxuICAgKiBvbiBtb2JpbGUgd2Via2l0IGRldmljZXNcbiAgICpcbiAgICovXG4gIHNlbGYuaG9vaygnaW5zdGVhZCcsICdzZXRDYXJldCcsIG5ld19wb3MgPT4ge1xuICAgIGlmIChzZWxmLnNldHRpbmdzLm1vZGUgPT09ICdzaW5nbGUnIHx8ICFzZWxmLmNvbnRyb2wuY29udGFpbnMoc2VsZi5jb250cm9sX2lucHV0KSkge1xuICAgICAgbmV3X3BvcyA9IHNlbGYuaXRlbXMubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdfcG9zID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc2VsZi5pdGVtcy5sZW5ndGgsIG5ld19wb3MpKTtcbiAgICAgIGlmIChuZXdfcG9zICE9IHNlbGYuY2FyZXRQb3MgJiYgIXNlbGYuaXNQZW5kaW5nKSB7XG4gICAgICAgIHNlbGYuY29udHJvbENoaWxkcmVuKCkuZm9yRWFjaCgoY2hpbGQsIGopID0+IHtcbiAgICAgICAgICBpZiAoaiA8IG5ld19wb3MpIHtcbiAgICAgICAgICAgIHNlbGYuY29udHJvbF9pbnB1dC5pbnNlcnRBZGphY2VudEVsZW1lbnQoJ2JlZm9yZWJlZ2luJywgY2hpbGQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmNvbnRyb2wuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGYuY2FyZXRQb3MgPSBuZXdfcG9zO1xuICB9KTtcbiAgc2VsZi5ob29rKCdpbnN0ZWFkJywgJ21vdmVDYXJldCcsIGRpcmVjdGlvbiA9PiB7XG4gICAgaWYgKCFzZWxmLmlzRm9jdXNlZCkgcmV0dXJuO1xuXG4gICAgLy8gbW92ZSBjYXJldCBiZWZvcmUgb3IgYWZ0ZXIgc2VsZWN0ZWQgaXRlbXNcbiAgICBjb25zdCBsYXN0X2FjdGl2ZSA9IHNlbGYuZ2V0TGFzdEFjdGl2ZShkaXJlY3Rpb24pO1xuICAgIGlmIChsYXN0X2FjdGl2ZSkge1xuICAgICAgY29uc3QgaWR4ID0gbm9kZUluZGV4KGxhc3RfYWN0aXZlKTtcbiAgICAgIHNlbGYuc2V0Q2FyZXQoZGlyZWN0aW9uID4gMCA/IGlkeCArIDEgOiBpZHgpO1xuICAgICAgc2VsZi5zZXRBY3RpdmVJdGVtKCk7XG4gICAgICByZW1vdmVDbGFzc2VzKGxhc3RfYWN0aXZlLCAnbGFzdC1hY3RpdmUnKTtcblxuICAgICAgLy8gbW92ZSBjYXJldCBsZWZ0IG9yIHJpZ2h0IG9mIGN1cnJlbnQgcG9zaXRpb25cbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5zZXRDYXJldChzZWxmLmNhcmV0UG9zICsgZGlyZWN0aW9uKTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgeyBwbHVnaW4gYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGx1Z2luLmpzLm1hcFxuIiwiLyoqXG4qIFRvbSBTZWxlY3QgdjIuNC4zXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qL1xuXG4vKipcbiAqIENvbnZlcnRzIGEgc2NhbGFyIHRvIGl0cyBiZXN0IHN0cmluZyByZXByZXNlbnRhdGlvblxuICogZm9yIGhhc2gga2V5cyBhbmQgSFRNTCBhdHRyaWJ1dGUgdmFsdWVzLlxuICpcbiAqIFRyYW5zZm9ybWF0aW9uczpcbiAqICAgJ3N0cicgICAgIC0+ICdzdHInXG4gKiAgIG51bGwgICAgICAtPiAnJ1xuICogICB1bmRlZmluZWQgLT4gJydcbiAqICAgdHJ1ZSAgICAgIC0+ICcxJ1xuICogICBmYWxzZSAgICAgLT4gJzAnXG4gKiAgIDAgICAgICAgICAtPiAnMCdcbiAqICAgMSAgICAgICAgIC0+ICcxJ1xuICpcbiAqL1xuXG4vKipcbiAqIEFkZCBldmVudCBoZWxwZXJcbiAqXG4gKi9cbmNvbnN0IGFkZEV2ZW50ID0gKHRhcmdldCwgdHlwZSwgY2FsbGJhY2ssIG9wdGlvbnMpID0+IHtcbiAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2ssIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBQbHVnaW46IFwiY2hhbmdlX2xpc3RlbmVyXCIgKFRvbSBTZWxlY3QpXG4gKiBDb3B5cmlnaHQgKGMpIGNvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gcGx1Z2luICgpIHtcbiAgYWRkRXZlbnQodGhpcy5pbnB1dCwgJ2NoYW5nZScsICgpID0+IHtcbiAgICB0aGlzLnN5bmMoKTtcbiAgfSk7XG59XG5cbmV4cG9ydCB7IHBsdWdpbiBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbHVnaW4uanMubWFwXG4iLCIvKipcbiogVG9tIFNlbGVjdCB2Mi40LjNcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiovXG5cbi8qKlxuICogQ29udmVydHMgYSBzY2FsYXIgdG8gaXRzIGJlc3Qgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gKiBmb3IgaGFzaCBrZXlzIGFuZCBIVE1MIGF0dHJpYnV0ZSB2YWx1ZXMuXG4gKlxuICogVHJhbnNmb3JtYXRpb25zOlxuICogICAnc3RyJyAgICAgLT4gJ3N0cidcbiAqICAgbnVsbCAgICAgIC0+ICcnXG4gKiAgIHVuZGVmaW5lZCAtPiAnJ1xuICogICB0cnVlICAgICAgLT4gJzEnXG4gKiAgIGZhbHNlICAgICAtPiAnMCdcbiAqICAgMCAgICAgICAgIC0+ICcwJ1xuICogICAxICAgICAgICAgLT4gJzEnXG4gKlxuICovXG5jb25zdCBoYXNoX2tleSA9IHZhbHVlID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdmFsdWUgPT09IG51bGwpIHJldHVybiBudWxsO1xuICByZXR1cm4gZ2V0X2hhc2godmFsdWUpO1xufTtcbmNvbnN0IGdldF9oYXNoID0gdmFsdWUgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHJldHVybiB2YWx1ZSA/ICcxJyA6ICcwJztcbiAgcmV0dXJuIHZhbHVlICsgJyc7XG59O1xuXG4vKipcbiAqIFByZXZlbnQgZGVmYXVsdFxuICpcbiAqL1xuY29uc3QgcHJldmVudERlZmF1bHQgPSAoZXZ0LCBzdG9wID0gZmFsc2UpID0+IHtcbiAgaWYgKGV2dCkge1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmIChzdG9wKSB7XG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFJldHVybiBhIGRvbSBlbGVtZW50IGZyb20gZWl0aGVyIGEgZG9tIHF1ZXJ5IHN0cmluZywgalF1ZXJ5IG9iamVjdCwgYSBkb20gZWxlbWVudCBvciBodG1sIHN0cmluZ1xuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDk0MTQzL2NyZWF0aW5nLWEtbmV3LWRvbS1lbGVtZW50LWZyb20tYW4taHRtbC1zdHJpbmctdXNpbmctYnVpbHQtaW4tZG9tLW1ldGhvZHMtb3ItcHJvLzM1Mzg1NTE4IzM1Mzg1NTE4XG4gKlxuICogcGFyYW0gcXVlcnkgc2hvdWxkIGJlIHt9XG4gKi9cbmNvbnN0IGdldERvbSA9IHF1ZXJ5ID0+IHtcbiAgaWYgKHF1ZXJ5LmpxdWVyeSkge1xuICAgIHJldHVybiBxdWVyeVswXTtcbiAgfVxuICBpZiAocXVlcnkgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgIHJldHVybiBxdWVyeTtcbiAgfVxuICBpZiAoaXNIdG1sU3RyaW5nKHF1ZXJ5KSkge1xuICAgIHZhciB0cGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgIHRwbC5pbm5lckhUTUwgPSBxdWVyeS50cmltKCk7IC8vIE5ldmVyIHJldHVybiBhIHRleHQgbm9kZSBvZiB3aGl0ZXNwYWNlIGFzIHRoZSByZXN1bHRcbiAgICByZXR1cm4gdHBsLmNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgfVxuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihxdWVyeSk7XG59O1xuY29uc3QgaXNIdG1sU3RyaW5nID0gYXJnID0+IHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnICYmIGFyZy5pbmRleE9mKCc8JykgPiAtMSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUGx1Z2luOiBcImNoZWNrYm94X29wdGlvbnNcIiAoVG9tIFNlbGVjdClcbiAqIENvcHlyaWdodCAoYykgY29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcbiAqIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBwbHVnaW4gKHVzZXJPcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIG9yaWdfb25PcHRpb25TZWxlY3QgPSBzZWxmLm9uT3B0aW9uU2VsZWN0O1xuICBzZWxmLnNldHRpbmdzLmhpZGVTZWxlY3RlZCA9IGZhbHNlO1xuICBjb25zdCBjYk9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAvLyBzbyB0aGF0IHRoZSB1c2VyIG1heSBhZGQgZGlmZmVyZW50IG9uZXMgYXMgd2VsbFxuICAgIGNsYXNzTmFtZTogXCJ0b21zZWxlY3QtY2hlY2tib3hcIixcbiAgICAvLyB0aGUgZm9sbG93aW5nIGRlZmF1bHQgdG8gdGhlIGhpc3RvcmljIHBsdWdpbidzIHZhbHVlc1xuICAgIGNoZWNrZWRDbGFzc05hbWVzOiB1bmRlZmluZWQsXG4gICAgdW5jaGVja2VkQ2xhc3NOYW1lczogdW5kZWZpbmVkXG4gIH0sIHVzZXJPcHRpb25zKTtcbiAgdmFyIFVwZGF0ZUNoZWNrZWQgPSBmdW5jdGlvbiBVcGRhdGVDaGVja2VkKGNoZWNrYm94LCB0b0NoZWNrKSB7XG4gICAgaWYgKHRvQ2hlY2spIHtcbiAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSB0cnVlO1xuICAgICAgaWYgKGNiT3B0aW9ucy51bmNoZWNrZWRDbGFzc05hbWVzKSB7XG4gICAgICAgIGNoZWNrYm94LmNsYXNzTGlzdC5yZW1vdmUoLi4uY2JPcHRpb25zLnVuY2hlY2tlZENsYXNzTmFtZXMpO1xuICAgICAgfVxuICAgICAgaWYgKGNiT3B0aW9ucy5jaGVja2VkQ2xhc3NOYW1lcykge1xuICAgICAgICBjaGVja2JveC5jbGFzc0xpc3QuYWRkKC4uLmNiT3B0aW9ucy5jaGVja2VkQ2xhc3NOYW1lcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgIGlmIChjYk9wdGlvbnMuY2hlY2tlZENsYXNzTmFtZXMpIHtcbiAgICAgICAgY2hlY2tib3guY2xhc3NMaXN0LnJlbW92ZSguLi5jYk9wdGlvbnMuY2hlY2tlZENsYXNzTmFtZXMpO1xuICAgICAgfVxuICAgICAgaWYgKGNiT3B0aW9ucy51bmNoZWNrZWRDbGFzc05hbWVzKSB7XG4gICAgICAgIGNoZWNrYm94LmNsYXNzTGlzdC5hZGQoLi4uY2JPcHRpb25zLnVuY2hlY2tlZENsYXNzTmFtZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyB1cGRhdGUgdGhlIGNoZWNrYm94IGZvciBhbiBvcHRpb25cbiAgdmFyIFVwZGF0ZUNoZWNrYm94ID0gZnVuY3Rpb24gVXBkYXRlQ2hlY2tib3gob3B0aW9uKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB2YXIgY2hlY2tib3ggPSBvcHRpb24ucXVlcnlTZWxlY3RvcignaW5wdXQuJyArIGNiT3B0aW9ucy5jbGFzc05hbWUpO1xuICAgICAgaWYgKGNoZWNrYm94IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCkge1xuICAgICAgICBVcGRhdGVDaGVja2VkKGNoZWNrYm94LCBvcHRpb24uY2xhc3NMaXN0LmNvbnRhaW5zKCdzZWxlY3RlZCcpKTtcbiAgICAgIH1cbiAgICB9LCAxKTtcbiAgfTtcblxuICAvLyBhZGQgY2hlY2tib3ggdG8gb3B0aW9uIHRlbXBsYXRlXG4gIHNlbGYuaG9vaygnYWZ0ZXInLCAnc2V0dXBUZW1wbGF0ZXMnLCAoKSA9PiB7XG4gICAgdmFyIG9yaWdfcmVuZGVyX29wdGlvbiA9IHNlbGYuc2V0dGluZ3MucmVuZGVyLm9wdGlvbjtcbiAgICBzZWxmLnNldHRpbmdzLnJlbmRlci5vcHRpb24gPSAoZGF0YSwgZXNjYXBlX2h0bWwpID0+IHtcbiAgICAgIHZhciByZW5kZXJlZCA9IGdldERvbShvcmlnX3JlbmRlcl9vcHRpb24uY2FsbChzZWxmLCBkYXRhLCBlc2NhcGVfaHRtbCkpO1xuICAgICAgdmFyIGNoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgIGlmIChjYk9wdGlvbnMuY2xhc3NOYW1lKSB7XG4gICAgICAgIGNoZWNrYm94LmNsYXNzTGlzdC5hZGQoY2JPcHRpb25zLmNsYXNzTmFtZSk7XG4gICAgICB9XG4gICAgICBjaGVja2JveC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgcHJldmVudERlZmF1bHQoZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgY2hlY2tib3gudHlwZSA9ICdjaGVja2JveCc7XG4gICAgICBjb25zdCBoYXNoZWQgPSBoYXNoX2tleShkYXRhW3NlbGYuc2V0dGluZ3MudmFsdWVGaWVsZF0pO1xuICAgICAgVXBkYXRlQ2hlY2tlZChjaGVja2JveCwgISEoaGFzaGVkICYmIHNlbGYuaXRlbXMuaW5kZXhPZihoYXNoZWQpID4gLTEpKTtcbiAgICAgIHJlbmRlcmVkLnByZXBlbmQoY2hlY2tib3gpO1xuICAgICAgcmV0dXJuIHJlbmRlcmVkO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIHVuY2hlY2sgd2hlbiBpdGVtIHJlbW92ZWRcbiAgc2VsZi5vbignaXRlbV9yZW1vdmUnLCB2YWx1ZSA9PiB7XG4gICAgdmFyIG9wdGlvbiA9IHNlbGYuZ2V0T3B0aW9uKHZhbHVlKTtcbiAgICBpZiAob3B0aW9uKSB7XG4gICAgICAvLyBpZiBkcm9wZG93biBoYXNuJ3QgYmVlbiBvcGVuZWQgeWV0LCB0aGUgb3B0aW9uIHdvbid0IGV4aXN0XG4gICAgICBvcHRpb24uY2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0ZWQnKTsgLy8gc2VsZWN0ZWQgY2xhc3Mgd29uJ3QgYmUgcmVtb3ZlZCB5ZXRcbiAgICAgIFVwZGF0ZUNoZWNrYm94KG9wdGlvbik7XG4gICAgfVxuICB9KTtcblxuICAvLyBjaGVjayB3aGVuIGl0ZW0gYWRkZWRcbiAgc2VsZi5vbignaXRlbV9hZGQnLCB2YWx1ZSA9PiB7XG4gICAgdmFyIG9wdGlvbiA9IHNlbGYuZ2V0T3B0aW9uKHZhbHVlKTtcbiAgICBpZiAob3B0aW9uKSB7XG4gICAgICAvLyBpZiBkcm9wZG93biBoYXNuJ3QgYmVlbiBvcGVuZWQgeWV0LCB0aGUgb3B0aW9uIHdvbid0IGV4aXN0XG4gICAgICBVcGRhdGVDaGVja2JveChvcHRpb24pO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcmVtb3ZlIGl0ZW1zIHdoZW4gc2VsZWN0ZWQgb3B0aW9uIGlzIGNsaWNrZWRcbiAgc2VsZi5ob29rKCdpbnN0ZWFkJywgJ29uT3B0aW9uU2VsZWN0JywgKGV2dCwgb3B0aW9uKSA9PiB7XG4gICAgaWYgKG9wdGlvbi5jbGFzc0xpc3QuY29udGFpbnMoJ3NlbGVjdGVkJykpIHtcbiAgICAgIG9wdGlvbi5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpO1xuICAgICAgc2VsZi5yZW1vdmVJdGVtKG9wdGlvbi5kYXRhc2V0LnZhbHVlKTtcbiAgICAgIHNlbGYucmVmcmVzaE9wdGlvbnMoKTtcbiAgICAgIHByZXZlbnREZWZhdWx0KGV2dCwgdHJ1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9yaWdfb25PcHRpb25TZWxlY3QuY2FsbChzZWxmLCBldnQsIG9wdGlvbik7XG4gICAgVXBkYXRlQ2hlY2tib3gob3B0aW9uKTtcbiAgfSk7XG59XG5cbmV4cG9ydCB7IHBsdWdpbiBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbHVnaW4uanMubWFwXG4iLCIvKipcbiogVG9tIFNlbGVjdCB2Mi40LjNcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiovXG5cbi8qKlxuICogUmV0dXJuIGEgZG9tIGVsZW1lbnQgZnJvbSBlaXRoZXIgYSBkb20gcXVlcnkgc3RyaW5nLCBqUXVlcnkgb2JqZWN0LCBhIGRvbSBlbGVtZW50IG9yIGh0bWwgc3RyaW5nXG4gKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80OTQxNDMvY3JlYXRpbmctYS1uZXctZG9tLWVsZW1lbnQtZnJvbS1hbi1odG1sLXN0cmluZy11c2luZy1idWlsdC1pbi1kb20tbWV0aG9kcy1vci1wcm8vMzUzODU1MTgjMzUzODU1MThcbiAqXG4gKiBwYXJhbSBxdWVyeSBzaG91bGQgYmUge31cbiAqL1xuY29uc3QgZ2V0RG9tID0gcXVlcnkgPT4ge1xuICBpZiAocXVlcnkuanF1ZXJ5KSB7XG4gICAgcmV0dXJuIHF1ZXJ5WzBdO1xuICB9XG4gIGlmIChxdWVyeSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgcmV0dXJuIHF1ZXJ5O1xuICB9XG4gIGlmIChpc0h0bWxTdHJpbmcocXVlcnkpKSB7XG4gICAgdmFyIHRwbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgdHBsLmlubmVySFRNTCA9IHF1ZXJ5LnRyaW0oKTsgLy8gTmV2ZXIgcmV0dXJuIGEgdGV4dCBub2RlIG9mIHdoaXRlc3BhY2UgYXMgdGhlIHJlc3VsdFxuICAgIHJldHVybiB0cGwuY29udGVudC5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHF1ZXJ5KTtcbn07XG5jb25zdCBpc0h0bWxTdHJpbmcgPSBhcmcgPT4ge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgJiYgYXJnLmluZGV4T2YoJzwnKSA+IC0xKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBQbHVnaW46IFwiZHJvcGRvd25faGVhZGVyXCIgKFRvbSBTZWxlY3QpXG4gKiBDb3B5cmlnaHQgKGMpIGNvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gcGx1Z2luICh1c2VyT3B0aW9ucykge1xuICBjb25zdCBzZWxmID0gdGhpcztcbiAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIGNsYXNzTmFtZTogJ2NsZWFyLWJ1dHRvbicsXG4gICAgdGl0bGU6ICdDbGVhciBBbGwnLFxuICAgIGh0bWw6IGRhdGEgPT4ge1xuICAgICAgcmV0dXJuIGA8ZGl2IGNsYXNzPVwiJHtkYXRhLmNsYXNzTmFtZX1cIiB0aXRsZT1cIiR7ZGF0YS50aXRsZX1cIj4mIzEwNzk5OzwvZGl2PmA7XG4gICAgfVxuICB9LCB1c2VyT3B0aW9ucyk7XG4gIHNlbGYub24oJ2luaXRpYWxpemUnLCAoKSA9PiB7XG4gICAgdmFyIGJ1dHRvbiA9IGdldERvbShvcHRpb25zLmh0bWwob3B0aW9ucykpO1xuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGV2dCA9PiB7XG4gICAgICBpZiAoc2VsZi5pc0xvY2tlZCkgcmV0dXJuO1xuICAgICAgc2VsZi5jbGVhcigpO1xuICAgICAgaWYgKHNlbGYuc2V0dGluZ3MubW9kZSA9PT0gJ3NpbmdsZScgJiYgc2VsZi5zZXR0aW5ncy5hbGxvd0VtcHR5T3B0aW9uKSB7XG4gICAgICAgIHNlbGYuYWRkSXRlbSgnJyk7XG4gICAgICB9XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9KTtcbiAgICBzZWxmLmNvbnRyb2wuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgfSk7XG59XG5cbmV4cG9ydCB7IHBsdWdpbiBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbHVnaW4uanMubWFwXG4iLCIvKipcbiogVG9tIFNlbGVjdCB2Mi40LjNcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiovXG5cbi8qKlxuICogQ29udmVydHMgYSBzY2FsYXIgdG8gaXRzIGJlc3Qgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gKiBmb3IgaGFzaCBrZXlzIGFuZCBIVE1MIGF0dHJpYnV0ZSB2YWx1ZXMuXG4gKlxuICogVHJhbnNmb3JtYXRpb25zOlxuICogICAnc3RyJyAgICAgLT4gJ3N0cidcbiAqICAgbnVsbCAgICAgIC0+ICcnXG4gKiAgIHVuZGVmaW5lZCAtPiAnJ1xuICogICB0cnVlICAgICAgLT4gJzEnXG4gKiAgIGZhbHNlICAgICAtPiAnMCdcbiAqICAgMCAgICAgICAgIC0+ICcwJ1xuICogICAxICAgICAgICAgLT4gJzEnXG4gKlxuICovXG5cbi8qKlxuICogUHJldmVudCBkZWZhdWx0XG4gKlxuICovXG5jb25zdCBwcmV2ZW50RGVmYXVsdCA9IChldnQsIHN0b3AgPSBmYWxzZSkgPT4ge1xuICBpZiAoZXZ0KSB7XG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKHN0b3ApIHtcbiAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQWRkIGV2ZW50IGhlbHBlclxuICpcbiAqL1xuY29uc3QgYWRkRXZlbnQgPSAodGFyZ2V0LCB0eXBlLCBjYWxsYmFjaywgb3B0aW9ucykgPT4ge1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgYXJyYXlzIGFuZCBoYXNoZXMuXG4gKlxuICogYGBgXG4gKiBpdGVyYXRlKHRoaXMuaXRlbXMsIGZ1bmN0aW9uKGl0ZW0sIGlkKSB7XG4gKiAgICAvLyBpbnZva2VkIGZvciBlYWNoIGl0ZW1cbiAqIH0pO1xuICogYGBgXG4gKlxuICovXG5jb25zdCBpdGVyYXRlID0gKG9iamVjdCwgY2FsbGJhY2spID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgIG9iamVjdC5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgY2FsbGJhY2sob2JqZWN0W2tleV0sIGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFJldHVybiBhIGRvbSBlbGVtZW50IGZyb20gZWl0aGVyIGEgZG9tIHF1ZXJ5IHN0cmluZywgalF1ZXJ5IG9iamVjdCwgYSBkb20gZWxlbWVudCBvciBodG1sIHN0cmluZ1xuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDk0MTQzL2NyZWF0aW5nLWEtbmV3LWRvbS1lbGVtZW50LWZyb20tYW4taHRtbC1zdHJpbmctdXNpbmctYnVpbHQtaW4tZG9tLW1ldGhvZHMtb3ItcHJvLzM1Mzg1NTE4IzM1Mzg1NTE4XG4gKlxuICogcGFyYW0gcXVlcnkgc2hvdWxkIGJlIHt9XG4gKi9cbmNvbnN0IGdldERvbSA9IHF1ZXJ5ID0+IHtcbiAgaWYgKHF1ZXJ5LmpxdWVyeSkge1xuICAgIHJldHVybiBxdWVyeVswXTtcbiAgfVxuICBpZiAocXVlcnkgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgIHJldHVybiBxdWVyeTtcbiAgfVxuICBpZiAoaXNIdG1sU3RyaW5nKHF1ZXJ5KSkge1xuICAgIHZhciB0cGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgIHRwbC5pbm5lckhUTUwgPSBxdWVyeS50cmltKCk7IC8vIE5ldmVyIHJldHVybiBhIHRleHQgbm9kZSBvZiB3aGl0ZXNwYWNlIGFzIHRoZSByZXN1bHRcbiAgICByZXR1cm4gdHBsLmNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgfVxuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihxdWVyeSk7XG59O1xuY29uc3QgaXNIdG1sU3RyaW5nID0gYXJnID0+IHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnICYmIGFyZy5pbmRleE9mKCc8JykgPiAtMSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2V0IGF0dHJpYnV0ZXMgb2YgYW4gZWxlbWVudFxuICpcbiAqL1xuY29uc3Qgc2V0QXR0ciA9IChlbCwgYXR0cnMpID0+IHtcbiAgaXRlcmF0ZShhdHRycywgKHZhbCwgYXR0cikgPT4ge1xuICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgJycgKyB2YWwpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIFBsdWdpbjogXCJkcmFnX2Ryb3BcIiAoVG9tIFNlbGVjdClcbiAqIENvcHlyaWdodCAoYykgY29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcbiAqIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG5jb25zdCBpbnNlcnRBZnRlciA9IChyZWZlcmVuY2VOb2RlLCBuZXdOb2RlKSA9PiB7XG4gIHZhciBfcmVmZXJlbmNlTm9kZSRwYXJlbnQ7XG4gIChfcmVmZXJlbmNlTm9kZSRwYXJlbnQgPSByZWZlcmVuY2VOb2RlLnBhcmVudE5vZGUpID09IG51bGwgfHwgX3JlZmVyZW5jZU5vZGUkcGFyZW50Lmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlLm5leHRTaWJsaW5nKTtcbn07XG5jb25zdCBpbnNlcnRCZWZvcmUgPSAocmVmZXJlbmNlTm9kZSwgbmV3Tm9kZSkgPT4ge1xuICB2YXIgX3JlZmVyZW5jZU5vZGUkcGFyZW50MjtcbiAgKF9yZWZlcmVuY2VOb2RlJHBhcmVudDIgPSByZWZlcmVuY2VOb2RlLnBhcmVudE5vZGUpID09IG51bGwgfHwgX3JlZmVyZW5jZU5vZGUkcGFyZW50Mi5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59O1xuY29uc3QgaXNCZWZvcmUgPSAocmVmZXJlbmNlTm9kZSwgbmV3Tm9kZSkgPT4ge1xuICBkbyB7XG4gICAgdmFyIF9uZXdOb2RlO1xuICAgIG5ld05vZGUgPSAoX25ld05vZGUgPSBuZXdOb2RlKSA9PSBudWxsID8gdm9pZCAwIDogX25ld05vZGUucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICBpZiAocmVmZXJlbmNlTm9kZSA9PSBuZXdOb2RlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gd2hpbGUgKG5ld05vZGUgJiYgbmV3Tm9kZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKTtcbiAgcmV0dXJuIGZhbHNlO1xufTtcbmZ1bmN0aW9uIHBsdWdpbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHNlbGYuc2V0dGluZ3MubW9kZSAhPT0gJ211bHRpJykgcmV0dXJuO1xuICB2YXIgb3JpZ19sb2NrID0gc2VsZi5sb2NrO1xuICB2YXIgb3JpZ191bmxvY2sgPSBzZWxmLnVubG9jaztcbiAgbGV0IHNvcnRhYmxlID0gdHJ1ZTtcbiAgbGV0IGRyYWdfaXRlbTtcblxuICAvKipcbiAgICogQWRkIGRyYWdnYWJsZSBhdHRyaWJ1dGUgdG8gaXRlbVxuICAgKi9cbiAgc2VsZi5ob29rKCdhZnRlcicsICdzZXR1cFRlbXBsYXRlcycsICgpID0+IHtcbiAgICB2YXIgb3JpZ19yZW5kZXJfaXRlbSA9IHNlbGYuc2V0dGluZ3MucmVuZGVyLml0ZW07XG4gICAgc2VsZi5zZXR0aW5ncy5yZW5kZXIuaXRlbSA9IChkYXRhLCBlc2NhcGUpID0+IHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBnZXREb20ob3JpZ19yZW5kZXJfaXRlbS5jYWxsKHNlbGYsIGRhdGEsIGVzY2FwZSkpO1xuICAgICAgc2V0QXR0cihpdGVtLCB7XG4gICAgICAgICdkcmFnZ2FibGUnOiAndHJ1ZSdcbiAgICAgIH0pO1xuXG4gICAgICAvLyBwcmV2ZW50IGRvY19tb3VzZWRvd24gKHNlZSB0b20tc2VsZWN0LnRzKVxuICAgICAgY29uc3QgbW91c2Vkb3duID0gZXZ0ID0+IHtcbiAgICAgICAgaWYgKCFzb3J0YWJsZSkgcHJldmVudERlZmF1bHQoZXZ0KTtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGRyYWdTdGFydCA9IGV2dCA9PiB7XG4gICAgICAgIGRyYWdfaXRlbSA9IGl0ZW07XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LmFkZCgndHMtZHJhZ2dpbmcnKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZHJhZ092ZXIgPSBldnQgPT4ge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKCd0cy1kcmFnLW92ZXInKTtcbiAgICAgICAgbW92ZWl0ZW0oaXRlbSwgZHJhZ19pdGVtKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBkcmFnTGVhdmUgPSAoKSA9PiB7XG4gICAgICAgIGl0ZW0uY2xhc3NMaXN0LnJlbW92ZSgndHMtZHJhZy1vdmVyJyk7XG4gICAgICB9O1xuICAgICAgY29uc3QgbW92ZWl0ZW0gPSAodGFyZ2V0aXRlbSwgZHJhZ2l0ZW0pID0+IHtcbiAgICAgICAgaWYgKGRyYWdpdGVtID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgICAgaWYgKGlzQmVmb3JlKGRyYWdpdGVtLCBpdGVtKSkge1xuICAgICAgICAgIGluc2VydEFmdGVyKHRhcmdldGl0ZW0sIGRyYWdpdGVtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnNlcnRCZWZvcmUodGFyZ2V0aXRlbSwgZHJhZ2l0ZW0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgZHJhZ2VuZCA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9kcmFnX2l0ZW07XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy50cy1kcmFnLW92ZXInKS5mb3JFYWNoKGVsID0+IGVsLmNsYXNzTGlzdC5yZW1vdmUoJ3RzLWRyYWctb3ZlcicpKTtcbiAgICAgICAgKF9kcmFnX2l0ZW0gPSBkcmFnX2l0ZW0pID09IG51bGwgfHwgX2RyYWdfaXRlbS5jbGFzc0xpc3QucmVtb3ZlKCd0cy1kcmFnZ2luZycpO1xuICAgICAgICBkcmFnX2l0ZW0gPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgc2VsZi5jb250cm9sLnF1ZXJ5U2VsZWN0b3JBbGwoYFtkYXRhLXZhbHVlXWApLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgIGlmIChlbC5kYXRhc2V0LnZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBlbC5kYXRhc2V0LnZhbHVlO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzZWxmLnNldFZhbHVlKHZhbHVlcyk7XG4gICAgICB9O1xuICAgICAgYWRkRXZlbnQoaXRlbSwgJ21vdXNlZG93bicsIG1vdXNlZG93bik7XG4gICAgICBhZGRFdmVudChpdGVtLCAnZHJhZ3N0YXJ0JywgZHJhZ1N0YXJ0KTtcbiAgICAgIGFkZEV2ZW50KGl0ZW0sICdkcmFnZW50ZXInLCBkcmFnT3Zlcik7XG4gICAgICBhZGRFdmVudChpdGVtLCAnZHJhZ292ZXInLCBkcmFnT3Zlcik7XG4gICAgICBhZGRFdmVudChpdGVtLCAnZHJhZ2xlYXZlJywgZHJhZ0xlYXZlKTtcbiAgICAgIGFkZEV2ZW50KGl0ZW0sICdkcmFnZW5kJywgZHJhZ2VuZCk7XG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9O1xuICB9KTtcbiAgc2VsZi5ob29rKCdpbnN0ZWFkJywgJ2xvY2snLCAoKSA9PiB7XG4gICAgc29ydGFibGUgPSBmYWxzZTtcbiAgICByZXR1cm4gb3JpZ19sb2NrLmNhbGwoc2VsZik7XG4gIH0pO1xuICBzZWxmLmhvb2soJ2luc3RlYWQnLCAndW5sb2NrJywgKCkgPT4ge1xuICAgIHNvcnRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gb3JpZ191bmxvY2suY2FsbChzZWxmKTtcbiAgfSk7XG59XG5cbmV4cG9ydCB7IHBsdWdpbiBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbHVnaW4uanMubWFwXG4iLCIvKipcbiogVG9tIFNlbGVjdCB2Mi40LjNcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiovXG5cbi8qKlxuICogQ29udmVydHMgYSBzY2FsYXIgdG8gaXRzIGJlc3Qgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gKiBmb3IgaGFzaCBrZXlzIGFuZCBIVE1MIGF0dHJpYnV0ZSB2YWx1ZXMuXG4gKlxuICogVHJhbnNmb3JtYXRpb25zOlxuICogICAnc3RyJyAgICAgLT4gJ3N0cidcbiAqICAgbnVsbCAgICAgIC0+ICcnXG4gKiAgIHVuZGVmaW5lZCAtPiAnJ1xuICogICB0cnVlICAgICAgLT4gJzEnXG4gKiAgIGZhbHNlICAgICAtPiAnMCdcbiAqICAgMCAgICAgICAgIC0+ICcwJ1xuICogICAxICAgICAgICAgLT4gJzEnXG4gKlxuICovXG5cbi8qKlxuICogUHJldmVudCBkZWZhdWx0XG4gKlxuICovXG5jb25zdCBwcmV2ZW50RGVmYXVsdCA9IChldnQsIHN0b3AgPSBmYWxzZSkgPT4ge1xuICBpZiAoZXZ0KSB7XG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKHN0b3ApIHtcbiAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJuIGEgZG9tIGVsZW1lbnQgZnJvbSBlaXRoZXIgYSBkb20gcXVlcnkgc3RyaW5nLCBqUXVlcnkgb2JqZWN0LCBhIGRvbSBlbGVtZW50IG9yIGh0bWwgc3RyaW5nXG4gKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80OTQxNDMvY3JlYXRpbmctYS1uZXctZG9tLWVsZW1lbnQtZnJvbS1hbi1odG1sLXN0cmluZy11c2luZy1idWlsdC1pbi1kb20tbWV0aG9kcy1vci1wcm8vMzUzODU1MTgjMzUzODU1MThcbiAqXG4gKiBwYXJhbSBxdWVyeSBzaG91bGQgYmUge31cbiAqL1xuY29uc3QgZ2V0RG9tID0gcXVlcnkgPT4ge1xuICBpZiAocXVlcnkuanF1ZXJ5KSB7XG4gICAgcmV0dXJuIHF1ZXJ5WzBdO1xuICB9XG4gIGlmIChxdWVyeSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgcmV0dXJuIHF1ZXJ5O1xuICB9XG4gIGlmIChpc0h0bWxTdHJpbmcocXVlcnkpKSB7XG4gICAgdmFyIHRwbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgdHBsLmlubmVySFRNTCA9IHF1ZXJ5LnRyaW0oKTsgLy8gTmV2ZXIgcmV0dXJuIGEgdGV4dCBub2RlIG9mIHdoaXRlc3BhY2UgYXMgdGhlIHJlc3VsdFxuICAgIHJldHVybiB0cGwuY29udGVudC5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHF1ZXJ5KTtcbn07XG5jb25zdCBpc0h0bWxTdHJpbmcgPSBhcmcgPT4ge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgJiYgYXJnLmluZGV4T2YoJzwnKSA+IC0xKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBQbHVnaW46IFwiZHJvcGRvd25faGVhZGVyXCIgKFRvbSBTZWxlY3QpXG4gKiBDb3B5cmlnaHQgKGMpIGNvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gcGx1Z2luICh1c2VyT3B0aW9ucykge1xuICBjb25zdCBzZWxmID0gdGhpcztcbiAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIHRpdGxlOiAnVW50aXRsZWQnLFxuICAgIGhlYWRlckNsYXNzOiAnZHJvcGRvd24taGVhZGVyJyxcbiAgICB0aXRsZVJvd0NsYXNzOiAnZHJvcGRvd24taGVhZGVyLXRpdGxlJyxcbiAgICBsYWJlbENsYXNzOiAnZHJvcGRvd24taGVhZGVyLWxhYmVsJyxcbiAgICBjbG9zZUNsYXNzOiAnZHJvcGRvd24taGVhZGVyLWNsb3NlJyxcbiAgICBodG1sOiBkYXRhID0+IHtcbiAgICAgIHJldHVybiAnPGRpdiBjbGFzcz1cIicgKyBkYXRhLmhlYWRlckNsYXNzICsgJ1wiPicgKyAnPGRpdiBjbGFzcz1cIicgKyBkYXRhLnRpdGxlUm93Q2xhc3MgKyAnXCI+JyArICc8c3BhbiBjbGFzcz1cIicgKyBkYXRhLmxhYmVsQ2xhc3MgKyAnXCI+JyArIGRhdGEudGl0bGUgKyAnPC9zcGFuPicgKyAnPGEgY2xhc3M9XCInICsgZGF0YS5jbG9zZUNsYXNzICsgJ1wiPiZ0aW1lczs8L2E+JyArICc8L2Rpdj4nICsgJzwvZGl2Pic7XG4gICAgfVxuICB9LCB1c2VyT3B0aW9ucyk7XG4gIHNlbGYub24oJ2luaXRpYWxpemUnLCAoKSA9PiB7XG4gICAgdmFyIGhlYWRlciA9IGdldERvbShvcHRpb25zLmh0bWwob3B0aW9ucykpO1xuICAgIHZhciBjbG9zZV9saW5rID0gaGVhZGVyLnF1ZXJ5U2VsZWN0b3IoJy4nICsgb3B0aW9ucy5jbG9zZUNsYXNzKTtcbiAgICBpZiAoY2xvc2VfbGluaykge1xuICAgICAgY2xvc2VfbGluay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGV2dCA9PiB7XG4gICAgICAgIHByZXZlbnREZWZhdWx0KGV2dCwgdHJ1ZSk7XG4gICAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBzZWxmLmRyb3Bkb3duLmluc2VydEJlZm9yZShoZWFkZXIsIHNlbGYuZHJvcGRvd24uZmlyc3RDaGlsZCk7XG4gIH0pO1xufVxuXG5leHBvcnQgeyBwbHVnaW4gYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGx1Z2luLmpzLm1hcFxuIiwiLyoqXG4qIFRvbSBTZWxlY3QgdjIuNC4zXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qL1xuXG5jb25zdCBLRVlfRVNDID0gMjc7XG5jb25zdCBLRVlfVEFCID0gOTtcbiAvLyBjdHJsIGtleSBvciBhcHBsZSBrZXkgZm9yIG1hXG5cbi8qKlxuICogQ29udmVydHMgYSBzY2FsYXIgdG8gaXRzIGJlc3Qgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gKiBmb3IgaGFzaCBrZXlzIGFuZCBIVE1MIGF0dHJpYnV0ZSB2YWx1ZXMuXG4gKlxuICogVHJhbnNmb3JtYXRpb25zOlxuICogICAnc3RyJyAgICAgLT4gJ3N0cidcbiAqICAgbnVsbCAgICAgIC0+ICcnXG4gKiAgIHVuZGVmaW5lZCAtPiAnJ1xuICogICB0cnVlICAgICAgLT4gJzEnXG4gKiAgIGZhbHNlICAgICAtPiAnMCdcbiAqICAgMCAgICAgICAgIC0+ICcwJ1xuICogICAxICAgICAgICAgLT4gJzEnXG4gKlxuICovXG5cbi8qKlxuICogUHJldmVudCBkZWZhdWx0XG4gKlxuICovXG5jb25zdCBwcmV2ZW50RGVmYXVsdCA9IChldnQsIHN0b3AgPSBmYWxzZSkgPT4ge1xuICBpZiAoZXZ0KSB7XG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKHN0b3ApIHtcbiAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQWRkIGV2ZW50IGhlbHBlclxuICpcbiAqL1xuY29uc3QgYWRkRXZlbnQgPSAodGFyZ2V0LCB0eXBlLCBjYWxsYmFjaywgb3B0aW9ucykgPT4ge1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgYXJyYXlzIGFuZCBoYXNoZXMuXG4gKlxuICogYGBgXG4gKiBpdGVyYXRlKHRoaXMuaXRlbXMsIGZ1bmN0aW9uKGl0ZW0sIGlkKSB7XG4gKiAgICAvLyBpbnZva2VkIGZvciBlYWNoIGl0ZW1cbiAqIH0pO1xuICogYGBgXG4gKlxuICovXG5jb25zdCBpdGVyYXRlID0gKG9iamVjdCwgY2FsbGJhY2spID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgIG9iamVjdC5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgY2FsbGJhY2sob2JqZWN0W2tleV0sIGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFJldHVybiBhIGRvbSBlbGVtZW50IGZyb20gZWl0aGVyIGEgZG9tIHF1ZXJ5IHN0cmluZywgalF1ZXJ5IG9iamVjdCwgYSBkb20gZWxlbWVudCBvciBodG1sIHN0cmluZ1xuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDk0MTQzL2NyZWF0aW5nLWEtbmV3LWRvbS1lbGVtZW50LWZyb20tYW4taHRtbC1zdHJpbmctdXNpbmctYnVpbHQtaW4tZG9tLW1ldGhvZHMtb3ItcHJvLzM1Mzg1NTE4IzM1Mzg1NTE4XG4gKlxuICogcGFyYW0gcXVlcnkgc2hvdWxkIGJlIHt9XG4gKi9cbmNvbnN0IGdldERvbSA9IHF1ZXJ5ID0+IHtcbiAgaWYgKHF1ZXJ5LmpxdWVyeSkge1xuICAgIHJldHVybiBxdWVyeVswXTtcbiAgfVxuICBpZiAocXVlcnkgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgIHJldHVybiBxdWVyeTtcbiAgfVxuICBpZiAoaXNIdG1sU3RyaW5nKHF1ZXJ5KSkge1xuICAgIHZhciB0cGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgIHRwbC5pbm5lckhUTUwgPSBxdWVyeS50cmltKCk7IC8vIE5ldmVyIHJldHVybiBhIHRleHQgbm9kZSBvZiB3aGl0ZXNwYWNlIGFzIHRoZSByZXN1bHRcbiAgICByZXR1cm4gdHBsLmNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgfVxuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihxdWVyeSk7XG59O1xuY29uc3QgaXNIdG1sU3RyaW5nID0gYXJnID0+IHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnICYmIGFyZy5pbmRleE9mKCc8JykgPiAtMSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQWRkIGNzcyBjbGFzc2VzXG4gKlxuICovXG5jb25zdCBhZGRDbGFzc2VzID0gKGVsbXRzLCAuLi5jbGFzc2VzKSA9PiB7XG4gIHZhciBub3JtX2NsYXNzZXMgPSBjbGFzc2VzQXJyYXkoY2xhc3Nlcyk7XG4gIGVsbXRzID0gY2FzdEFzQXJyYXkoZWxtdHMpO1xuICBlbG10cy5tYXAoZWwgPT4ge1xuICAgIG5vcm1fY2xhc3Nlcy5tYXAoY2xzID0+IHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybiBhcmd1bWVudHNcbiAqXG4gKi9cbmNvbnN0IGNsYXNzZXNBcnJheSA9IGFyZ3MgPT4ge1xuICB2YXIgY2xhc3NlcyA9IFtdO1xuICBpdGVyYXRlKGFyZ3MsIF9jbGFzc2VzID0+IHtcbiAgICBpZiAodHlwZW9mIF9jbGFzc2VzID09PSAnc3RyaW5nJykge1xuICAgICAgX2NsYXNzZXMgPSBfY2xhc3Nlcy50cmltKCkuc3BsaXQoL1tcXHRcXG5cXGZcXHJcXHNdLyk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KF9jbGFzc2VzKSkge1xuICAgICAgY2xhc3NlcyA9IGNsYXNzZXMuY29uY2F0KF9jbGFzc2VzKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY2xhc3Nlcy5maWx0ZXIoQm9vbGVhbik7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbiBhcnJheSBmcm9tIGFyZyBpZiBpdCdzIG5vdCBhbHJlYWR5IGFuIGFycmF5XG4gKlxuICovXG5jb25zdCBjYXN0QXNBcnJheSA9IGFyZyA9PiB7XG4gIGlmICghQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgYXJnID0gW2FyZ107XG4gIH1cbiAgcmV0dXJuIGFyZztcbn07XG5cbi8qKlxuICogUGx1Z2luOiBcImRyb3Bkb3duX2lucHV0XCIgKFRvbSBTZWxlY3QpXG4gKiBDb3B5cmlnaHQgKGMpIGNvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gcGx1Z2luICgpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIHNlbGYuc2V0dGluZ3Muc2hvdWxkT3BlbiA9IHRydWU7IC8vIG1ha2Ugc3VyZSB0aGUgaW5wdXQgaXMgc2hvd24gZXZlbiBpZiB0aGVyZSBhcmUgbm8gb3B0aW9ucyB0byBkaXNwbGF5IGluIHRoZSBkcm9wZG93blxuXG4gIHNlbGYuaG9vaygnYmVmb3JlJywgJ3NldHVwJywgKCkgPT4ge1xuICAgIHNlbGYuZm9jdXNfbm9kZSA9IHNlbGYuY29udHJvbDtcbiAgICBhZGRDbGFzc2VzKHNlbGYuY29udHJvbF9pbnB1dCwgJ2Ryb3Bkb3duLWlucHV0Jyk7XG4gICAgY29uc3QgZGl2ID0gZ2V0RG9tKCc8ZGl2IGNsYXNzPVwiZHJvcGRvd24taW5wdXQtd3JhcFwiPicpO1xuICAgIGRpdi5hcHBlbmQoc2VsZi5jb250cm9sX2lucHV0KTtcbiAgICBzZWxmLmRyb3Bkb3duLmluc2VydEJlZm9yZShkaXYsIHNlbGYuZHJvcGRvd24uZmlyc3RDaGlsZCk7XG5cbiAgICAvLyBzZXQgYSBwbGFjZWhvbGRlciBpbiB0aGUgc2VsZWN0IGNvbnRyb2xcbiAgICBjb25zdCBwbGFjZWhvbGRlciA9IGdldERvbSgnPGlucHV0IGNsYXNzPVwiaXRlbXMtcGxhY2Vob2xkZXJcIiB0YWJpbmRleD1cIi0xXCIgLz4nKTtcbiAgICBwbGFjZWhvbGRlci5wbGFjZWhvbGRlciA9IHNlbGYuc2V0dGluZ3MucGxhY2Vob2xkZXIgfHwgJyc7XG4gICAgc2VsZi5jb250cm9sLmFwcGVuZChwbGFjZWhvbGRlcik7XG4gIH0pO1xuICBzZWxmLm9uKCdpbml0aWFsaXplJywgKCkgPT4ge1xuICAgIC8vIHNldCB0YWJJbmRleCBvbiBjb250cm9sIHRvIC0xLCBvdGhlcndpc2UgW3NoaWZ0K3RhYl0gd2lsbCBwdXQgZm9jdXMgcmlnaHQgYmFjayBvbiBjb250cm9sX2lucHV0XG4gICAgc2VsZi5jb250cm9sX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBldnQgPT4ge1xuICAgICAgLy9hZGRFdmVudChzZWxmLmNvbnRyb2xfaW5wdXQsJ2tleWRvd24nIGFzIGNvbnN0LChldnQ6S2V5Ym9hcmRFdmVudCkgPT57XG4gICAgICBzd2l0Y2ggKGV2dC5rZXlDb2RlKSB7XG4gICAgICAgIGNhc2UgS0VZX0VTQzpcbiAgICAgICAgICBpZiAoc2VsZi5pc09wZW4pIHtcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGV2dCwgdHJ1ZSk7XG4gICAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYuY2xlYXJBY3RpdmVJdGVtcygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSBLRVlfVEFCOlxuICAgICAgICAgIHNlbGYuZm9jdXNfbm9kZS50YWJJbmRleCA9IC0xO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGYub25LZXlEb3duLmNhbGwoc2VsZiwgZXZ0KTtcbiAgICB9KTtcbiAgICBzZWxmLm9uKCdibHVyJywgKCkgPT4ge1xuICAgICAgc2VsZi5mb2N1c19ub2RlLnRhYkluZGV4ID0gc2VsZi5pc0Rpc2FibGVkID8gLTEgOiBzZWxmLnRhYkluZGV4O1xuICAgIH0pO1xuXG4gICAgLy8gZ2l2ZSB0aGUgY29udHJvbF9pbnB1dCBmb2N1cyB3aGVuIHRoZSBkcm9wZG93biBpcyBvcGVuXG4gICAgc2VsZi5vbignZHJvcGRvd25fb3BlbicsICgpID0+IHtcbiAgICAgIHNlbGYuY29udHJvbF9pbnB1dC5mb2N1cygpO1xuICAgIH0pO1xuXG4gICAgLy8gcHJldmVudCBvbkJsdXIgZnJvbSBjbG9zaW5nIHdoZW4gZm9jdXMgaXMgb24gdGhlIGNvbnRyb2xfaW5wdXRcbiAgICBjb25zdCBvcmlnX29uQmx1ciA9IHNlbGYub25CbHVyO1xuICAgIHNlbGYuaG9vaygnaW5zdGVhZCcsICdvbkJsdXInLCBldnQgPT4ge1xuICAgICAgaWYgKGV2dCAmJiBldnQucmVsYXRlZFRhcmdldCA9PSBzZWxmLmNvbnRyb2xfaW5wdXQpIHJldHVybjtcbiAgICAgIHJldHVybiBvcmlnX29uQmx1ci5jYWxsKHNlbGYpO1xuICAgIH0pO1xuICAgIGFkZEV2ZW50KHNlbGYuY29udHJvbF9pbnB1dCwgJ2JsdXInLCAoKSA9PiBzZWxmLm9uQmx1cigpKTtcblxuICAgIC8vIHJldHVybiBmb2N1cyB0byBjb250cm9sIHRvIGFsbG93IGZ1cnRoZXIga2V5Ym9hcmQgaW5wdXRcbiAgICBzZWxmLmhvb2soJ2JlZm9yZScsICdjbG9zZScsICgpID0+IHtcbiAgICAgIGlmICghc2VsZi5pc09wZW4pIHJldHVybjtcbiAgICAgIHNlbGYuZm9jdXNfbm9kZS5mb2N1cyh7XG4gICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0IHsgcGx1Z2luIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsdWdpbi5qcy5tYXBcbiIsIi8qKlxuKiBUb20gU2VsZWN0IHYyLjQuM1xuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKi9cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHNjYWxhciB0byBpdHMgYmVzdCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAqIGZvciBoYXNoIGtleXMgYW5kIEhUTUwgYXR0cmlidXRlIHZhbHVlcy5cbiAqXG4gKiBUcmFuc2Zvcm1hdGlvbnM6XG4gKiAgICdzdHInICAgICAtPiAnc3RyJ1xuICogICBudWxsICAgICAgLT4gJydcbiAqICAgdW5kZWZpbmVkIC0+ICcnXG4gKiAgIHRydWUgICAgICAtPiAnMSdcbiAqICAgZmFsc2UgICAgIC0+ICcwJ1xuICogICAwICAgICAgICAgLT4gJzAnXG4gKiAgIDEgICAgICAgICAtPiAnMSdcbiAqXG4gKi9cblxuLyoqXG4gKiBBZGQgZXZlbnQgaGVscGVyXG4gKlxuICovXG5jb25zdCBhZGRFdmVudCA9ICh0YXJnZXQsIHR5cGUsIGNhbGxiYWNrLCBvcHRpb25zKSA9PiB7XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogUGx1Z2luOiBcImlucHV0X2F1dG9ncm93XCIgKFRvbSBTZWxlY3QpXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcbiAqIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBwbHVnaW4gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYub24oJ2luaXRpYWxpemUnLCAoKSA9PiB7XG4gICAgdmFyIHRlc3RfaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgdmFyIGNvbnRyb2wgPSBzZWxmLmNvbnRyb2xfaW5wdXQ7XG4gICAgdGVzdF9pbnB1dC5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOmFic29sdXRlOyB0b3A6LTk5OTk5cHg7IGxlZnQ6LTk5OTk5cHg7IHdpZHRoOmF1dG87IHBhZGRpbmc6MDsgd2hpdGUtc3BhY2U6cHJlOyAnO1xuICAgIHNlbGYud3JhcHBlci5hcHBlbmRDaGlsZCh0ZXN0X2lucHV0KTtcbiAgICB2YXIgdHJhbnNmZXJfc3R5bGVzID0gWydsZXR0ZXJTcGFjaW5nJywgJ2ZvbnRTaXplJywgJ2ZvbnRGYW1pbHknLCAnZm9udFdlaWdodCcsICd0ZXh0VHJhbnNmb3JtJ107XG4gICAgZm9yIChjb25zdCBzdHlsZV9uYW1lIG9mIHRyYW5zZmVyX3N0eWxlcykge1xuICAgICAgLy8gQHRzLWlnbm9yZSBUUzcwMTUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzUwNTA2MTU0LzY5NzU3NlxuICAgICAgdGVzdF9pbnB1dC5zdHlsZVtzdHlsZV9uYW1lXSA9IGNvbnRyb2wuc3R5bGVbc3R5bGVfbmFtZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjb250cm9sIHdpZHRoXG4gICAgICpcbiAgICAgKi9cbiAgICB2YXIgcmVzaXplID0gKCkgPT4ge1xuICAgICAgdGVzdF9pbnB1dC50ZXh0Q29udGVudCA9IGNvbnRyb2wudmFsdWU7XG4gICAgICBjb250cm9sLnN0eWxlLndpZHRoID0gdGVzdF9pbnB1dC5jbGllbnRXaWR0aCArICdweCc7XG4gICAgfTtcbiAgICByZXNpemUoKTtcbiAgICBzZWxmLm9uKCd1cGRhdGUgaXRlbV9hZGQgaXRlbV9yZW1vdmUnLCByZXNpemUpO1xuICAgIGFkZEV2ZW50KGNvbnRyb2wsICdpbnB1dCcsIHJlc2l6ZSk7XG4gICAgYWRkRXZlbnQoY29udHJvbCwgJ2tleXVwJywgcmVzaXplKTtcbiAgICBhZGRFdmVudChjb250cm9sLCAnYmx1cicsIHJlc2l6ZSk7XG4gICAgYWRkRXZlbnQoY29udHJvbCwgJ3VwZGF0ZScsIHJlc2l6ZSk7XG4gIH0pO1xufVxuXG5leHBvcnQgeyBwbHVnaW4gYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGx1Z2luLmpzLm1hcFxuIiwiLyoqXG4qIFRvbSBTZWxlY3QgdjIuNC4zXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qL1xuXG4vKipcbiAqIFBsdWdpbjogXCJub19hY3RpdmVfaXRlbXNcIiAoVG9tIFNlbGVjdClcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuICogZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GXG4gKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbmZ1bmN0aW9uIHBsdWdpbiAoKSB7XG4gIHRoaXMuaG9vaygnaW5zdGVhZCcsICdzZXRBY3RpdmVJdGVtJywgKCkgPT4ge30pO1xuICB0aGlzLmhvb2soJ2luc3RlYWQnLCAnc2VsZWN0QWxsJywgKCkgPT4ge30pO1xufVxuXG5leHBvcnQgeyBwbHVnaW4gYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGx1Z2luLmpzLm1hcFxuIiwiLyoqXG4qIFRvbSBTZWxlY3QgdjIuNC4zXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qL1xuXG4vKipcbiAqIFBsdWdpbjogXCJpbnB1dF9hdXRvZ3Jvd1wiIChUb20gU2VsZWN0KVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gcGx1Z2luICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgb3JpZ19kZWxldGVTZWxlY3Rpb24gPSBzZWxmLmRlbGV0ZVNlbGVjdGlvbjtcbiAgdGhpcy5ob29rKCdpbnN0ZWFkJywgJ2RlbGV0ZVNlbGVjdGlvbicsIGV2dCA9PiB7XG4gICAgaWYgKHNlbGYuYWN0aXZlSXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gb3JpZ19kZWxldGVTZWxlY3Rpb24uY2FsbChzZWxmLCBldnQpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xufVxuXG5leHBvcnQgeyBwbHVnaW4gYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGx1Z2luLmpzLm1hcFxuIiwiLyoqXG4qIFRvbSBTZWxlY3QgdjIuNC4zXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qL1xuXG5jb25zdCBLRVlfTEVGVCA9IDM3O1xuY29uc3QgS0VZX1JJR0hUID0gMzk7XG4gLy8gY3RybCBrZXkgb3IgYXBwbGUga2V5IGZvciBtYVxuXG4vKipcbiAqIEdldCB0aGUgY2xvc2VzdCBub2RlIHRvIHRoZSBldnQudGFyZ2V0IG1hdGNoaW5nIHRoZSBzZWxlY3RvclxuICogU3RvcHMgYXQgd3JhcHBlclxuICpcbiAqL1xuY29uc3QgcGFyZW50TWF0Y2ggPSAodGFyZ2V0LCBzZWxlY3Rvciwgd3JhcHBlcikgPT4ge1xuICB3aGlsZSAodGFyZ2V0ICYmIHRhcmdldC5tYXRjaGVzKSB7XG4gICAgaWYgKHRhcmdldC5tYXRjaGVzKHNlbGVjdG9yKSkge1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBpbmRleCBvZiBhbiBlbGVtZW50IGFtb25nc3Qgc2libGluZyBub2RlcyBvZiB0aGUgc2FtZSB0eXBlXG4gKlxuICovXG5jb25zdCBub2RlSW5kZXggPSAoZWwsIGFtb25nc3QpID0+IHtcbiAgaWYgKCFlbCkgcmV0dXJuIC0xO1xuICBhbW9uZ3N0ID0gYW1vbmdzdCB8fCBlbC5ub2RlTmFtZTtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoZWwgPSBlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSB7XG4gICAgaWYgKGVsLm1hdGNoZXMoYW1vbmdzdCkpIHtcbiAgICAgIGkrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGk7XG59O1xuXG4vKipcbiAqIFBsdWdpbjogXCJvcHRncm91cF9jb2x1bW5zXCIgKFRvbSBTZWxlY3QuanMpXG4gKiBDb3B5cmlnaHQgKGMpIGNvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gcGx1Z2luICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgb3JpZ19rZXlkb3duID0gc2VsZi5vbktleURvd247XG4gIHNlbGYuaG9vaygnaW5zdGVhZCcsICdvbktleURvd24nLCBldnQgPT4ge1xuICAgIHZhciBpbmRleCwgb3B0aW9uLCBvcHRpb25zLCBvcHRncm91cDtcbiAgICBpZiAoIXNlbGYuaXNPcGVuIHx8ICEoZXZ0LmtleUNvZGUgPT09IEtFWV9MRUZUIHx8IGV2dC5rZXlDb2RlID09PSBLRVlfUklHSFQpKSB7XG4gICAgICByZXR1cm4gb3JpZ19rZXlkb3duLmNhbGwoc2VsZiwgZXZ0KTtcbiAgICB9XG4gICAgc2VsZi5pZ25vcmVIb3ZlciA9IHRydWU7XG4gICAgb3B0Z3JvdXAgPSBwYXJlbnRNYXRjaChzZWxmLmFjdGl2ZU9wdGlvbiwgJ1tkYXRhLWdyb3VwXScpO1xuICAgIGluZGV4ID0gbm9kZUluZGV4KHNlbGYuYWN0aXZlT3B0aW9uLCAnW2RhdGEtc2VsZWN0YWJsZV0nKTtcbiAgICBpZiAoIW9wdGdyb3VwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChldnQua2V5Q29kZSA9PT0gS0VZX0xFRlQpIHtcbiAgICAgIG9wdGdyb3VwID0gb3B0Z3JvdXAucHJldmlvdXNTaWJsaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRncm91cCA9IG9wdGdyb3VwLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICBpZiAoIW9wdGdyb3VwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRncm91cC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zZWxlY3RhYmxlXScpO1xuICAgIG9wdGlvbiA9IG9wdGlvbnNbTWF0aC5taW4ob3B0aW9ucy5sZW5ndGggLSAxLCBpbmRleCldO1xuICAgIGlmIChvcHRpb24pIHtcbiAgICAgIHNlbGYuc2V0QWN0aXZlT3B0aW9uKG9wdGlvbik7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IHsgcGx1Z2luIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsdWdpbi5qcy5tYXBcbiIsIi8qKlxuKiBUb20gU2VsZWN0IHYyLjQuM1xuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKi9cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHNjYWxhciB0byBpdHMgYmVzdCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAqIGZvciBoYXNoIGtleXMgYW5kIEhUTUwgYXR0cmlidXRlIHZhbHVlcy5cbiAqXG4gKiBUcmFuc2Zvcm1hdGlvbnM6XG4gKiAgICdzdHInICAgICAtPiAnc3RyJ1xuICogICBudWxsICAgICAgLT4gJydcbiAqICAgdW5kZWZpbmVkIC0+ICcnXG4gKiAgIHRydWUgICAgICAtPiAnMSdcbiAqICAgZmFsc2UgICAgIC0+ICcwJ1xuICogICAwICAgICAgICAgLT4gJzAnXG4gKiAgIDEgICAgICAgICAtPiAnMSdcbiAqXG4gKi9cblxuLyoqXG4gKiBFc2NhcGVzIGEgc3RyaW5nIGZvciB1c2Ugd2l0aGluIEhUTUwuXG4gKlxuICovXG5jb25zdCBlc2NhcGVfaHRtbCA9IHN0ciA9PiB7XG4gIHJldHVybiAoc3RyICsgJycpLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoLz4vZywgJyZndDsnKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG59O1xuXG4vKipcbiAqIFByZXZlbnQgZGVmYXVsdFxuICpcbiAqL1xuY29uc3QgcHJldmVudERlZmF1bHQgPSAoZXZ0LCBzdG9wID0gZmFsc2UpID0+IHtcbiAgaWYgKGV2dCkge1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmIChzdG9wKSB7XG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEFkZCBldmVudCBoZWxwZXJcbiAqXG4gKi9cbmNvbnN0IGFkZEV2ZW50ID0gKHRhcmdldCwgdHlwZSwgY2FsbGJhY2ssIG9wdGlvbnMpID0+IHtcbiAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2ssIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYSBkb20gZWxlbWVudCBmcm9tIGVpdGhlciBhIGRvbSBxdWVyeSBzdHJpbmcsIGpRdWVyeSBvYmplY3QsIGEgZG9tIGVsZW1lbnQgb3IgaHRtbCBzdHJpbmdcbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ5NDE0My9jcmVhdGluZy1hLW5ldy1kb20tZWxlbWVudC1mcm9tLWFuLWh0bWwtc3RyaW5nLXVzaW5nLWJ1aWx0LWluLWRvbS1tZXRob2RzLW9yLXByby8zNTM4NTUxOCMzNTM4NTUxOFxuICpcbiAqIHBhcmFtIHF1ZXJ5IHNob3VsZCBiZSB7fVxuICovXG5jb25zdCBnZXREb20gPSBxdWVyeSA9PiB7XG4gIGlmIChxdWVyeS5qcXVlcnkpIHtcbiAgICByZXR1cm4gcXVlcnlbMF07XG4gIH1cbiAgaWYgKHF1ZXJ5IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICByZXR1cm4gcXVlcnk7XG4gIH1cbiAgaWYgKGlzSHRtbFN0cmluZyhxdWVyeSkpIHtcbiAgICB2YXIgdHBsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICB0cGwuaW5uZXJIVE1MID0gcXVlcnkudHJpbSgpOyAvLyBOZXZlciByZXR1cm4gYSB0ZXh0IG5vZGUgb2Ygd2hpdGVzcGFjZSBhcyB0aGUgcmVzdWx0XG4gICAgcmV0dXJuIHRwbC5jb250ZW50LmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocXVlcnkpO1xufTtcbmNvbnN0IGlzSHRtbFN0cmluZyA9IGFyZyA9PiB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJyAmJiBhcmcuaW5kZXhPZignPCcpID4gLTEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFBsdWdpbjogXCJyZW1vdmVfYnV0dG9uXCIgKFRvbSBTZWxlY3QpXG4gKiBDb3B5cmlnaHQgKGMpIGNvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gcGx1Z2luICh1c2VyT3B0aW9ucykge1xuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgbGFiZWw6ICcmdGltZXM7JyxcbiAgICB0aXRsZTogJ1JlbW92ZScsXG4gICAgY2xhc3NOYW1lOiAncmVtb3ZlJyxcbiAgICBhcHBlbmQ6IHRydWVcbiAgfSwgdXNlck9wdGlvbnMpO1xuXG4gIC8vb3B0aW9ucy5jbGFzc05hbWUgPSAncmVtb3ZlLXNpbmdsZSc7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBvdmVycmlkZSB0aGUgcmVuZGVyIG1ldGhvZCB0byBhZGQgcmVtb3ZlIGJ1dHRvbiB0byBlYWNoIGl0ZW1cbiAgaWYgKCFvcHRpb25zLmFwcGVuZCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgaHRtbCA9ICc8YSBocmVmPVwiamF2YXNjcmlwdDp2b2lkKDApXCIgY2xhc3M9XCInICsgb3B0aW9ucy5jbGFzc05hbWUgKyAnXCIgdGFiaW5kZXg9XCItMVwiIHRpdGxlPVwiJyArIGVzY2FwZV9odG1sKG9wdGlvbnMudGl0bGUpICsgJ1wiPicgKyBvcHRpb25zLmxhYmVsICsgJzwvYT4nO1xuICBzZWxmLmhvb2soJ2FmdGVyJywgJ3NldHVwVGVtcGxhdGVzJywgKCkgPT4ge1xuICAgIHZhciBvcmlnX3JlbmRlcl9pdGVtID0gc2VsZi5zZXR0aW5ncy5yZW5kZXIuaXRlbTtcbiAgICBzZWxmLnNldHRpbmdzLnJlbmRlci5pdGVtID0gKGRhdGEsIGVzY2FwZSkgPT4ge1xuICAgICAgdmFyIGl0ZW0gPSBnZXREb20ob3JpZ19yZW5kZXJfaXRlbS5jYWxsKHNlbGYsIGRhdGEsIGVzY2FwZSkpO1xuICAgICAgdmFyIGNsb3NlX2J1dHRvbiA9IGdldERvbShodG1sKTtcbiAgICAgIGl0ZW0uYXBwZW5kQ2hpbGQoY2xvc2VfYnV0dG9uKTtcbiAgICAgIGFkZEV2ZW50KGNsb3NlX2J1dHRvbiwgJ21vdXNlZG93bicsIGV2dCA9PiB7XG4gICAgICAgIHByZXZlbnREZWZhdWx0KGV2dCwgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICAgIGFkZEV2ZW50KGNsb3NlX2J1dHRvbiwgJ2NsaWNrJywgZXZ0ID0+IHtcbiAgICAgICAgaWYgKHNlbGYuaXNMb2NrZWQpIHJldHVybjtcblxuICAgICAgICAvLyBwcm9wYWdhdGluZyB3aWxsIHRyaWdnZXIgdGhlIGRyb3Bkb3duIHRvIHNob3cgZm9yIHNpbmdsZSBtb2RlXG4gICAgICAgIHByZXZlbnREZWZhdWx0KGV2dCwgdHJ1ZSk7XG4gICAgICAgIGlmIChzZWxmLmlzTG9ja2VkKSByZXR1cm47XG4gICAgICAgIGlmICghc2VsZi5zaG91bGREZWxldGUoW2l0ZW1dLCBldnQpKSByZXR1cm47XG4gICAgICAgIHNlbGYucmVtb3ZlSXRlbShpdGVtKTtcbiAgICAgICAgc2VsZi5yZWZyZXNoT3B0aW9ucyhmYWxzZSk7XG4gICAgICAgIHNlbGYuaW5wdXRTdGF0ZSgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9O1xuICB9KTtcbn1cblxuZXhwb3J0IHsgcGx1Z2luIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsdWdpbi5qcy5tYXBcbiIsIi8qKlxuKiBUb20gU2VsZWN0IHYyLjQuM1xuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKi9cblxuLyoqXG4gKiBQbHVnaW46IFwicmVzdG9yZV9vbl9iYWNrc3BhY2VcIiAoVG9tIFNlbGVjdClcbiAqIENvcHlyaWdodCAoYykgY29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcbiAqIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBwbHVnaW4gKHVzZXJPcHRpb25zKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgdGV4dDogb3B0aW9uID0+IHtcbiAgICAgIHJldHVybiBvcHRpb25bc2VsZi5zZXR0aW5ncy5sYWJlbEZpZWxkXTtcbiAgICB9XG4gIH0sIHVzZXJPcHRpb25zKTtcbiAgc2VsZi5vbignaXRlbV9yZW1vdmUnLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoIXNlbGYuaXNGb2N1c2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzZWxmLmNvbnRyb2xfaW5wdXQudmFsdWUudHJpbSgpID09PSAnJykge1xuICAgICAgdmFyIG9wdGlvbiA9IHNlbGYub3B0aW9uc1t2YWx1ZV07XG4gICAgICBpZiAob3B0aW9uKSB7XG4gICAgICAgIHNlbGYuc2V0VGV4dGJveFZhbHVlKG9wdGlvbnMudGV4dC5jYWxsKHNlbGYsIG9wdGlvbikpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCB7IHBsdWdpbiBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbHVnaW4uanMubWFwXG4iLCIvKipcbiogVG9tIFNlbGVjdCB2Mi40LjNcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiovXG5cbi8qKlxuICogQ29udmVydHMgYSBzY2FsYXIgdG8gaXRzIGJlc3Qgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gKiBmb3IgaGFzaCBrZXlzIGFuZCBIVE1MIGF0dHJpYnV0ZSB2YWx1ZXMuXG4gKlxuICogVHJhbnNmb3JtYXRpb25zOlxuICogICAnc3RyJyAgICAgLT4gJ3N0cidcbiAqICAgbnVsbCAgICAgIC0+ICcnXG4gKiAgIHVuZGVmaW5lZCAtPiAnJ1xuICogICB0cnVlICAgICAgLT4gJzEnXG4gKiAgIGZhbHNlICAgICAtPiAnMCdcbiAqICAgMCAgICAgICAgIC0+ICcwJ1xuICogICAxICAgICAgICAgLT4gJzEnXG4gKlxuICovXG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBhcnJheXMgYW5kIGhhc2hlcy5cbiAqXG4gKiBgYGBcbiAqIGl0ZXJhdGUodGhpcy5pdGVtcywgZnVuY3Rpb24oaXRlbSwgaWQpIHtcbiAqICAgIC8vIGludm9rZWQgZm9yIGVhY2ggaXRlbVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKi9cbmNvbnN0IGl0ZXJhdGUgPSAob2JqZWN0LCBjYWxsYmFjaykgPT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgb2JqZWN0LmZvckVhY2goY2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBjYWxsYmFjayhvYmplY3Rba2V5XSwga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQWRkIGNzcyBjbGFzc2VzXG4gKlxuICovXG5jb25zdCBhZGRDbGFzc2VzID0gKGVsbXRzLCAuLi5jbGFzc2VzKSA9PiB7XG4gIHZhciBub3JtX2NsYXNzZXMgPSBjbGFzc2VzQXJyYXkoY2xhc3Nlcyk7XG4gIGVsbXRzID0gY2FzdEFzQXJyYXkoZWxtdHMpO1xuICBlbG10cy5tYXAoZWwgPT4ge1xuICAgIG5vcm1fY2xhc3Nlcy5tYXAoY2xzID0+IHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybiBhcmd1bWVudHNcbiAqXG4gKi9cbmNvbnN0IGNsYXNzZXNBcnJheSA9IGFyZ3MgPT4ge1xuICB2YXIgY2xhc3NlcyA9IFtdO1xuICBpdGVyYXRlKGFyZ3MsIF9jbGFzc2VzID0+IHtcbiAgICBpZiAodHlwZW9mIF9jbGFzc2VzID09PSAnc3RyaW5nJykge1xuICAgICAgX2NsYXNzZXMgPSBfY2xhc3Nlcy50cmltKCkuc3BsaXQoL1tcXHRcXG5cXGZcXHJcXHNdLyk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KF9jbGFzc2VzKSkge1xuICAgICAgY2xhc3NlcyA9IGNsYXNzZXMuY29uY2F0KF9jbGFzc2VzKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY2xhc3Nlcy5maWx0ZXIoQm9vbGVhbik7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbiBhcnJheSBmcm9tIGFyZyBpZiBpdCdzIG5vdCBhbHJlYWR5IGFuIGFycmF5XG4gKlxuICovXG5jb25zdCBjYXN0QXNBcnJheSA9IGFyZyA9PiB7XG4gIGlmICghQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgYXJnID0gW2FyZ107XG4gIH1cbiAgcmV0dXJuIGFyZztcbn07XG5cbi8qKlxuICogUGx1Z2luOiBcInJlc3RvcmVfb25fYmFja3NwYWNlXCIgKFRvbSBTZWxlY3QpXG4gKiBDb3B5cmlnaHQgKGMpIGNvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gcGx1Z2luICgpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIGNvbnN0IG9yaWdfY2FuTG9hZCA9IHNlbGYuY2FuTG9hZDtcbiAgY29uc3Qgb3JpZ19jbGVhckFjdGl2ZU9wdGlvbiA9IHNlbGYuY2xlYXJBY3RpdmVPcHRpb247XG4gIGNvbnN0IG9yaWdfbG9hZENhbGxiYWNrID0gc2VsZi5sb2FkQ2FsbGJhY2s7XG4gIHZhciBwYWdpbmF0aW9uID0ge307XG4gIHZhciBkcm9wZG93bl9jb250ZW50O1xuICB2YXIgbG9hZGluZ19tb3JlID0gZmFsc2U7XG4gIHZhciBsb2FkX21vcmVfb3B0O1xuICB2YXIgZGVmYXVsdF92YWx1ZXMgPSBbXTtcbiAgaWYgKCFzZWxmLnNldHRpbmdzLnNob3VsZExvYWRNb3JlKSB7XG4gICAgLy8gcmV0dXJuIHRydWUgaWYgYWRkaXRpb25hbCByZXN1bHRzIHNob3VsZCBiZSBsb2FkZWRcbiAgICBzZWxmLnNldHRpbmdzLnNob3VsZExvYWRNb3JlID0gKCkgPT4ge1xuICAgICAgY29uc3Qgc2Nyb2xsX3BlcmNlbnQgPSBkcm9wZG93bl9jb250ZW50LmNsaWVudEhlaWdodCAvIChkcm9wZG93bl9jb250ZW50LnNjcm9sbEhlaWdodCAtIGRyb3Bkb3duX2NvbnRlbnQuc2Nyb2xsVG9wKTtcbiAgICAgIGlmIChzY3JvbGxfcGVyY2VudCA+IDAuOSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLmFjdGl2ZU9wdGlvbikge1xuICAgICAgICB2YXIgc2VsZWN0YWJsZSA9IHNlbGYuc2VsZWN0YWJsZSgpO1xuICAgICAgICB2YXIgaW5kZXggPSBBcnJheS5mcm9tKHNlbGVjdGFibGUpLmluZGV4T2Yoc2VsZi5hY3RpdmVPcHRpb24pO1xuICAgICAgICBpZiAoaW5kZXggPj0gc2VsZWN0YWJsZS5sZW5ndGggLSAyKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICB9XG4gIGlmICghc2VsZi5zZXR0aW5ncy5maXJzdFVybCkge1xuICAgIHRocm93ICd2aXJ0dWFsX3Njcm9sbCBwbHVnaW4gcmVxdWlyZXMgYSBmaXJzdFVybCgpIG1ldGhvZCc7XG4gIH1cblxuICAvLyBpbiBvcmRlciBmb3IgdmlydHVhbCBzY3JvbGxpbmcgdG8gd29yayxcbiAgLy8gb3B0aW9ucyBuZWVkIHRvIGJlIG9yZGVyZWQgdGhlIHNhbWUgd2F5IHRoZXkncmUgcmV0dXJuZWQgZnJvbSB0aGUgcmVtb3RlIGRhdGEgc291cmNlXG4gIHNlbGYuc2V0dGluZ3Muc29ydEZpZWxkID0gW3tcbiAgICBmaWVsZDogJyRvcmRlcidcbiAgfSwge1xuICAgIGZpZWxkOiAnJHNjb3JlJ1xuICB9XTtcblxuICAvLyBjYW4gd2UgbG9hZCBtb3JlIHJlc3VsdHMgZm9yIGdpdmVuIHF1ZXJ5P1xuICBjb25zdCBjYW5Mb2FkTW9yZSA9IHF1ZXJ5ID0+IHtcbiAgICBpZiAodHlwZW9mIHNlbGYuc2V0dGluZ3MubWF4T3B0aW9ucyA9PT0gJ251bWJlcicgJiYgZHJvcGRvd25fY29udGVudC5jaGlsZHJlbi5sZW5ndGggPj0gc2VsZi5zZXR0aW5ncy5tYXhPcHRpb25zKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChxdWVyeSBpbiBwYWdpbmF0aW9uICYmIHBhZ2luYXRpb25bcXVlcnldKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBjb25zdCBjbGVhckZpbHRlciA9IChvcHRpb24sIHZhbHVlKSA9PiB7XG4gICAgaWYgKHNlbGYuaXRlbXMuaW5kZXhPZih2YWx1ZSkgPj0gMCB8fCBkZWZhdWx0X3ZhbHVlcy5pbmRleE9mKHZhbHVlKSA+PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIHNldCB0aGUgbmV4dCB1cmwgdGhhdCB3aWxsIGJlXG4gIHNlbGYuc2V0TmV4dFVybCA9ICh2YWx1ZSwgbmV4dF91cmwpID0+IHtcbiAgICBwYWdpbmF0aW9uW3ZhbHVlXSA9IG5leHRfdXJsO1xuICB9O1xuXG4gIC8vIGdldFVybCgpIHRvIGJlIHVzZWQgaW4gc2V0dGluZ3MubG9hZCgpXG4gIHNlbGYuZ2V0VXJsID0gcXVlcnkgPT4ge1xuICAgIGlmIChxdWVyeSBpbiBwYWdpbmF0aW9uKSB7XG4gICAgICBjb25zdCBuZXh0X3VybCA9IHBhZ2luYXRpb25bcXVlcnldO1xuICAgICAgcGFnaW5hdGlvbltxdWVyeV0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBuZXh0X3VybDtcbiAgICB9XG5cbiAgICAvLyBpZiB0aGUgdXNlciBnb2VzIGJhY2sgdG8gYSBwcmV2aW91cyBxdWVyeVxuICAgIC8vIHdlIG5lZWQgdG8gbG9hZCB0aGUgZmlyc3QgcGFnZSBhZ2FpblxuICAgIHNlbGYuY2xlYXJQYWdpbmF0aW9uKCk7XG4gICAgcmV0dXJuIHNlbGYuc2V0dGluZ3MuZmlyc3RVcmwuY2FsbChzZWxmLCBxdWVyeSk7XG4gIH07XG5cbiAgLy8gY2xlYXIgcGFnaW5hdGlvblxuICBzZWxmLmNsZWFyUGFnaW5hdGlvbiA9ICgpID0+IHtcbiAgICBwYWdpbmF0aW9uID0ge307XG4gIH07XG5cbiAgLy8gZG9uJ3QgY2xlYXIgdGhlIGFjdGl2ZSBvcHRpb24gKGFuZCBjYXVzZSB1bndhbnRlZCBkcm9wZG93biBzY3JvbGwpXG4gIC8vIHdoaWxlIGxvYWRpbmcgbW9yZSByZXN1bHRzXG4gIHNlbGYuaG9vaygnaW5zdGVhZCcsICdjbGVhckFjdGl2ZU9wdGlvbicsICgpID0+IHtcbiAgICBpZiAobG9hZGluZ19tb3JlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBvcmlnX2NsZWFyQWN0aXZlT3B0aW9uLmNhbGwoc2VsZik7XG4gIH0pO1xuXG4gIC8vIG92ZXJyaWRlIHRoZSBjYW5Mb2FkIG1ldGhvZFxuICBzZWxmLmhvb2soJ2luc3RlYWQnLCAnY2FuTG9hZCcsIHF1ZXJ5ID0+IHtcbiAgICAvLyBmaXJzdCB0aW1lIHRoZSBxdWVyeSBoYXMgYmVlbiBzZWVuXG4gICAgaWYgKCEocXVlcnkgaW4gcGFnaW5hdGlvbikpIHtcbiAgICAgIHJldHVybiBvcmlnX2NhbkxvYWQuY2FsbChzZWxmLCBxdWVyeSk7XG4gICAgfVxuICAgIHJldHVybiBjYW5Mb2FkTW9yZShxdWVyeSk7XG4gIH0pO1xuXG4gIC8vIHdyYXAgdGhlIGxvYWRcbiAgc2VsZi5ob29rKCdpbnN0ZWFkJywgJ2xvYWRDYWxsYmFjaycsIChvcHRpb25zLCBvcHRncm91cHMpID0+IHtcbiAgICBpZiAoIWxvYWRpbmdfbW9yZSkge1xuICAgICAgc2VsZi5jbGVhck9wdGlvbnMoY2xlYXJGaWx0ZXIpO1xuICAgIH0gZWxzZSBpZiAobG9hZF9tb3JlX29wdCkge1xuICAgICAgY29uc3QgZmlyc3Rfb3B0aW9uID0gb3B0aW9uc1swXTtcbiAgICAgIGlmIChmaXJzdF9vcHRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb2FkX21vcmVfb3B0LmRhdGFzZXQudmFsdWUgPSBmaXJzdF9vcHRpb25bc2VsZi5zZXR0aW5ncy52YWx1ZUZpZWxkXTtcbiAgICAgIH1cbiAgICB9XG4gICAgb3JpZ19sb2FkQ2FsbGJhY2suY2FsbChzZWxmLCBvcHRpb25zLCBvcHRncm91cHMpO1xuICAgIGxvYWRpbmdfbW9yZSA9IGZhbHNlO1xuICB9KTtcblxuICAvLyBhZGQgdGVtcGxhdGVzIHRvIGRyb3Bkb3duXG4gIC8vXHRsb2FkaW5nX21vcmUgaWYgd2UgaGF2ZSBhbm90aGVyIHVybCBpbiB0aGUgcXVldWVcbiAgLy9cdG5vX21vcmVfcmVzdWx0cyBpZiB3ZSBkb24ndCBoYXZlIGFub3RoZXIgdXJsIGluIHRoZSBxdWV1ZVxuICBzZWxmLmhvb2soJ2FmdGVyJywgJ3JlZnJlc2hPcHRpb25zJywgKCkgPT4ge1xuICAgIGNvbnN0IHF1ZXJ5ID0gc2VsZi5sYXN0VmFsdWU7XG4gICAgdmFyIG9wdGlvbjtcbiAgICBpZiAoY2FuTG9hZE1vcmUocXVlcnkpKSB7XG4gICAgICBvcHRpb24gPSBzZWxmLnJlbmRlcignbG9hZGluZ19tb3JlJywge1xuICAgICAgICBxdWVyeTogcXVlcnlcbiAgICAgIH0pO1xuICAgICAgaWYgKG9wdGlvbikge1xuICAgICAgICBvcHRpb24uc2V0QXR0cmlidXRlKCdkYXRhLXNlbGVjdGFibGUnLCAnJyk7IC8vIHNvIHRoYXQgbmF2aWdhdGluZyBkcm9wZG93biB3aXRoIFtkb3duXSBrZXlwcmVzc2VzIGNhbiBuYXZpZ2F0ZSB0byB0aGlzIG5vZGVcbiAgICAgICAgbG9hZF9tb3JlX29wdCA9IG9wdGlvbjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHF1ZXJ5IGluIHBhZ2luYXRpb24gJiYgIWRyb3Bkb3duX2NvbnRlbnQucXVlcnlTZWxlY3RvcignLm5vLXJlc3VsdHMnKSkge1xuICAgICAgb3B0aW9uID0gc2VsZi5yZW5kZXIoJ25vX21vcmVfcmVzdWx0cycsIHtcbiAgICAgICAgcXVlcnk6IHF1ZXJ5XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbikge1xuICAgICAgYWRkQ2xhc3NlcyhvcHRpb24sIHNlbGYuc2V0dGluZ3Mub3B0aW9uQ2xhc3MpO1xuICAgICAgZHJvcGRvd25fY29udGVudC5hcHBlbmQob3B0aW9uKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGFkZCBzY3JvbGwgbGlzdGVuZXIgYW5kIGRlZmF1bHQgdGVtcGxhdGVzXG4gIHNlbGYub24oJ2luaXRpYWxpemUnLCAoKSA9PiB7XG4gICAgZGVmYXVsdF92YWx1ZXMgPSBPYmplY3Qua2V5cyhzZWxmLm9wdGlvbnMpO1xuICAgIGRyb3Bkb3duX2NvbnRlbnQgPSBzZWxmLmRyb3Bkb3duX2NvbnRlbnQ7XG5cbiAgICAvLyBkZWZhdWx0IHRlbXBsYXRlc1xuICAgIHNlbGYuc2V0dGluZ3MucmVuZGVyID0gT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgbG9hZGluZ19tb3JlOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBgPGRpdiBjbGFzcz1cImxvYWRpbmctbW9yZS1yZXN1bHRzXCI+TG9hZGluZyBtb3JlIHJlc3VsdHMgLi4uIDwvZGl2PmA7XG4gICAgICB9LFxuICAgICAgbm9fbW9yZV9yZXN1bHRzOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBgPGRpdiBjbGFzcz1cIm5vLW1vcmUtcmVzdWx0c1wiPk5vIG1vcmUgcmVzdWx0czwvZGl2PmA7XG4gICAgICB9XG4gICAgfSwgc2VsZi5zZXR0aW5ncy5yZW5kZXIpO1xuXG4gICAgLy8gd2F0Y2ggZHJvcGRvd24gY29udGVudCBzY3JvbGwgcG9zaXRpb25cbiAgICBkcm9wZG93bl9jb250ZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsICgpID0+IHtcbiAgICAgIGlmICghc2VsZi5zZXR0aW5ncy5zaG91bGRMb2FkTW9yZS5jYWxsKHNlbGYpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gIWltcG9ydGFudDogdGhpcyB3aWxsIGdldCBjaGVja2VkIGFnYWluIGluIGxvYWQoKSBidXQgd2Ugc3RpbGwgbmVlZCB0byBjaGVjayBoZXJlIG90aGVyd2lzZSBsb2FkaW5nX21vcmUgd2lsbCBiZSBzZXQgdG8gdHJ1ZVxuICAgICAgaWYgKCFjYW5Mb2FkTW9yZShzZWxmLmxhc3RWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBkb24ndCBjYWxsIGxvYWQoKSB0b28gbXVjaFxuICAgICAgaWYgKGxvYWRpbmdfbW9yZSkgcmV0dXJuO1xuICAgICAgbG9hZGluZ19tb3JlID0gdHJ1ZTtcbiAgICAgIHNlbGYubG9hZC5jYWxsKHNlbGYsIHNlbGYubGFzdFZhbHVlKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydCB7IHBsdWdpbiBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbHVnaW4uanMubWFwXG4iLCJpbXBvcnQgVG9tU2VsZWN0IGZyb20gXCIuL3RvbS1zZWxlY3QuanNcIjtcbmltcG9ydCBjaGFuZ2VfbGlzdGVuZXIgZnJvbSBcIi4vcGx1Z2lucy9jaGFuZ2VfbGlzdGVuZXIvcGx1Z2luLmpzXCI7XG5pbXBvcnQgY2hlY2tib3hfb3B0aW9ucyBmcm9tIFwiLi9wbHVnaW5zL2NoZWNrYm94X29wdGlvbnMvcGx1Z2luLmpzXCI7XG5pbXBvcnQgY2xlYXJfYnV0dG9uIGZyb20gXCIuL3BsdWdpbnMvY2xlYXJfYnV0dG9uL3BsdWdpbi5qc1wiO1xuaW1wb3J0IGRyYWdfZHJvcCBmcm9tIFwiLi9wbHVnaW5zL2RyYWdfZHJvcC9wbHVnaW4uanNcIjtcbmltcG9ydCBkcm9wZG93bl9oZWFkZXIgZnJvbSBcIi4vcGx1Z2lucy9kcm9wZG93bl9oZWFkZXIvcGx1Z2luLmpzXCI7XG5pbXBvcnQgY2FyZXRfcG9zaXRpb24gZnJvbSBcIi4vcGx1Z2lucy9jYXJldF9wb3NpdGlvbi9wbHVnaW4uanNcIjtcbmltcG9ydCBkcm9wZG93bl9pbnB1dCBmcm9tIFwiLi9wbHVnaW5zL2Ryb3Bkb3duX2lucHV0L3BsdWdpbi5qc1wiO1xuaW1wb3J0IGlucHV0X2F1dG9ncm93IGZyb20gXCIuL3BsdWdpbnMvaW5wdXRfYXV0b2dyb3cvcGx1Z2luLmpzXCI7XG5pbXBvcnQgbm9fYmFja3NwYWNlX2RlbGV0ZSBmcm9tIFwiLi9wbHVnaW5zL25vX2JhY2tzcGFjZV9kZWxldGUvcGx1Z2luLmpzXCI7XG5pbXBvcnQgbm9fYWN0aXZlX2l0ZW1zIGZyb20gXCIuL3BsdWdpbnMvbm9fYWN0aXZlX2l0ZW1zL3BsdWdpbi5qc1wiO1xuaW1wb3J0IG9wdGdyb3VwX2NvbHVtbnMgZnJvbSBcIi4vcGx1Z2lucy9vcHRncm91cF9jb2x1bW5zL3BsdWdpbi5qc1wiO1xuaW1wb3J0IHJlbW92ZV9idXR0b24gZnJvbSBcIi4vcGx1Z2lucy9yZW1vdmVfYnV0dG9uL3BsdWdpbi5qc1wiO1xuaW1wb3J0IHJlc3RvcmVfb25fYmFja3NwYWNlIGZyb20gXCIuL3BsdWdpbnMvcmVzdG9yZV9vbl9iYWNrc3BhY2UvcGx1Z2luLmpzXCI7XG5pbXBvcnQgdmlydHVhbF9zY3JvbGwgZnJvbSBcIi4vcGx1Z2lucy92aXJ0dWFsX3Njcm9sbC9wbHVnaW4uanNcIjtcblRvbVNlbGVjdC5kZWZpbmUoJ2NoYW5nZV9saXN0ZW5lcicsIGNoYW5nZV9saXN0ZW5lcik7XG5Ub21TZWxlY3QuZGVmaW5lKCdjaGVja2JveF9vcHRpb25zJywgY2hlY2tib3hfb3B0aW9ucyk7XG5Ub21TZWxlY3QuZGVmaW5lKCdjbGVhcl9idXR0b24nLCBjbGVhcl9idXR0b24pO1xuVG9tU2VsZWN0LmRlZmluZSgnZHJhZ19kcm9wJywgZHJhZ19kcm9wKTtcblRvbVNlbGVjdC5kZWZpbmUoJ2Ryb3Bkb3duX2hlYWRlcicsIGRyb3Bkb3duX2hlYWRlcik7XG5Ub21TZWxlY3QuZGVmaW5lKCdjYXJldF9wb3NpdGlvbicsIGNhcmV0X3Bvc2l0aW9uKTtcblRvbVNlbGVjdC5kZWZpbmUoJ2Ryb3Bkb3duX2lucHV0JywgZHJvcGRvd25faW5wdXQpO1xuVG9tU2VsZWN0LmRlZmluZSgnaW5wdXRfYXV0b2dyb3cnLCBpbnB1dF9hdXRvZ3Jvdyk7XG5Ub21TZWxlY3QuZGVmaW5lKCdub19iYWNrc3BhY2VfZGVsZXRlJywgbm9fYmFja3NwYWNlX2RlbGV0ZSk7XG5Ub21TZWxlY3QuZGVmaW5lKCdub19hY3RpdmVfaXRlbXMnLCBub19hY3RpdmVfaXRlbXMpO1xuVG9tU2VsZWN0LmRlZmluZSgnb3B0Z3JvdXBfY29sdW1ucycsIG9wdGdyb3VwX2NvbHVtbnMpO1xuVG9tU2VsZWN0LmRlZmluZSgncmVtb3ZlX2J1dHRvbicsIHJlbW92ZV9idXR0b24pO1xuVG9tU2VsZWN0LmRlZmluZSgncmVzdG9yZV9vbl9iYWNrc3BhY2UnLCByZXN0b3JlX29uX2JhY2tzcGFjZSk7XG5Ub21TZWxlY3QuZGVmaW5lKCd2aXJ0dWFsX3Njcm9sbCcsIHZpcnR1YWxfc2Nyb2xsKTtcbmV4cG9ydCBkZWZhdWx0IFRvbVNlbGVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvbS1zZWxlY3QuY29tcGxldGUuanMubWFwIiwiaW1wb3J0IE1pY3JvRXZlbnQgZnJvbSBcIi4vY29udHJpYi9taWNyb2V2ZW50LmpzXCI7XG5pbXBvcnQgTWljcm9QbHVnaW4gZnJvbSBcIi4vY29udHJpYi9taWNyb3BsdWdpbi5qc1wiO1xuaW1wb3J0IHsgU2lmdGVyIH0gZnJvbSAnQG9yY2hpZGpzL3NpZnRlcic7XG5pbXBvcnQgeyBlc2NhcGVfcmVnZXggfSBmcm9tICdAb3JjaGlkanMvdW5pY29kZS12YXJpYW50cyc7XG5pbXBvcnQgeyBoaWdobGlnaHQsIHJlbW92ZUhpZ2hsaWdodCB9IGZyb20gXCIuL2NvbnRyaWIvaGlnaGxpZ2h0LmpzXCI7XG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSBcIi4vY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgZ2V0U2V0dGluZ3MgZnJvbSBcIi4vZ2V0U2V0dGluZ3MuanNcIjtcbmltcG9ydCB7IGhhc2hfa2V5LCBnZXRfaGFzaCwgZXNjYXBlX2h0bWwsIGRlYm91bmNlX2V2ZW50cywgZ2V0U2VsZWN0aW9uLCBwcmV2ZW50RGVmYXVsdCwgYWRkRXZlbnQsIGxvYWREZWJvdW5jZSwgdGltZW91dCwgaXNLZXlEb3duLCBnZXRJZCwgYWRkU2xhc2hlcywgYXBwZW5kLCBpdGVyYXRlIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IGdldERvbSwgaXNIdG1sU3RyaW5nLCBlc2NhcGVRdWVyeSwgdHJpZ2dlckV2ZW50LCBhcHBseUNTUywgYWRkQ2xhc3NlcywgcmVtb3ZlQ2xhc3NlcywgcGFyZW50TWF0Y2gsIGdldFRhaWwsIGlzRW1wdHlPYmplY3QsIG5vZGVJbmRleCwgc2V0QXR0ciwgcmVwbGFjZU5vZGUgfSBmcm9tIFwiLi92YW5pbGxhLmpzXCI7XG52YXIgaW5zdGFuY2VfaSA9IDA7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb21TZWxlY3QgZXh0ZW5kcyBNaWNyb1BsdWdpbihNaWNyb0V2ZW50KSB7XG4gICAgY29uc3RydWN0b3IoaW5wdXRfYXJnLCB1c2VyX3NldHRpbmdzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub3JkZXIgPSAwO1xuICAgICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1JlYWRPbmx5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNJbnZhbGlkID0gZmFsc2U7IC8vIEBkZXByZWNhdGVkIDEuOFxuICAgICAgICB0aGlzLmlzVmFsaWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzTG9ja2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNGb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNJbnB1dEhpZGRlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzU2V0dXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pZ25vcmVGb2N1cyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlnbm9yZUhvdmVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzT3B0aW9ucyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhc3RWYWx1ZSA9ICcnO1xuICAgICAgICB0aGlzLmNhcmV0UG9zID0gMDtcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gMDtcbiAgICAgICAgdGhpcy5sb2FkZWRTZWFyY2hlcyA9IHt9O1xuICAgICAgICB0aGlzLmFjdGl2ZU9wdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuYWN0aXZlSXRlbXMgPSBbXTtcbiAgICAgICAgdGhpcy5vcHRncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICAgIHRoaXMudXNlck9wdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgICAgICB0aGlzLnJlZnJlc2hUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaW5zdGFuY2VfaSsrO1xuICAgICAgICB2YXIgZGlyO1xuICAgICAgICB2YXIgaW5wdXQgPSBnZXREb20oaW5wdXRfYXJnKTtcbiAgICAgICAgaWYgKGlucHV0LnRvbXNlbGVjdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb20gU2VsZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWQgb24gdGhpcyBlbGVtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQudG9tc2VsZWN0ID0gdGhpcztcbiAgICAgICAgLy8gZGV0ZWN0IHJ0bCBlbnZpcm9ubWVudFxuICAgICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlICYmIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGlucHV0LCBudWxsKTtcbiAgICAgICAgZGlyID0gY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXJlY3Rpb24nKTtcbiAgICAgICAgLy8gc2V0dXAgZGVmYXVsdCBzdGF0ZVxuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGdldFNldHRpbmdzKGlucHV0LCB1c2VyX3NldHRpbmdzKTtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMudGFiSW5kZXggPSBpbnB1dC50YWJJbmRleCB8fCAwO1xuICAgICAgICB0aGlzLmlzX3NlbGVjdF90YWcgPSBpbnB1dC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzZWxlY3QnO1xuICAgICAgICB0aGlzLnJ0bCA9IC9ydGwvaS50ZXN0KGRpcik7XG4gICAgICAgIHRoaXMuaW5wdXRJZCA9IGdldElkKGlucHV0LCAndG9tc2VsZWN0LScgKyBpbnN0YW5jZV9pKTtcbiAgICAgICAgdGhpcy5pc1JlcXVpcmVkID0gaW5wdXQucmVxdWlyZWQ7XG4gICAgICAgIC8vIHNlYXJjaCBzeXN0ZW1cbiAgICAgICAgdGhpcy5zaWZ0ZXIgPSBuZXcgU2lmdGVyKHRoaXMub3B0aW9ucywgeyBkaWFjcml0aWNzOiBzZXR0aW5ncy5kaWFjcml0aWNzIH0pO1xuICAgICAgICAvLyBvcHRpb24tZGVwZW5kZW50IGRlZmF1bHRzXG4gICAgICAgIHNldHRpbmdzLm1vZGUgPSBzZXR0aW5ncy5tb2RlIHx8IChzZXR0aW5ncy5tYXhJdGVtcyA9PT0gMSA/ICdzaW5nbGUnIDogJ211bHRpJyk7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MuaGlkZVNlbGVjdGVkICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmhpZGVTZWxlY3RlZCA9IHNldHRpbmdzLm1vZGUgPT09ICdtdWx0aSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5oaWRlUGxhY2Vob2xkZXIgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgc2V0dGluZ3MuaGlkZVBsYWNlaG9sZGVyID0gc2V0dGluZ3MubW9kZSAhPT0gJ211bHRpJztcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgdXAgY3JlYXRlRmlsdGVyIGNhbGxiYWNrXG4gICAgICAgIHZhciBmaWx0ZXIgPSBzZXR0aW5ncy5jcmVhdGVGaWx0ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgZmlsdGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIgPSBuZXcgUmVnRXhwKGZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlsdGVyIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuY3JlYXRlRmlsdGVyID0gKGlucHV0KSA9PiBmaWx0ZXIudGVzdChpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5jcmVhdGVGaWx0ZXIgPSAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MuZHVwbGljYXRlcyB8fCAhdGhpcy5vcHRpb25zW3ZhbHVlXTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZVBsdWdpbnMoc2V0dGluZ3MucGx1Z2lucyk7XG4gICAgICAgIHRoaXMuc2V0dXBDYWxsYmFja3MoKTtcbiAgICAgICAgdGhpcy5zZXR1cFRlbXBsYXRlcygpO1xuICAgICAgICAvLyBDcmVhdGUgYWxsIGVsZW1lbnRzXG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSBnZXREb20oJzxkaXY+Jyk7XG4gICAgICAgIGNvbnN0IGNvbnRyb2wgPSBnZXREb20oJzxkaXY+Jyk7XG4gICAgICAgIGNvbnN0IGRyb3Bkb3duID0gdGhpcy5fcmVuZGVyKCdkcm9wZG93bicpO1xuICAgICAgICBjb25zdCBkcm9wZG93bl9jb250ZW50ID0gZ2V0RG9tKGA8ZGl2IHJvbGU9XCJsaXN0Ym94XCIgdGFiaW5kZXg9XCItMVwiPmApO1xuICAgICAgICBjb25zdCBjbGFzc2VzID0gdGhpcy5pbnB1dC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJyc7XG4gICAgICAgIGNvbnN0IGlucHV0TW9kZSA9IHNldHRpbmdzLm1vZGU7XG4gICAgICAgIHZhciBjb250cm9sX2lucHV0O1xuICAgICAgICBhZGRDbGFzc2VzKHdyYXBwZXIsIHNldHRpbmdzLndyYXBwZXJDbGFzcywgY2xhc3NlcywgaW5wdXRNb2RlKTtcbiAgICAgICAgYWRkQ2xhc3Nlcyhjb250cm9sLCBzZXR0aW5ncy5jb250cm9sQ2xhc3MpO1xuICAgICAgICBhcHBlbmQod3JhcHBlciwgY29udHJvbCk7XG4gICAgICAgIGFkZENsYXNzZXMoZHJvcGRvd24sIHNldHRpbmdzLmRyb3Bkb3duQ2xhc3MsIGlucHV0TW9kZSk7XG4gICAgICAgIGlmIChzZXR0aW5ncy5jb3B5Q2xhc3Nlc1RvRHJvcGRvd24pIHtcbiAgICAgICAgICAgIGFkZENsYXNzZXMoZHJvcGRvd24sIGNsYXNzZXMpO1xuICAgICAgICB9XG4gICAgICAgIGFkZENsYXNzZXMoZHJvcGRvd25fY29udGVudCwgc2V0dGluZ3MuZHJvcGRvd25Db250ZW50Q2xhc3MpO1xuICAgICAgICBhcHBlbmQoZHJvcGRvd24sIGRyb3Bkb3duX2NvbnRlbnQpO1xuICAgICAgICBnZXREb20oc2V0dGluZ3MuZHJvcGRvd25QYXJlbnQgfHwgd3JhcHBlcikuYXBwZW5kQ2hpbGQoZHJvcGRvd24pO1xuICAgICAgICAvLyBkZWZhdWx0IGNvbnRyb2xJbnB1dFxuICAgICAgICBpZiAoaXNIdG1sU3RyaW5nKHNldHRpbmdzLmNvbnRyb2xJbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbnRyb2xfaW5wdXQgPSBnZXREb20oc2V0dGluZ3MuY29udHJvbElucHV0KTtcbiAgICAgICAgICAgIC8vIHNldCBhdHRyaWJ1dGVzXG4gICAgICAgICAgICB2YXIgYXR0cnMgPSBbJ2F1dG9jb3JyZWN0JywgJ2F1dG9jYXBpdGFsaXplJywgJ2F1dG9jb21wbGV0ZScsICdzcGVsbGNoZWNrJ107XG4gICAgICAgICAgICBpdGVyYXRlKGF0dHJzLCAoYXR0cikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5nZXRBdHRyaWJ1dGUoYXR0cikpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0QXR0cihjb250cm9sX2lucHV0LCB7IFthdHRyXTogaW5wdXQuZ2V0QXR0cmlidXRlKGF0dHIpIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udHJvbF9pbnB1dC50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgY29udHJvbC5hcHBlbmRDaGlsZChjb250cm9sX2lucHV0KTtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNfbm9kZSA9IGNvbnRyb2xfaW5wdXQ7XG4gICAgICAgICAgICAvLyBkb20gZWxlbWVudFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNldHRpbmdzLmNvbnRyb2xJbnB1dCkge1xuICAgICAgICAgICAgY29udHJvbF9pbnB1dCA9IGdldERvbShzZXR0aW5ncy5jb250cm9sSW5wdXQpO1xuICAgICAgICAgICAgdGhpcy5mb2N1c19ub2RlID0gY29udHJvbF9pbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRyb2xfaW5wdXQgPSBnZXREb20oJzxpbnB1dC8+Jyk7XG4gICAgICAgICAgICB0aGlzLmZvY3VzX25vZGUgPSBjb250cm9sO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JhcHBlciA9IHdyYXBwZXI7XG4gICAgICAgIHRoaXMuZHJvcGRvd24gPSBkcm9wZG93bjtcbiAgICAgICAgdGhpcy5kcm9wZG93bl9jb250ZW50ID0gZHJvcGRvd25fY29udGVudDtcbiAgICAgICAgdGhpcy5jb250cm9sID0gY29udHJvbDtcbiAgICAgICAgdGhpcy5jb250cm9sX2lucHV0ID0gY29udHJvbF9pbnB1dDtcbiAgICAgICAgdGhpcy5zZXR1cCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzZXQgdXAgZXZlbnQgYmluZGluZ3MuXG4gICAgICpcbiAgICAgKi9cbiAgICBzZXR1cCgpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gc2VsZi5zZXR0aW5ncztcbiAgICAgICAgY29uc3QgY29udHJvbF9pbnB1dCA9IHNlbGYuY29udHJvbF9pbnB1dDtcbiAgICAgICAgY29uc3QgZHJvcGRvd24gPSBzZWxmLmRyb3Bkb3duO1xuICAgICAgICBjb25zdCBkcm9wZG93bl9jb250ZW50ID0gc2VsZi5kcm9wZG93bl9jb250ZW50O1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gc2VsZi53cmFwcGVyO1xuICAgICAgICBjb25zdCBjb250cm9sID0gc2VsZi5jb250cm9sO1xuICAgICAgICBjb25zdCBpbnB1dCA9IHNlbGYuaW5wdXQ7XG4gICAgICAgIGNvbnN0IGZvY3VzX25vZGUgPSBzZWxmLmZvY3VzX25vZGU7XG4gICAgICAgIGNvbnN0IHBhc3NpdmVfZXZlbnQgPSB7IHBhc3NpdmU6IHRydWUgfTtcbiAgICAgICAgY29uc3QgbGlzdGJveElkID0gc2VsZi5pbnB1dElkICsgJy10cy1kcm9wZG93bic7XG4gICAgICAgIHNldEF0dHIoZHJvcGRvd25fY29udGVudCwge1xuICAgICAgICAgICAgaWQ6IGxpc3Rib3hJZFxuICAgICAgICB9KTtcbiAgICAgICAgc2V0QXR0cihmb2N1c19ub2RlLCB7XG4gICAgICAgICAgICByb2xlOiAnY29tYm9ib3gnLFxuICAgICAgICAgICAgJ2FyaWEtaGFzcG9wdXAnOiAnbGlzdGJveCcsXG4gICAgICAgICAgICAnYXJpYS1leHBhbmRlZCc6ICdmYWxzZScsXG4gICAgICAgICAgICAnYXJpYS1jb250cm9scyc6IGxpc3Rib3hJZFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY29udHJvbF9pZCA9IGdldElkKGZvY3VzX25vZGUsIHNlbGYuaW5wdXRJZCArICctdHMtY29udHJvbCcpO1xuICAgICAgICBjb25zdCBxdWVyeSA9IFwibGFiZWxbZm9yPSdcIiArIGVzY2FwZVF1ZXJ5KHNlbGYuaW5wdXRJZCkgKyBcIiddXCI7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihxdWVyeSk7XG4gICAgICAgIGNvbnN0IGxhYmVsX2NsaWNrID0gc2VsZi5mb2N1cy5iaW5kKHNlbGYpO1xuICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgIGFkZEV2ZW50KGxhYmVsLCAnY2xpY2snLCBsYWJlbF9jbGljayk7XG4gICAgICAgICAgICBzZXRBdHRyKGxhYmVsLCB7IGZvcjogY29udHJvbF9pZCB9KTtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsX2lkID0gZ2V0SWQobGFiZWwsIHNlbGYuaW5wdXRJZCArICctdHMtbGFiZWwnKTtcbiAgICAgICAgICAgIHNldEF0dHIoZm9jdXNfbm9kZSwgeyAnYXJpYS1sYWJlbGxlZGJ5JzogbGFiZWxfaWQgfSk7XG4gICAgICAgICAgICBzZXRBdHRyKGRyb3Bkb3duX2NvbnRlbnQsIHsgJ2FyaWEtbGFiZWxsZWRieSc6IGxhYmVsX2lkIH0pO1xuICAgICAgICB9XG4gICAgICAgIHdyYXBwZXIuc3R5bGUud2lkdGggPSBpbnB1dC5zdHlsZS53aWR0aDtcbiAgICAgICAgaWYgKHNlbGYucGx1Z2lucy5uYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzZXNfcGx1Z2lucyA9ICdwbHVnaW4tJyArIHNlbGYucGx1Z2lucy5uYW1lcy5qb2luKCcgcGx1Z2luLScpO1xuICAgICAgICAgICAgYWRkQ2xhc3Nlcyhbd3JhcHBlciwgZHJvcGRvd25dLCBjbGFzc2VzX3BsdWdpbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc2V0dGluZ3MubWF4SXRlbXMgPT09IG51bGwgfHwgc2V0dGluZ3MubWF4SXRlbXMgPiAxKSAmJiBzZWxmLmlzX3NlbGVjdF90YWcpIHtcbiAgICAgICAgICAgIHNldEF0dHIoaW5wdXQsIHsgbXVsdGlwbGU6ICdtdWx0aXBsZScgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICBzZXRBdHRyKGNvbnRyb2xfaW5wdXQsIHsgcGxhY2Vob2xkZXI6IHNldHRpbmdzLnBsYWNlaG9sZGVyIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHNwbGl0T24gd2FzIG5vdCBwYXNzZWQgaW4sIGNvbnN0cnVjdCBpdCBmcm9tIHRoZSBkZWxpbWl0ZXIgdG8gYWxsb3cgcGFzdGluZyB1bml2ZXJzYWxseVxuICAgICAgICBpZiAoIXNldHRpbmdzLnNwbGl0T24gJiYgc2V0dGluZ3MuZGVsaW1pdGVyKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5zcGxpdE9uID0gbmV3IFJlZ0V4cCgnXFxcXHMqJyArIGVzY2FwZV9yZWdleChzZXR0aW5ncy5kZWxpbWl0ZXIpICsgJytcXFxccyonKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZWJvdW5jZSB1c2VyIGRlZmluZWQgbG9hZCgpIGlmIGxvYWRUaHJvdHRsZSA+IDBcbiAgICAgICAgLy8gYWZ0ZXIgaW5pdGlhbGl6ZVBsdWdpbnMoKSBzbyBwbHVnaW5zIGNhbiBjcmVhdGUvbW9kaWZ5IHVzZXIgZGVmaW5lZCBsb2FkZXJzXG4gICAgICAgIGlmIChzZXR0aW5ncy5sb2FkICYmIHNldHRpbmdzLmxvYWRUaHJvdHRsZSkge1xuICAgICAgICAgICAgc2V0dGluZ3MubG9hZCA9IGxvYWREZWJvdW5jZShzZXR0aW5ncy5sb2FkLCBzZXR0aW5ncy5sb2FkVGhyb3R0bGUpO1xuICAgICAgICB9XG4gICAgICAgIGFkZEV2ZW50KGRyb3Bkb3duLCAnbW91c2Vtb3ZlJywgKCkgPT4ge1xuICAgICAgICAgICAgc2VsZi5pZ25vcmVIb3ZlciA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgYWRkRXZlbnQoZHJvcGRvd24sICdtb3VzZWVudGVyJywgKGUpID0+IHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRfbWF0Y2ggPSBwYXJlbnRNYXRjaChlLnRhcmdldCwgJ1tkYXRhLXNlbGVjdGFibGVdJywgZHJvcGRvd24pO1xuICAgICAgICAgICAgaWYgKHRhcmdldF9tYXRjaClcbiAgICAgICAgICAgICAgICBzZWxmLm9uT3B0aW9uSG92ZXIoZSwgdGFyZ2V0X21hdGNoKTtcbiAgICAgICAgfSwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuICAgICAgICAvLyBjbGlja2luZyBvbiBhbiBvcHRpb24gc2hvdWxkIHNlbGVjdCBpdFxuICAgICAgICBhZGRFdmVudChkcm9wZG93biwgJ2NsaWNrJywgKGV2dCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uID0gcGFyZW50TWF0Y2goZXZ0LnRhcmdldCwgJ1tkYXRhLXNlbGVjdGFibGVdJyk7XG4gICAgICAgICAgICBpZiAob3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5vbk9wdGlvblNlbGVjdChldnQsIG9wdGlvbik7XG4gICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQoZXZ0LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGFkZEV2ZW50KGNvbnRyb2wsICdjbGljaycsIChldnQpID0+IHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRfbWF0Y2ggPSBwYXJlbnRNYXRjaChldnQudGFyZ2V0LCAnW2RhdGEtdHMtaXRlbV0nLCBjb250cm9sKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXRfbWF0Y2ggJiYgc2VsZi5vbkl0ZW1TZWxlY3QoZXZ0LCB0YXJnZXRfbWF0Y2gpKSB7XG4gICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQoZXZ0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXRhaW4gZm9jdXMgKHNlZSBjb250cm9sX2lucHV0IG1vdXNlZG93bilcbiAgICAgICAgICAgIGlmIChjb250cm9sX2lucHV0LnZhbHVlICE9ICcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5vbkNsaWNrKCk7XG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChldnQsIHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8ga2V5ZG93biBvbiBmb2N1c19ub2RlIGZvciBhcnJvd19kb3duL2Fycm93X3VwXG4gICAgICAgIGFkZEV2ZW50KGZvY3VzX25vZGUsICdrZXlkb3duJywgKGUpID0+IHNlbGYub25LZXlEb3duKGUpKTtcbiAgICAgICAgLy8ga2V5cHJlc3MgYW5kIGlucHV0L2tleXVwXG4gICAgICAgIGFkZEV2ZW50KGNvbnRyb2xfaW5wdXQsICdrZXlwcmVzcycsIChlKSA9PiBzZWxmLm9uS2V5UHJlc3MoZSkpO1xuICAgICAgICBhZGRFdmVudChjb250cm9sX2lucHV0LCAnaW5wdXQnLCAoZSkgPT4gc2VsZi5vbklucHV0KGUpKTtcbiAgICAgICAgYWRkRXZlbnQoZm9jdXNfbm9kZSwgJ2JsdXInLCAoZSkgPT4gc2VsZi5vbkJsdXIoZSkpO1xuICAgICAgICBhZGRFdmVudChmb2N1c19ub2RlLCAnZm9jdXMnLCAoZSkgPT4gc2VsZi5vbkZvY3VzKGUpKTtcbiAgICAgICAgYWRkRXZlbnQoY29udHJvbF9pbnB1dCwgJ3Bhc3RlJywgKGUpID0+IHNlbGYub25QYXN0ZShlKSk7XG4gICAgICAgIGNvbnN0IGRvY19tb3VzZWRvd24gPSAoZXZ0KSA9PiB7XG4gICAgICAgICAgICAvLyBibHVyIGlmIHRhcmdldCBpcyBvdXRzaWRlIG9mIHRoaXMgaW5zdGFuY2VcbiAgICAgICAgICAgIC8vIGRyb3Bkb3duIGlzIG5vdCBhbHdheXMgaW5zaWRlIHdyYXBwZXJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGV2dC5jb21wb3NlZFBhdGgoKVswXTtcbiAgICAgICAgICAgIGlmICghd3JhcHBlci5jb250YWlucyh0YXJnZXQpICYmICFkcm9wZG93bi5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuaXNGb2N1c2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYmx1cigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLmlucHV0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXRhaW4gZm9jdXMgYnkgcHJldmVudGluZyBuYXRpdmUgaGFuZGxpbmcuIGlmIHRoZVxuICAgICAgICAgICAgLy8gZXZlbnQgdGFyZ2V0IGlzIHRoZSBpbnB1dCBpdCBzaG91bGQgbm90IGJlIG1vZGlmaWVkLlxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCB0ZXh0IHNlbGVjdGlvbiB3aXRoaW4gdGhlIGlucHV0IHdvbid0IHdvcmsuXG4gICAgICAgICAgICAvLyBGaXhlcyBidWcgIzIxMiB3aGljaCBpcyBubyBjb3ZlcmVkIGJ5IHRlc3RzXG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09IGNvbnRyb2xfaW5wdXQgJiYgc2VsZi5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgLy8gY2xpY2tpbmcgYW55d2hlcmUgaW4gdGhlIGNvbnRyb2wgc2hvdWxkIG5vdCBibHVyIHRoZSBjb250cm9sX2lucHV0ICh3aGljaCB3b3VsZCBjbG9zZSB0aGUgZHJvcGRvd24pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChldnQsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB3aW5fc2Nyb2xsID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNlbGYuaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5wb3NpdGlvbkRyb3Bkb3duKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGFkZEV2ZW50KGRvY3VtZW50LCAnbW91c2Vkb3duJywgZG9jX21vdXNlZG93bik7XG4gICAgICAgIGFkZEV2ZW50KHdpbmRvdywgJ3Njcm9sbCcsIHdpbl9zY3JvbGwsIHBhc3NpdmVfZXZlbnQpO1xuICAgICAgICBhZGRFdmVudCh3aW5kb3csICdyZXNpemUnLCB3aW5fc2Nyb2xsLCBwYXNzaXZlX2V2ZW50KTtcbiAgICAgICAgdGhpcy5fZGVzdHJveSA9ICgpID0+IHtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGRvY19tb3VzZWRvd24pO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHdpbl9zY3JvbGwpO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHdpbl9zY3JvbGwpO1xuICAgICAgICAgICAgaWYgKGxhYmVsKVxuICAgICAgICAgICAgICAgIGxhYmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgbGFiZWxfY2xpY2spO1xuICAgICAgICB9O1xuICAgICAgICAvLyBzdG9yZSBvcmlnaW5hbCBodG1sIGFuZCB0YWIgaW5kZXggc28gdGhhdCB0aGV5IGNhbiBiZVxuICAgICAgICAvLyByZXN0b3JlZCB3aGVuIHRoZSBkZXN0cm95KCkgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICAgICAgdGhpcy5yZXZlcnRTZXR0aW5ncyA9IHtcbiAgICAgICAgICAgIGlubmVySFRNTDogaW5wdXQuaW5uZXJIVE1MLFxuICAgICAgICAgICAgdGFiSW5kZXg6IGlucHV0LnRhYkluZGV4XG4gICAgICAgIH07XG4gICAgICAgIGlucHV0LnRhYkluZGV4ID0gLTE7XG4gICAgICAgIGlucHV0Lmluc2VydEFkamFjZW50RWxlbWVudCgnYWZ0ZXJlbmQnLCBzZWxmLndyYXBwZXIpO1xuICAgICAgICBzZWxmLnN5bmMoZmFsc2UpO1xuICAgICAgICBzZXR0aW5ncy5pdGVtcyA9IFtdO1xuICAgICAgICBkZWxldGUgc2V0dGluZ3Mub3B0Z3JvdXBzO1xuICAgICAgICBkZWxldGUgc2V0dGluZ3Mub3B0aW9ucztcbiAgICAgICAgYWRkRXZlbnQoaW5wdXQsICdpbnZhbGlkJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNlbGYuaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIHNlbGYuaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHNlbGYuaXNJbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzZWxmLnJlZnJlc2hTdGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2VsZi51cGRhdGVPcmlnaW5hbElucHV0KCk7XG4gICAgICAgIHNlbGYucmVmcmVzaEl0ZW1zKCk7XG4gICAgICAgIHNlbGYuY2xvc2UoZmFsc2UpO1xuICAgICAgICBzZWxmLmlucHV0U3RhdGUoKTtcbiAgICAgICAgc2VsZi5pc1NldHVwID0gdHJ1ZTtcbiAgICAgICAgaWYgKGlucHV0LmRpc2FibGVkKSB7XG4gICAgICAgICAgICBzZWxmLmRpc2FibGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnB1dC5yZWFkT25seSkge1xuICAgICAgICAgICAgc2VsZi5zZXRSZWFkT25seSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuZW5hYmxlKCk7IC8vc2V0cyB0YWJJbmRleFxuICAgICAgICB9XG4gICAgICAgIHNlbGYub24oJ2NoYW5nZScsIHRoaXMub25DaGFuZ2UpO1xuICAgICAgICBhZGRDbGFzc2VzKGlucHV0LCAndG9tc2VsZWN0ZWQnLCAndHMtaGlkZGVuLWFjY2Vzc2libGUnKTtcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdpbml0aWFsaXplJyk7XG4gICAgICAgIC8vIHByZWxvYWQgb3B0aW9uc1xuICAgICAgICBpZiAoc2V0dGluZ3MucHJlbG9hZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgc2VsZi5wcmVsb2FkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgb3B0aW9ucyBhbmQgb3B0Z3JvdXBzXG4gICAgICpcbiAgICAgKi9cbiAgICBzZXR1cE9wdGlvbnMob3B0aW9ucyA9IFtdLCBvcHRncm91cHMgPSBbXSkge1xuICAgICAgICAvLyBidWlsZCBvcHRpb25zIHRhYmxlXG4gICAgICAgIHRoaXMuYWRkT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgLy8gYnVpbGQgb3B0Z3JvdXAgdGFibGVcbiAgICAgICAgaXRlcmF0ZShvcHRncm91cHMsIChvcHRncm91cCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlck9wdGlvbkdyb3VwKG9wdGdyb3VwKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgZGVmYXVsdCByZW5kZXJpbmcgZnVuY3Rpb25zLlxuICAgICAqL1xuICAgIHNldHVwVGVtcGxhdGVzKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBmaWVsZF9sYWJlbCA9IHNlbGYuc2V0dGluZ3MubGFiZWxGaWVsZDtcbiAgICAgICAgdmFyIGZpZWxkX29wdGdyb3VwID0gc2VsZi5zZXR0aW5ncy5vcHRncm91cExhYmVsRmllbGQ7XG4gICAgICAgIHZhciB0ZW1wbGF0ZXMgPSB7XG4gICAgICAgICAgICAnb3B0Z3JvdXAnOiAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBvcHRncm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgIG9wdGdyb3VwLmNsYXNzTmFtZSA9ICdvcHRncm91cCc7XG4gICAgICAgICAgICAgICAgb3B0Z3JvdXAuYXBwZW5kQ2hpbGQoZGF0YS5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0Z3JvdXA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ29wdGdyb3VwX2hlYWRlcic6IChkYXRhLCBlc2NhcGUpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJzxkaXYgY2xhc3M9XCJvcHRncm91cC1oZWFkZXJcIj4nICsgZXNjYXBlKGRhdGFbZmllbGRfb3B0Z3JvdXBdKSArICc8L2Rpdj4nO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdvcHRpb24nOiAoZGF0YSwgZXNjYXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICc8ZGl2PicgKyBlc2NhcGUoZGF0YVtmaWVsZF9sYWJlbF0pICsgJzwvZGl2Pic7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2l0ZW0nOiAoZGF0YSwgZXNjYXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICc8ZGl2PicgKyBlc2NhcGUoZGF0YVtmaWVsZF9sYWJlbF0pICsgJzwvZGl2Pic7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ29wdGlvbl9jcmVhdGUnOiAoZGF0YSwgZXNjYXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICc8ZGl2IGNsYXNzPVwiY3JlYXRlXCI+QWRkIDxzdHJvbmc+JyArIGVzY2FwZShkYXRhLmlucHV0KSArICc8L3N0cm9uZz4maGVsbGlwOzwvZGl2Pic7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ25vX3Jlc3VsdHMnOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICc8ZGl2IGNsYXNzPVwibm8tcmVzdWx0c1wiPk5vIHJlc3VsdHMgZm91bmQ8L2Rpdj4nO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdsb2FkaW5nJzogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAnPGRpdiBjbGFzcz1cInNwaW5uZXJcIj48L2Rpdj4nO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdub3RfbG9hZGluZyc6ICgpID0+IHsgfSxcbiAgICAgICAgICAgICdkcm9wZG93bic6ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJzxkaXY+PC9kaXY+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5zZXR0aW5ncy5yZW5kZXIgPSBPYmplY3QuYXNzaWduKHt9LCB0ZW1wbGF0ZXMsIHNlbGYuc2V0dGluZ3MucmVuZGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFwcyBmaXJlZCBldmVudHMgdG8gY2FsbGJhY2tzIHByb3ZpZGVkXG4gICAgICogaW4gdGhlIHNldHRpbmdzIHVzZWQgd2hlbiBjcmVhdGluZyB0aGUgY29udHJvbC5cbiAgICAgKi9cbiAgICBzZXR1cENhbGxiYWNrcygpIHtcbiAgICAgICAgdmFyIGtleSwgZm47XG4gICAgICAgIHZhciBjYWxsYmFja3MgPSB7XG4gICAgICAgICAgICAnaW5pdGlhbGl6ZSc6ICdvbkluaXRpYWxpemUnLFxuICAgICAgICAgICAgJ2NoYW5nZSc6ICdvbkNoYW5nZScsXG4gICAgICAgICAgICAnaXRlbV9hZGQnOiAnb25JdGVtQWRkJyxcbiAgICAgICAgICAgICdpdGVtX3JlbW92ZSc6ICdvbkl0ZW1SZW1vdmUnLFxuICAgICAgICAgICAgJ2l0ZW1fc2VsZWN0JzogJ29uSXRlbVNlbGVjdCcsXG4gICAgICAgICAgICAnY2xlYXInOiAnb25DbGVhcicsXG4gICAgICAgICAgICAnb3B0aW9uX2FkZCc6ICdvbk9wdGlvbkFkZCcsXG4gICAgICAgICAgICAnb3B0aW9uX3JlbW92ZSc6ICdvbk9wdGlvblJlbW92ZScsXG4gICAgICAgICAgICAnb3B0aW9uX2NsZWFyJzogJ29uT3B0aW9uQ2xlYXInLFxuICAgICAgICAgICAgJ29wdGdyb3VwX2FkZCc6ICdvbk9wdGlvbkdyb3VwQWRkJyxcbiAgICAgICAgICAgICdvcHRncm91cF9yZW1vdmUnOiAnb25PcHRpb25Hcm91cFJlbW92ZScsXG4gICAgICAgICAgICAnb3B0Z3JvdXBfY2xlYXInOiAnb25PcHRpb25Hcm91cENsZWFyJyxcbiAgICAgICAgICAgICdkcm9wZG93bl9vcGVuJzogJ29uRHJvcGRvd25PcGVuJyxcbiAgICAgICAgICAgICdkcm9wZG93bl9jbG9zZSc6ICdvbkRyb3Bkb3duQ2xvc2UnLFxuICAgICAgICAgICAgJ3R5cGUnOiAnb25UeXBlJyxcbiAgICAgICAgICAgICdsb2FkJzogJ29uTG9hZCcsXG4gICAgICAgICAgICAnZm9jdXMnOiAnb25Gb2N1cycsXG4gICAgICAgICAgICAnYmx1cic6ICdvbkJsdXInXG4gICAgICAgIH07XG4gICAgICAgIGZvciAoa2V5IGluIGNhbGxiYWNrcykge1xuICAgICAgICAgICAgZm4gPSB0aGlzLnNldHRpbmdzW2NhbGxiYWNrc1trZXldXTtcbiAgICAgICAgICAgIGlmIChmbilcbiAgICAgICAgICAgICAgICB0aGlzLm9uKGtleSwgZm4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN5bmMgdGhlIFRvbSBTZWxlY3QgaW5zdGFuY2Ugd2l0aCB0aGUgb3JpZ2luYWwgaW5wdXQgb3Igc2VsZWN0XG4gICAgICpcbiAgICAgKi9cbiAgICBzeW5jKGdldF9zZXR0aW5ncyA9IHRydWUpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gZ2V0X3NldHRpbmdzID8gZ2V0U2V0dGluZ3Moc2VsZi5pbnB1dCwgeyBkZWxpbWl0ZXI6IHNlbGYuc2V0dGluZ3MuZGVsaW1pdGVyIH0pIDogc2VsZi5zZXR0aW5ncztcbiAgICAgICAgc2VsZi5zZXR1cE9wdGlvbnMoc2V0dGluZ3Mub3B0aW9ucywgc2V0dGluZ3Mub3B0Z3JvdXBzKTtcbiAgICAgICAgc2VsZi5zZXRWYWx1ZShzZXR0aW5ncy5pdGVtcyB8fCBbXSwgdHJ1ZSk7IC8vIHNpbGVudCBwcmV2ZW50cyByZWN1cnNpb25cbiAgICAgICAgc2VsZi5sYXN0UXVlcnkgPSBudWxsOyAvLyBzbyB1cGRhdGVkIG9wdGlvbnMgd2lsbCBiZSBkaXNwbGF5ZWQgaW4gZHJvcGRvd25cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gdGhlIG1haW4gY29udHJvbCBlbGVtZW50XG4gICAgICogaGFzIGEgY2xpY2sgZXZlbnQuXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNsaWNrKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChzZWxmLmFjdGl2ZUl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHNlbGYuY2xlYXJBY3RpdmVJdGVtcygpO1xuICAgICAgICAgICAgc2VsZi5mb2N1cygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLmlzRm9jdXNlZCAmJiBzZWxmLmlzT3Blbikge1xuICAgICAgICAgICAgc2VsZi5ibHVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgdjEuN1xuICAgICAqXG4gICAgICovXG4gICAgb25Nb3VzZURvd24oKSB7IH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiB0aGUgdmFsdWUgb2YgdGhlIGNvbnRyb2wgaGFzIGJlZW4gY2hhbmdlZC5cbiAgICAgKiBUaGlzIHNob3VsZCBwcm9wYWdhdGUgdGhlIGV2ZW50IHRvIHRoZSBvcmlnaW5hbCBET01cbiAgICAgKiBpbnB1dCAvIHNlbGVjdCBlbGVtZW50LlxuICAgICAqL1xuICAgIG9uQ2hhbmdlKCkge1xuICAgICAgICB0cmlnZ2VyRXZlbnQodGhpcy5pbnB1dCwgJ2lucHV0Jyk7XG4gICAgICAgIHRyaWdnZXJFdmVudCh0aGlzLmlucHV0LCAnY2hhbmdlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBvbiA8aW5wdXQ+IHBhc3RlLlxuICAgICAqXG4gICAgICovXG4gICAgb25QYXN0ZShlKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKHNlbGYuaXNJbnB1dEhpZGRlbiB8fCBzZWxmLmlzTG9ja2VkKSB7XG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhIHJlZ2V4IG9yIHN0cmluZyBpcyBpbmNsdWRlZCwgdGhpcyB3aWxsIHNwbGl0IHRoZSBwYXN0ZWRcbiAgICAgICAgLy8gaW5wdXQgYW5kIGNyZWF0ZSBJdGVtcyBmb3IgZWFjaCBzZXBhcmF0ZSB2YWx1ZVxuICAgICAgICBpZiAoIXNlbGYuc2V0dGluZ3Muc3BsaXRPbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdhaXQgZm9yIHBhc3RlZCB0ZXh0IHRvIGJlIHJlY29nbml6ZWQgaW4gdmFsdWVcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB2YXIgcGFzdGVkVGV4dCA9IHNlbGYuaW5wdXRWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKCFwYXN0ZWRUZXh0Lm1hdGNoKHNlbGYuc2V0dGluZ3Muc3BsaXRPbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3BsaXRJbnB1dCA9IHBhc3RlZFRleHQudHJpbSgpLnNwbGl0KHNlbGYuc2V0dGluZ3Muc3BsaXRPbik7XG4gICAgICAgICAgICBpdGVyYXRlKHNwbGl0SW5wdXQsIChwaWVjZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBoYXNoX2tleShwaWVjZSk7XG4gICAgICAgICAgICAgICAgaWYgKGhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc1twaWVjZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYWRkSXRlbShwaWVjZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNyZWF0ZUl0ZW0ocGllY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgb24gPGlucHV0PiBrZXlwcmVzcy5cbiAgICAgKlxuICAgICAqL1xuICAgIG9uS2V5UHJlc3MoZSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChzZWxmLmlzTG9ja2VkKSB7XG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhcmFjdGVyID0gU3RyaW5nLmZyb21DaGFyQ29kZShlLmtleUNvZGUgfHwgZS53aGljaCk7XG4gICAgICAgIGlmIChzZWxmLnNldHRpbmdzLmNyZWF0ZSAmJiBzZWxmLnNldHRpbmdzLm1vZGUgPT09ICdtdWx0aScgJiYgY2hhcmFjdGVyID09PSBzZWxmLnNldHRpbmdzLmRlbGltaXRlcikge1xuICAgICAgICAgICAgc2VsZi5jcmVhdGVJdGVtKCk7XG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgb24gPGlucHV0PiBrZXlkb3duLlxuICAgICAqXG4gICAgICovXG4gICAgb25LZXlEb3duKGUpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBzZWxmLmlnbm9yZUhvdmVyID0gdHJ1ZTtcbiAgICAgICAgaWYgKHNlbGYuaXNMb2NrZWQpIHtcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgIT09IGNvbnN0YW50cy5LRVlfVEFCKSB7XG4gICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChlLmtleUNvZGUpIHtcbiAgICAgICAgICAgIC8vIGN0cmwrQTogc2VsZWN0IGFsbFxuICAgICAgICAgICAgY2FzZSBjb25zdGFudHMuS0VZX0E6XG4gICAgICAgICAgICAgICAgaWYgKGlzS2V5RG93bihjb25zdGFudHMuS0VZX1NIT1JUQ1VULCBlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb250cm9sX2lucHV0LnZhbHVlID09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0QWxsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBlc2M6IGNsb3NlIGRyb3Bkb3duXG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50cy5LRVlfRVNDOlxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmlzT3Blbikge1xuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLmNsZWFyQWN0aXZlSXRlbXMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBkb3duOiBvcGVuIGRyb3Bkb3duIG9yIG1vdmUgc2VsZWN0aW9uIGRvd25cbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzLktFWV9ET1dOOlxuICAgICAgICAgICAgICAgIGlmICghc2VsZi5pc09wZW4gJiYgc2VsZi5oYXNPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYub3BlbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWxmLmFjdGl2ZU9wdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHNlbGYuZ2V0QWRqYWNlbnQoc2VsZi5hY3RpdmVPcHRpb24sIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0QWN0aXZlT3B0aW9uKG5leHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyB1cDogbW92ZSBzZWxlY3Rpb24gdXBcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzLktFWV9VUDpcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5hY3RpdmVPcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZXYgPSBzZWxmLmdldEFkamFjZW50KHNlbGYuYWN0aXZlT3B0aW9uLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2KVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXRBY3RpdmVPcHRpb24ocHJldik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIHJldHVybjogc2VsZWN0IGFjdGl2ZSBvcHRpb25cbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzLktFWV9SRVRVUk46XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY2FuU2VsZWN0KHNlbGYuYWN0aXZlT3B0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9uT3B0aW9uU2VsZWN0KGUsIHNlbGYuYWN0aXZlT3B0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBvcHRpb25fY3JlYXRlPW51bGwsIHRoZSBkcm9wZG93biBtaWdodCBiZSBjbG9zZWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VsZi5zZXR0aW5ncy5jcmVhdGUgJiYgc2VsZi5jcmVhdGVJdGVtKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IHN1Ym1pdCBmb3JtIHdoZW4gc2VhcmNoaW5nIGZvciBhIHZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT0gc2VsZi5jb250cm9sX2lucHV0ICYmIHNlbGYuaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBsZWZ0OiBtb2RpZml5IGl0ZW0gc2VsZWN0aW9uIHRvIHRoZSBsZWZ0XG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50cy5LRVlfTEVGVDpcbiAgICAgICAgICAgICAgICBzZWxmLmFkdmFuY2VTZWxlY3Rpb24oLTEsIGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIHJpZ2h0OiBtb2RpZml5IGl0ZW0gc2VsZWN0aW9uIHRvIHRoZSByaWdodFxuICAgICAgICAgICAgY2FzZSBjb25zdGFudHMuS0VZX1JJR0hUOlxuICAgICAgICAgICAgICAgIHNlbGYuYWR2YW5jZVNlbGVjdGlvbigxLCBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyB0YWI6IHNlbGVjdCBhY3RpdmUgb3B0aW9uIGFuZC9vciBjcmVhdGUgaXRlbVxuICAgICAgICAgICAgY2FzZSBjb25zdGFudHMuS0VZX1RBQjpcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5zZXR0aW5ncy5zZWxlY3RPblRhYikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5jYW5TZWxlY3Qoc2VsZi5hY3RpdmVPcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm9uT3B0aW9uU2VsZWN0KGUsIHNlbGYuYWN0aXZlT3B0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgZGVmYXVsdCBbdGFiXSBiZWhhdmlvdXIgb2YganVtcCB0byB0aGUgbmV4dCBmaWVsZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgc2VsZWN0IGlzRnVsbCwgdGhlbiB0aGUgZHJvcGRvd24gd29uJ3QgYmUgb3BlbiBhbmQgW3RhYl0gd2lsbCB3b3JrIG5vcm1hbGx5XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5zZXR0aW5ncy5jcmVhdGUgJiYgc2VsZi5jcmVhdGVJdGVtKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIGRlbGV0ZXxiYWNrc3BhY2U6IGRlbGV0ZSBpdGVtc1xuICAgICAgICAgICAgY2FzZSBjb25zdGFudHMuS0VZX0JBQ0tTUEFDRTpcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzLktFWV9ERUxFVEU6XG4gICAgICAgICAgICAgICAgc2VsZi5kZWxldGVTZWxlY3Rpb24oZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRvbid0IGVudGVyIHRleHQgaW4gdGhlIGNvbnRyb2xfaW5wdXQgd2hlbiBhY3RpdmUgaXRlbXMgYXJlIHNlbGVjdGVkXG4gICAgICAgIGlmIChzZWxmLmlzSW5wdXRIaWRkZW4gJiYgIWlzS2V5RG93bihjb25zdGFudHMuS0VZX1NIT1JUQ1VULCBlKSkge1xuICAgICAgICAgICAgcHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIG9uIDxpbnB1dD4ga2V5dXAuXG4gICAgICpcbiAgICAgKi9cbiAgICBvbklucHV0KGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNMb2NrZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5wdXRWYWx1ZSgpO1xuICAgICAgICBpZiAodGhpcy5sYXN0VmFsdWUgPT09IHZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmxhc3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgPT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMuX29uSW5wdXQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWZyZXNoVGltZW91dCkge1xuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJlZnJlc2hUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZnJlc2hUaW1lb3V0ID0gdGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX29uSW5wdXQoKTtcbiAgICAgICAgfSwgdGhpcy5zZXR0aW5ncy5yZWZyZXNoVGhyb3R0bGUpO1xuICAgIH1cbiAgICBfb25JbnB1dCgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmxhc3RWYWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc2hvdWxkTG9hZC5jYWxsKHRoaXMsIHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5sb2FkKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZnJlc2hPcHRpb25zKCk7XG4gICAgICAgIHRoaXMudHJpZ2dlcigndHlwZScsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgcm9sbHMgb3ZlclxuICAgICAqIGFuIG9wdGlvbiBpbiB0aGUgYXV0b2NvbXBsZXRlIGRyb3Bkb3duIG1lbnUuXG4gICAgICpcbiAgICAgKi9cbiAgICBvbk9wdGlvbkhvdmVyKGV2dCwgb3B0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLmlnbm9yZUhvdmVyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnNldEFjdGl2ZU9wdGlvbihvcHRpb24sIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIG9uIDxpbnB1dD4gZm9jdXMuXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkZvY3VzKGUpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgd2FzRm9jdXNlZCA9IHNlbGYuaXNGb2N1c2VkO1xuICAgICAgICBpZiAoc2VsZi5pc0Rpc2FibGVkIHx8IHNlbGYuaXNSZWFkT25seSkge1xuICAgICAgICAgICAgc2VsZi5ibHVyKCk7XG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5pZ25vcmVGb2N1cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc2VsZi5pc0ZvY3VzZWQgPSB0cnVlO1xuICAgICAgICBpZiAoc2VsZi5zZXR0aW5ncy5wcmVsb2FkID09PSAnZm9jdXMnKVxuICAgICAgICAgICAgc2VsZi5wcmVsb2FkKCk7XG4gICAgICAgIGlmICghd2FzRm9jdXNlZClcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcignZm9jdXMnKTtcbiAgICAgICAgaWYgKCFzZWxmLmFjdGl2ZUl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgc2VsZi5pbnB1dFN0YXRlKCk7XG4gICAgICAgICAgICBzZWxmLnJlZnJlc2hPcHRpb25zKCEhc2VsZi5zZXR0aW5ncy5vcGVuT25Gb2N1cyk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5yZWZyZXNoU3RhdGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIG9uIDxpbnB1dD4gYmx1ci5cbiAgICAgKlxuICAgICAqL1xuICAgIG9uQmx1cihlKSB7XG4gICAgICAgIGlmIChkb2N1bWVudC5oYXNGb2N1cygpID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoIXNlbGYuaXNGb2N1c2VkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzZWxmLmlzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICBzZWxmLmlnbm9yZUZvY3VzID0gZmFsc2U7XG4gICAgICAgIHZhciBkZWFjdGl2YXRlID0gKCkgPT4ge1xuICAgICAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgICAgICAgc2VsZi5zZXRBY3RpdmVJdGVtKCk7XG4gICAgICAgICAgICBzZWxmLnNldENhcmV0KHNlbGYuaXRlbXMubGVuZ3RoKTtcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcignYmx1cicpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoc2VsZi5zZXR0aW5ncy5jcmVhdGUgJiYgc2VsZi5zZXR0aW5ncy5jcmVhdGVPbkJsdXIpIHtcbiAgICAgICAgICAgIHNlbGYuY3JlYXRlSXRlbShudWxsLCBkZWFjdGl2YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlYWN0aXZhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gYW4gb3B0aW9uXG4gICAgICogaW4gdGhlIGF1dG9jb21wbGV0ZSBkcm9wZG93biBtZW51LlxuICAgICAqXG4gICAgICovXG4gICAgb25PcHRpb25TZWxlY3QoZXZ0LCBvcHRpb24pIHtcbiAgICAgICAgdmFyIHZhbHVlLCBzZWxmID0gdGhpcztcbiAgICAgICAgLy8gc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byB0cmlnZ2VyIGEgb3B0aW9uIHVuZGVyIGEgZGlzYWJsZWQgb3B0Z3JvdXBcbiAgICAgICAgaWYgKG9wdGlvbi5wYXJlbnRFbGVtZW50ICYmIG9wdGlvbi5wYXJlbnRFbGVtZW50Lm1hdGNoZXMoJ1tkYXRhLWRpc2FibGVkXScpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbi5jbGFzc0xpc3QuY29udGFpbnMoJ2NyZWF0ZScpKSB7XG4gICAgICAgICAgICBzZWxmLmNyZWF0ZUl0ZW0obnVsbCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnNldHRpbmdzLmNsb3NlQWZ0ZXJTZWxlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBvcHRpb24uZGF0YXNldC52YWx1ZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5sYXN0UXVlcnkgPSBudWxsO1xuICAgICAgICAgICAgICAgIHNlbGYuYWRkSXRlbSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuc2V0dGluZ3MuY2xvc2VBZnRlclNlbGVjdCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc2VsZi5zZXR0aW5ncy5oaWRlU2VsZWN0ZWQgJiYgZXZ0LnR5cGUgJiYgL2NsaWNrLy50ZXN0KGV2dC50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNldEFjdGl2ZU9wdGlvbihvcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgZ2l2ZW4gb3B0aW9uIGNhbiBiZSBzZWxlY3RlZFxuICAgICAqXG4gICAgICovXG4gICAgY2FuU2VsZWN0KG9wdGlvbikge1xuICAgICAgICBpZiAodGhpcy5pc09wZW4gJiYgb3B0aW9uICYmIHRoaXMuZHJvcGRvd25fY29udGVudC5jb250YWlucyhvcHRpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiBhbiBpdGVtXG4gICAgICogdGhhdCBoYXMgYmVlbiBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqL1xuICAgIG9uSXRlbVNlbGVjdChldnQsIGl0ZW0pIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoIXNlbGYuaXNMb2NrZWQgJiYgc2VsZi5zZXR0aW5ncy5tb2RlID09PSAnbXVsdGknKSB7XG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChldnQpO1xuICAgICAgICAgICAgc2VsZi5zZXRBY3RpdmVJdGVtKGl0ZW0sIGV2dCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdG8gaW52b2tlXG4gICAgICogdGhlIHVzZXItcHJvdmlkZWQgb3B0aW9uIHByb3ZpZGVyIC8gbG9hZGVyXG4gICAgICpcbiAgICAgKiBOb3RlLCB0aGVyZSBpcyBhIHN1YnRsZSBkaWZmZXJlbmNlIGJldHdlZW5cbiAgICAgKiB0aGlzLmNhbkxvYWQoKSBhbmQgdGhpcy5zZXR0aW5ncy5zaG91bGRMb2FkKCk7XG4gICAgICpcbiAgICAgKlx0LSBzZXR0aW5ncy5zaG91bGRMb2FkKCkgaXMgYSB1c2VyLWlucHV0IHZhbGlkYXRvci5cbiAgICAgKlx0V2hlbiBmYWxzZSBpcyByZXR1cm5lZCwgdGhlIG5vdF9sb2FkaW5nIHRlbXBsYXRlXG4gICAgICpcdHdpbGwgYmUgYWRkZWQgdG8gdGhlIGRyb3Bkb3duXG4gICAgICpcbiAgICAgKlx0LSBjYW5Mb2FkKCkgaXMgbG93ZXIgbGV2ZWwgdmFsaWRhdG9yIHRoYXQgY2hlY2tzXG4gICAgICogXHR0aGUgVG9tIFNlbGVjdCBpbnN0YW5jZS4gVGhlcmUgaXMgbm8gaW5oZXJlbnQgdXNlclxuICAgICAqXHRmZWVkYmFjayB3aGVuIGNhbkxvYWQgcmV0dXJucyBmYWxzZVxuICAgICAqXG4gICAgICovXG4gICAgY2FuTG9hZCh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3MubG9hZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMubG9hZGVkU2VhcmNoZXMuaGFzT3duUHJvcGVydHkodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgdXNlci1wcm92aWRlZCBvcHRpb24gcHJvdmlkZXIgLyBsb2FkZXIuXG4gICAgICpcbiAgICAgKi9cbiAgICBsb2FkKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoIXNlbGYuY2FuTG9hZCh2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGFkZENsYXNzZXMoc2VsZi53cmFwcGVyLCBzZWxmLnNldHRpbmdzLmxvYWRpbmdDbGFzcyk7XG4gICAgICAgIHNlbGYubG9hZGluZysrO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IHNlbGYubG9hZENhbGxiYWNrLmJpbmQoc2VsZik7XG4gICAgICAgIHNlbGYuc2V0dGluZ3MubG9hZC5jYWxsKHNlbGYsIHZhbHVlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludm9rZWQgYnkgdGhlIHVzZXItcHJvdmlkZWQgb3B0aW9uIHByb3ZpZGVyXG4gICAgICpcbiAgICAgKi9cbiAgICBsb2FkQ2FsbGJhY2sob3B0aW9ucywgb3B0Z3JvdXBzKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBzZWxmLmxvYWRpbmcgPSBNYXRoLm1heChzZWxmLmxvYWRpbmcgLSAxLCAwKTtcbiAgICAgICAgc2VsZi5sYXN0UXVlcnkgPSBudWxsO1xuICAgICAgICBzZWxmLmNsZWFyQWN0aXZlT3B0aW9uKCk7IC8vIHdoZW4gbmV3IHJlc3VsdHMgbG9hZCwgZm9jdXMgc2hvdWxkIGJlIG9uIGZpcnN0IG9wdGlvblxuICAgICAgICBzZWxmLnNldHVwT3B0aW9ucyhvcHRpb25zLCBvcHRncm91cHMpO1xuICAgICAgICBzZWxmLnJlZnJlc2hPcHRpb25zKHNlbGYuaXNGb2N1c2VkICYmICFzZWxmLmlzSW5wdXRIaWRkZW4pO1xuICAgICAgICBpZiAoIXNlbGYubG9hZGluZykge1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3NlcyhzZWxmLndyYXBwZXIsIHNlbGYuc2V0dGluZ3MubG9hZGluZ0NsYXNzKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLnRyaWdnZXIoJ2xvYWQnLCBvcHRpb25zLCBvcHRncm91cHMpO1xuICAgIH1cbiAgICBwcmVsb2FkKCkge1xuICAgICAgICB2YXIgY2xhc3NMaXN0ID0gdGhpcy53cmFwcGVyLmNsYXNzTGlzdDtcbiAgICAgICAgaWYgKGNsYXNzTGlzdC5jb250YWlucygncHJlbG9hZGVkJykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ3ByZWxvYWRlZCcpO1xuICAgICAgICB0aGlzLmxvYWQoJycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBpbnB1dCBmaWVsZCBvZiB0aGUgY29udHJvbCB0byB0aGUgc3BlY2lmaWVkIHZhbHVlLlxuICAgICAqXG4gICAgICovXG4gICAgc2V0VGV4dGJveFZhbHVlKHZhbHVlID0gJycpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5jb250cm9sX2lucHV0O1xuICAgICAgICB2YXIgY2hhbmdlZCA9IGlucHV0LnZhbHVlICE9PSB2YWx1ZTtcbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgIGlucHV0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoaW5wdXQsICd1cGRhdGUnKTtcbiAgICAgICAgICAgIHRoaXMubGFzdFZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGNvbnRyb2wuIElmIG11bHRpcGxlIGl0ZW1zXG4gICAgICogY2FuIGJlIHNlbGVjdGVkIChlLmcuIDxzZWxlY3QgbXVsdGlwbGU+KSwgdGhpcyByZXR1cm5zXG4gICAgICogYW4gYXJyYXkuIElmIG9ubHkgb25lIGl0ZW0gY2FuIGJlIHNlbGVjdGVkLCB0aGlzXG4gICAgICogcmV0dXJucyBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqL1xuICAgIGdldFZhbHVlKCkge1xuICAgICAgICBpZiAodGhpcy5pc19zZWxlY3RfdGFnICYmIHRoaXMuaW5wdXQuaGFzQXR0cmlidXRlKCdtdWx0aXBsZScpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5qb2luKHRoaXMuc2V0dGluZ3MuZGVsaW1pdGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBzZWxlY3RlZCBpdGVtcyB0byB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAgICpcbiAgICAgKi9cbiAgICBzZXRWYWx1ZSh2YWx1ZSwgc2lsZW50KSB7XG4gICAgICAgIHZhciBldmVudHMgPSBzaWxlbnQgPyBbXSA6IFsnY2hhbmdlJ107XG4gICAgICAgIGRlYm91bmNlX2V2ZW50cyh0aGlzLCBldmVudHMsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoc2lsZW50KTtcbiAgICAgICAgICAgIHRoaXMuYWRkSXRlbXModmFsdWUsIHNpbGVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIG51bWJlciBvZiBtYXggaXRlbXMgdG8gdGhlIGdpdmVuIHZhbHVlXG4gICAgICpcbiAgICAgKi9cbiAgICBzZXRNYXhJdGVtcyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IDApXG4gICAgICAgICAgICB2YWx1ZSA9IG51bGw7IC8vcmVzZXQgdG8gdW5saW1pdGVkIGl0ZW1zLlxuICAgICAgICB0aGlzLnNldHRpbmdzLm1heEl0ZW1zID0gdmFsdWU7XG4gICAgICAgIHRoaXMucmVmcmVzaFN0YXRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNlbGVjdGVkIGl0ZW0uXG4gICAgICpcbiAgICAgKi9cbiAgICBzZXRBY3RpdmVJdGVtKGl0ZW0sIGUpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZXZlbnROYW1lO1xuICAgICAgICB2YXIgaSwgYmVnaW4sIGVuZCwgc3dhcDtcbiAgICAgICAgdmFyIGxhc3Q7XG4gICAgICAgIGlmIChzZWxmLnNldHRpbmdzLm1vZGUgPT09ICdzaW5nbGUnKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBjbGVhciB0aGUgYWN0aXZlIHNlbGVjdGlvblxuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgIHNlbGYuY2xlYXJBY3RpdmVJdGVtcygpO1xuICAgICAgICAgICAgaWYgKHNlbGYuaXNGb2N1c2VkKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pbnB1dFN0YXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gbW9kaWZ5IHNlbGVjdGlvblxuICAgICAgICBldmVudE5hbWUgPSBlICYmIGUudHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoZXZlbnROYW1lID09PSAnY2xpY2snICYmIGlzS2V5RG93bignc2hpZnRLZXknLCBlKSAmJiBzZWxmLmFjdGl2ZUl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgbGFzdCA9IHNlbGYuZ2V0TGFzdEFjdGl2ZSgpO1xuICAgICAgICAgICAgYmVnaW4gPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHNlbGYuY29udHJvbC5jaGlsZHJlbiwgbGFzdCk7XG4gICAgICAgICAgICBlbmQgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHNlbGYuY29udHJvbC5jaGlsZHJlbiwgaXRlbSk7XG4gICAgICAgICAgICBpZiAoYmVnaW4gPiBlbmQpIHtcbiAgICAgICAgICAgICAgICBzd2FwID0gYmVnaW47XG4gICAgICAgICAgICAgICAgYmVnaW4gPSBlbmQ7XG4gICAgICAgICAgICAgICAgZW5kID0gc3dhcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IGJlZ2luOyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IHNlbGYuY29udHJvbC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5hY3RpdmVJdGVtcy5pbmRleE9mKGl0ZW0pID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNldEFjdGl2ZUl0ZW1DbGFzcyhpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoZXZlbnROYW1lID09PSAnY2xpY2snICYmIGlzS2V5RG93bihjb25zdGFudHMuS0VZX1NIT1JUQ1VULCBlKSkgfHwgKGV2ZW50TmFtZSA9PT0gJ2tleWRvd24nICYmIGlzS2V5RG93bignc2hpZnRLZXknLCBlKSkpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJlbW92ZUFjdGl2ZUl0ZW0oaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNldEFjdGl2ZUl0ZW1DbGFzcyhpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuY2xlYXJBY3RpdmVJdGVtcygpO1xuICAgICAgICAgICAgc2VsZi5zZXRBY3RpdmVJdGVtQ2xhc3MoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZW5zdXJlIGNvbnRyb2wgaGFzIGZvY3VzXG4gICAgICAgIHNlbGYuaW5wdXRTdGF0ZSgpO1xuICAgICAgICBpZiAoIXNlbGYuaXNGb2N1c2VkKSB7XG4gICAgICAgICAgICBzZWxmLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBhY3RpdmUgYW5kIGxhc3QtYWN0aXZlIGNsYXNzZXNcbiAgICAgKlxuICAgICAqL1xuICAgIHNldEFjdGl2ZUl0ZW1DbGFzcyhpdGVtKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBjb25zdCBsYXN0X2FjdGl2ZSA9IHNlbGYuY29udHJvbC5xdWVyeVNlbGVjdG9yKCcubGFzdC1hY3RpdmUnKTtcbiAgICAgICAgaWYgKGxhc3RfYWN0aXZlKVxuICAgICAgICAgICAgcmVtb3ZlQ2xhc3NlcyhsYXN0X2FjdGl2ZSwgJ2xhc3QtYWN0aXZlJyk7XG4gICAgICAgIGFkZENsYXNzZXMoaXRlbSwgJ2FjdGl2ZSBsYXN0LWFjdGl2ZScpO1xuICAgICAgICBzZWxmLnRyaWdnZXIoJ2l0ZW1fc2VsZWN0JywgaXRlbSk7XG4gICAgICAgIGlmIChzZWxmLmFjdGl2ZUl0ZW1zLmluZGV4T2YoaXRlbSkgPT0gLTEpIHtcbiAgICAgICAgICAgIHNlbGYuYWN0aXZlSXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWN0aXZlIGl0ZW1cbiAgICAgKlxuICAgICAqL1xuICAgIHJlbW92ZUFjdGl2ZUl0ZW0oaXRlbSkge1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5hY3RpdmVJdGVtcy5pbmRleE9mKGl0ZW0pO1xuICAgICAgICB0aGlzLmFjdGl2ZUl0ZW1zLnNwbGljZShpZHgsIDEpO1xuICAgICAgICByZW1vdmVDbGFzc2VzKGl0ZW0sICdhY3RpdmUnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCB0aGUgYWN0aXZlIGl0ZW1zXG4gICAgICpcbiAgICAgKi9cbiAgICBjbGVhckFjdGl2ZUl0ZW1zKCkge1xuICAgICAgICByZW1vdmVDbGFzc2VzKHRoaXMuYWN0aXZlSXRlbXMsICdhY3RpdmUnKTtcbiAgICAgICAgdGhpcy5hY3RpdmVJdGVtcyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzZWxlY3RlZCBpdGVtIGluIHRoZSBkcm9wZG93biBtZW51XG4gICAgICogb2YgYXZhaWxhYmxlIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKi9cbiAgICBzZXRBY3RpdmVPcHRpb24ob3B0aW9uLCBzY3JvbGwgPSB0cnVlKSB7XG4gICAgICAgIGlmIChvcHRpb24gPT09IHRoaXMuYWN0aXZlT3B0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhckFjdGl2ZU9wdGlvbigpO1xuICAgICAgICBpZiAoIW9wdGlvbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5hY3RpdmVPcHRpb24gPSBvcHRpb247XG4gICAgICAgIHNldEF0dHIodGhpcy5mb2N1c19ub2RlLCB7ICdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnOiBvcHRpb24uZ2V0QXR0cmlidXRlKCdpZCcpIH0pO1xuICAgICAgICBzZXRBdHRyKG9wdGlvbiwgeyAnYXJpYS1zZWxlY3RlZCc6ICd0cnVlJyB9KTtcbiAgICAgICAgYWRkQ2xhc3NlcyhvcHRpb24sICdhY3RpdmUnKTtcbiAgICAgICAgaWYgKHNjcm9sbClcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9PcHRpb24ob3B0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZHJvcGRvd25fY29udGVudCBzY3JvbGxUb3AgdG8gZGlzcGxheSB0aGUgb3B0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBzY3JvbGxUb09wdGlvbihvcHRpb24sIGJlaGF2aW9yKSB7XG4gICAgICAgIGlmICghb3B0aW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5kcm9wZG93bl9jb250ZW50O1xuICAgICAgICBjb25zdCBoZWlnaHRfbWVudSA9IGNvbnRlbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICBjb25zdCBzY3JvbGxUb3AgPSBjb250ZW50LnNjcm9sbFRvcCB8fCAwO1xuICAgICAgICBjb25zdCBoZWlnaHRfaXRlbSA9IG9wdGlvbi5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGNvbnN0IHkgPSBvcHRpb24uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIC0gY29udGVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyBzY3JvbGxUb3A7XG4gICAgICAgIGlmICh5ICsgaGVpZ2h0X2l0ZW0gPiBoZWlnaHRfbWVudSArIHNjcm9sbFRvcCkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGwoeSAtIGhlaWdodF9tZW51ICsgaGVpZ2h0X2l0ZW0sIGJlaGF2aW9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh5IDwgc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbCh5LCBiZWhhdmlvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2Nyb2xsIHRoZSBkcm9wZG93biB0byB0aGUgZ2l2ZW4gcG9zaXRpb25cbiAgICAgKlxuICAgICAqL1xuICAgIHNjcm9sbChzY3JvbGxUb3AsIGJlaGF2aW9yKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLmRyb3Bkb3duX2NvbnRlbnQ7XG4gICAgICAgIGlmIChiZWhhdmlvcikge1xuICAgICAgICAgICAgY29udGVudC5zdHlsZS5zY3JvbGxCZWhhdmlvciA9IGJlaGF2aW9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRlbnQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICBjb250ZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gJyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgYWN0aXZlIG9wdGlvblxuICAgICAqXG4gICAgICovXG4gICAgY2xlYXJBY3RpdmVPcHRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZU9wdGlvbikge1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3Nlcyh0aGlzLmFjdGl2ZU9wdGlvbiwgJ2FjdGl2ZScpO1xuICAgICAgICAgICAgc2V0QXR0cih0aGlzLmFjdGl2ZU9wdGlvbiwgeyAnYXJpYS1zZWxlY3RlZCc6IG51bGwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVPcHRpb24gPSBudWxsO1xuICAgICAgICBzZXRBdHRyKHRoaXMuZm9jdXNfbm9kZSwgeyAnYXJpYS1hY3RpdmVkZXNjZW5kYW50JzogbnVsbCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VsZWN0cyBhbGwgaXRlbXMgKENUUkwgKyBBKS5cbiAgICAgKi9cbiAgICBzZWxlY3RBbGwoKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoc2VsZi5zZXR0aW5ncy5tb2RlID09PSAnc2luZ2xlJylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgYWN0aXZlSXRlbXMgPSBzZWxmLmNvbnRyb2xDaGlsZHJlbigpO1xuICAgICAgICBpZiAoIWFjdGl2ZUl0ZW1zLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc2VsZi5pbnB1dFN0YXRlKCk7XG4gICAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICAgICAgc2VsZi5hY3RpdmVJdGVtcyA9IGFjdGl2ZUl0ZW1zO1xuICAgICAgICBpdGVyYXRlKGFjdGl2ZUl0ZW1zLCAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgc2VsZi5zZXRBY3RpdmVJdGVtQ2xhc3MoaXRlbSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBjb250cm9sX2lucHV0IHNob3VsZCBiZSBpbiBhIGhpZGRlbiBvciB2aXNpYmxlIHN0YXRlXG4gICAgICpcbiAgICAgKi9cbiAgICBpbnB1dFN0YXRlKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICghc2VsZi5jb250cm9sLmNvbnRhaW5zKHNlbGYuY29udHJvbF9pbnB1dCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHNldEF0dHIoc2VsZi5jb250cm9sX2lucHV0LCB7IHBsYWNlaG9sZGVyOiBzZWxmLnNldHRpbmdzLnBsYWNlaG9sZGVyIH0pO1xuICAgICAgICBpZiAoc2VsZi5hY3RpdmVJdGVtcy5sZW5ndGggPiAwIHx8ICghc2VsZi5pc0ZvY3VzZWQgJiYgc2VsZi5zZXR0aW5ncy5oaWRlUGxhY2Vob2xkZXIgJiYgc2VsZi5pdGVtcy5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgc2VsZi5zZXRUZXh0Ym94VmFsdWUoKTtcbiAgICAgICAgICAgIHNlbGYuaXNJbnB1dEhpZGRlbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5zZXR0aW5ncy5oaWRlUGxhY2Vob2xkZXIgJiYgc2VsZi5pdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgc2V0QXR0cihzZWxmLmNvbnRyb2xfaW5wdXQsIHsgcGxhY2Vob2xkZXI6ICcnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5pc0lucHV0SGlkZGVuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi53cmFwcGVyLmNsYXNzTGlzdC50b2dnbGUoJ2lucHV0LWhpZGRlbicsIHNlbGYuaXNJbnB1dEhpZGRlbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaW5wdXQgdmFsdWVcbiAgICAgKi9cbiAgICBpbnB1dFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sX2lucHV0LnZhbHVlLnRyaW0oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZXMgdGhlIGNvbnRyb2wgZm9jdXMuXG4gICAgICovXG4gICAgZm9jdXMoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKHNlbGYuaXNEaXNhYmxlZCB8fCBzZWxmLmlzUmVhZE9ubHkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHNlbGYuaWdub3JlRm9jdXMgPSB0cnVlO1xuICAgICAgICBpZiAoc2VsZi5jb250cm9sX2lucHV0Lm9mZnNldFdpZHRoKSB7XG4gICAgICAgICAgICBzZWxmLmNvbnRyb2xfaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuZm9jdXNfbm9kZS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgc2VsZi5pZ25vcmVGb2N1cyA9IGZhbHNlO1xuICAgICAgICAgICAgc2VsZi5vbkZvY3VzKCk7XG4gICAgICAgIH0sIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3JjZXMgdGhlIGNvbnRyb2wgb3V0IG9mIGZvY3VzLlxuICAgICAqXG4gICAgICovXG4gICAgYmx1cigpIHtcbiAgICAgICAgdGhpcy5mb2N1c19ub2RlLmJsdXIoKTtcbiAgICAgICAgdGhpcy5vbkJsdXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgc2NvcmVzIGFuIG9iamVjdFxuICAgICAqIHRvIHNob3cgaG93IGdvb2Qgb2YgYSBtYXRjaCBpdCBpcyB0byB0aGVcbiAgICAgKiBwcm92aWRlZCBxdWVyeS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGdldFNjb3JlRnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lmdGVyLmdldFNjb3JlRnVuY3Rpb24ocXVlcnksIHRoaXMuZ2V0U2VhcmNoT3B0aW9ucygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzZWFyY2ggb3B0aW9ucyBmb3Igc2lmdGVyICh0aGUgc3lzdGVtXG4gICAgICogZm9yIHNjb3JpbmcgYW5kIHNvcnRpbmcgcmVzdWx0cykuXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9vcmNoaWRqcy9zaWZ0ZXIuanNcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAgICovXG4gICAgZ2V0U2VhcmNoT3B0aW9ucygpIHtcbiAgICAgICAgdmFyIHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncztcbiAgICAgICAgdmFyIHNvcnQgPSBzZXR0aW5ncy5zb3J0RmllbGQ7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3Muc29ydEZpZWxkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc29ydCA9IFt7IGZpZWxkOiBzZXR0aW5ncy5zb3J0RmllbGQgfV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpZWxkczogc2V0dGluZ3Muc2VhcmNoRmllbGQsXG4gICAgICAgICAgICBjb25qdW5jdGlvbjogc2V0dGluZ3Muc2VhcmNoQ29uanVuY3Rpb24sXG4gICAgICAgICAgICBzb3J0OiBzb3J0LFxuICAgICAgICAgICAgbmVzdGluZzogc2V0dGluZ3MubmVzdGluZ1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyB0aHJvdWdoIGF2YWlsYWJsZSBvcHRpb25zIGFuZCByZXR1cm5zXG4gICAgICogYSBzb3J0ZWQgYXJyYXkgb2YgbWF0Y2hlcy5cbiAgICAgKlxuICAgICAqL1xuICAgIHNlYXJjaChxdWVyeSkge1xuICAgICAgICB2YXIgcmVzdWx0LCBjYWxjdWxhdGVTY29yZTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuZ2V0U2VhcmNoT3B0aW9ucygpO1xuICAgICAgICAvLyB2YWxpZGF0ZSB1c2VyLXByb3ZpZGVkIHJlc3VsdCBzY29yaW5nIGZ1bmN0aW9uXG4gICAgICAgIGlmIChzZWxmLnNldHRpbmdzLnNjb3JlKSB7XG4gICAgICAgICAgICBjYWxjdWxhdGVTY29yZSA9IHNlbGYuc2V0dGluZ3Muc2NvcmUuY2FsbChzZWxmLCBxdWVyeSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbGN1bGF0ZVNjb3JlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb20gU2VsZWN0IFwic2NvcmVcIiBzZXR0aW5nIG11c3QgYmUgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHBlcmZvcm0gc2VhcmNoXG4gICAgICAgIGlmIChxdWVyeSAhPT0gc2VsZi5sYXN0UXVlcnkpIHtcbiAgICAgICAgICAgIHNlbGYubGFzdFF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgICAgICByZXN1bHQgPSBzZWxmLnNpZnRlci5zZWFyY2gocXVlcnksIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgeyBzY29yZTogY2FsY3VsYXRlU2NvcmUgfSkpO1xuICAgICAgICAgICAgc2VsZi5jdXJyZW50UmVzdWx0cyA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oe30sIHNlbGYuY3VycmVudFJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpbHRlciBvdXQgc2VsZWN0ZWQgaXRlbXNcbiAgICAgICAgaWYgKHNlbGYuc2V0dGluZ3MuaGlkZVNlbGVjdGVkKSB7XG4gICAgICAgICAgICByZXN1bHQuaXRlbXMgPSByZXN1bHQuaXRlbXMuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGhhc2hlZCA9IGhhc2hfa2V5KGl0ZW0uaWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAhKGhhc2hlZCAmJiBzZWxmLml0ZW1zLmluZGV4T2YoaGFzaGVkKSAhPT0gLTEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVmcmVzaGVzIHRoZSBsaXN0IG9mIGF2YWlsYWJsZSBvcHRpb25zIHNob3duXG4gICAgICogaW4gdGhlIGF1dG9jb21wbGV0ZSBkcm9wZG93biBtZW51LlxuICAgICAqXG4gICAgICovXG4gICAgcmVmcmVzaE9wdGlvbnModHJpZ2dlckRyb3Bkb3duID0gdHJ1ZSkge1xuICAgICAgICB2YXIgaSwgaiwgaywgbiwgb3B0Z3JvdXAsIG9wdGdyb3VwcywgaHRtbCwgaGFzX2NyZWF0ZV9vcHRpb24sIGFjdGl2ZV9ncm91cDtcbiAgICAgICAgdmFyIGNyZWF0ZTtcbiAgICAgICAgY29uc3QgZ3JvdXBzID0ge307XG4gICAgICAgIGNvbnN0IGdyb3Vwc19vcmRlciA9IFtdO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBxdWVyeSA9IHNlbGYuaW5wdXRWYWx1ZSgpO1xuICAgICAgICBjb25zdCBzYW1lX3F1ZXJ5ID0gcXVlcnkgPT09IHNlbGYubGFzdFF1ZXJ5IHx8IChxdWVyeSA9PSAnJyAmJiBzZWxmLmxhc3RRdWVyeSA9PSBudWxsKTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBzZWxmLnNlYXJjaChxdWVyeSk7XG4gICAgICAgIHZhciBhY3RpdmVfb3B0aW9uID0gbnVsbDtcbiAgICAgICAgdmFyIHNob3dfZHJvcGRvd24gPSBzZWxmLnNldHRpbmdzLnNob3VsZE9wZW4gfHwgZmFsc2U7XG4gICAgICAgIHZhciBkcm9wZG93bl9jb250ZW50ID0gc2VsZi5kcm9wZG93bl9jb250ZW50O1xuICAgICAgICBpZiAoc2FtZV9xdWVyeSkge1xuICAgICAgICAgICAgYWN0aXZlX29wdGlvbiA9IHNlbGYuYWN0aXZlT3B0aW9uO1xuICAgICAgICAgICAgaWYgKGFjdGl2ZV9vcHRpb24pIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVfZ3JvdXAgPSBhY3RpdmVfb3B0aW9uLmNsb3Nlc3QoJ1tkYXRhLWdyb3VwXScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGJ1aWxkIG1hcmt1cFxuICAgICAgICBuID0gcmVzdWx0cy5pdGVtcy5sZW5ndGg7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZi5zZXR0aW5ncy5tYXhPcHRpb25zID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgbiA9IE1hdGgubWluKG4sIHNlbGYuc2V0dGluZ3MubWF4T3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgICAgICBzaG93X2Ryb3Bkb3duID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZXQgZnJhZ21lbnQgZm9yIGdyb3VwIGFuZCB0aGUgcG9zaXRpb24gb2YgdGhlIGdyb3VwIGluIGdyb3VwX29yZGVyXG4gICAgICAgIGNvbnN0IGdldEdyb3VwRnJhZ21lbnQgPSAob3B0Z3JvdXAsIG9yZGVyKSA9PiB7XG4gICAgICAgICAgICBsZXQgZ3JvdXBfb3JkZXJfaSA9IGdyb3Vwc1tvcHRncm91cF07XG4gICAgICAgICAgICBpZiAoZ3JvdXBfb3JkZXJfaSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9yZGVyX2dyb3VwID0gZ3JvdXBzX29yZGVyW2dyb3VwX29yZGVyX2ldO1xuICAgICAgICAgICAgICAgIGlmIChvcmRlcl9ncm91cCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbZ3JvdXBfb3JkZXJfaSwgb3JkZXJfZ3JvdXAuZnJhZ21lbnRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBncm91cF9mcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgIGdyb3VwX29yZGVyX2kgPSBncm91cHNfb3JkZXIubGVuZ3RoO1xuICAgICAgICAgICAgZ3JvdXBzX29yZGVyLnB1c2goeyBmcmFnbWVudDogZ3JvdXBfZnJhZ21lbnQsIG9yZGVyLCBvcHRncm91cCB9KTtcbiAgICAgICAgICAgIHJldHVybiBbZ3JvdXBfb3JkZXJfaSwgZ3JvdXBfZnJhZ21lbnRdO1xuICAgICAgICB9O1xuICAgICAgICAvLyByZW5kZXIgYW5kIGdyb3VwIGF2YWlsYWJsZSBvcHRpb25zIGluZGl2aWR1YWxseVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBnZXQgb3B0aW9uIGRvbSBlbGVtZW50XG4gICAgICAgICAgICBsZXQgaXRlbSA9IHJlc3VsdHMuaXRlbXNbaV07XG4gICAgICAgICAgICBpZiAoIWl0ZW0pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgb3B0X3ZhbHVlID0gaXRlbS5pZDtcbiAgICAgICAgICAgIGxldCBvcHRpb24gPSBzZWxmLm9wdGlvbnNbb3B0X3ZhbHVlXTtcbiAgICAgICAgICAgIGlmIChvcHRpb24gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBvcHRfaGFzaCA9IGdldF9oYXNoKG9wdF92YWx1ZSk7XG4gICAgICAgICAgICBsZXQgb3B0aW9uX2VsID0gc2VsZi5nZXRPcHRpb24ob3B0X2hhc2gsIHRydWUpO1xuICAgICAgICAgICAgLy8gdG9nZ2xlICdzZWxlY3RlZCcgY2xhc3NcbiAgICAgICAgICAgIGlmICghc2VsZi5zZXR0aW5ncy5oaWRlU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25fZWwuY2xhc3NMaXN0LnRvZ2dsZSgnc2VsZWN0ZWQnLCBzZWxmLml0ZW1zLmluY2x1ZGVzKG9wdF9oYXNoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRncm91cCA9IG9wdGlvbltzZWxmLnNldHRpbmdzLm9wdGdyb3VwRmllbGRdIHx8ICcnO1xuICAgICAgICAgICAgb3B0Z3JvdXBzID0gQXJyYXkuaXNBcnJheShvcHRncm91cCkgPyBvcHRncm91cCA6IFtvcHRncm91cF07XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBrID0gb3B0Z3JvdXBzICYmIG9wdGdyb3Vwcy5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgICAgICBvcHRncm91cCA9IG9wdGdyb3Vwc1tqXTtcbiAgICAgICAgICAgICAgICBsZXQgb3JkZXIgPSBvcHRpb24uJG9yZGVyO1xuICAgICAgICAgICAgICAgIGxldCBzZWxmX29wdGdyb3VwID0gc2VsZi5vcHRncm91cHNbb3B0Z3JvdXBdO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmX29wdGdyb3VwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0Z3JvdXAgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9yZGVyID0gc2VsZl9vcHRncm91cC4kb3JkZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IFtncm91cF9vcmRlcl9pLCBncm91cF9mcmFnbWVudF0gPSBnZXRHcm91cEZyYWdtZW50KG9wdGdyb3VwLCBvcmRlcik7XG4gICAgICAgICAgICAgICAgLy8gbm9kZXMgY2FuIG9ubHkgaGF2ZSBvbmUgcGFyZW50LCBzbyBpZiB0aGUgb3B0aW9uIGlzIGluIG11dHBsZSBncm91cHMsIHdlIG5lZWQgYSBjbG9uZVxuICAgICAgICAgICAgICAgIGlmIChqID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25fZWwgPSBvcHRpb25fZWwuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBzZXRBdHRyKG9wdGlvbl9lbCwgeyBpZDogb3B0aW9uLiRpZCArICctY2xvbmUtJyArIGosICdhcmlhLXNlbGVjdGVkJzogbnVsbCB9KTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uX2VsLmNsYXNzTGlzdC5hZGQoJ3RzLWNsb25lZCcpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzc2VzKG9wdGlvbl9lbCwgJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2Uga2VlcCB0aGUgYWN0aXZlT3B0aW9uIGluIHRoZSBzYW1lIGdyb3VwXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmFjdGl2ZU9wdGlvbiAmJiBzZWxmLmFjdGl2ZU9wdGlvbi5kYXRhc2V0LnZhbHVlID09IG9wdF92YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZV9ncm91cCAmJiBhY3RpdmVfZ3JvdXAuZGF0YXNldC5ncm91cCA9PT0gb3B0Z3JvdXAudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZV9vcHRpb24gPSBvcHRpb25fZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ3JvdXBfZnJhZ21lbnQuYXBwZW5kQ2hpbGQob3B0aW9uX2VsKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0Z3JvdXAgIT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBzW29wdGdyb3VwXSA9IGdyb3VwX29yZGVyX2k7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNvcnQgb3B0Z3JvdXBzXG4gICAgICAgIGlmIChzZWxmLnNldHRpbmdzLmxvY2tPcHRncm91cE9yZGVyKSB7XG4gICAgICAgICAgICBncm91cHNfb3JkZXIuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLm9yZGVyIC0gYi5vcmRlcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbmRlciBvcHRncm91cCBoZWFkZXJzICYgam9pbiBncm91cHNcbiAgICAgICAgaHRtbCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgaXRlcmF0ZShncm91cHNfb3JkZXIsIChncm91cF9vcmRlcikgPT4ge1xuICAgICAgICAgICAgbGV0IGdyb3VwX2ZyYWdtZW50ID0gZ3JvdXBfb3JkZXIuZnJhZ21lbnQ7XG4gICAgICAgICAgICBsZXQgb3B0Z3JvdXAgPSBncm91cF9vcmRlci5vcHRncm91cDtcbiAgICAgICAgICAgIGlmICghZ3JvdXBfZnJhZ21lbnQgfHwgIWdyb3VwX2ZyYWdtZW50LmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgZ3JvdXBfaGVhZGluZyA9IHNlbGYub3B0Z3JvdXBzW29wdGdyb3VwXTtcbiAgICAgICAgICAgIGlmIChncm91cF9oZWFkaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZ3JvdXBfb3B0aW9ucyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgICAgICBsZXQgaGVhZGVyID0gc2VsZi5yZW5kZXIoJ29wdGdyb3VwX2hlYWRlcicsIGdyb3VwX2hlYWRpbmcpO1xuICAgICAgICAgICAgICAgIGFwcGVuZChncm91cF9vcHRpb25zLCBoZWFkZXIpO1xuICAgICAgICAgICAgICAgIGFwcGVuZChncm91cF9vcHRpb25zLCBncm91cF9mcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgbGV0IGdyb3VwX2h0bWwgPSBzZWxmLnJlbmRlcignb3B0Z3JvdXAnLCB7IGdyb3VwOiBncm91cF9oZWFkaW5nLCBvcHRpb25zOiBncm91cF9vcHRpb25zIH0pO1xuICAgICAgICAgICAgICAgIGFwcGVuZChodG1sLCBncm91cF9odG1sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFwcGVuZChodG1sLCBncm91cF9mcmFnbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBkcm9wZG93bl9jb250ZW50LmlubmVySFRNTCA9ICcnO1xuICAgICAgICBhcHBlbmQoZHJvcGRvd25fY29udGVudCwgaHRtbCk7XG4gICAgICAgIC8vIGhpZ2hsaWdodCBtYXRjaGluZyB0ZXJtcyBpbmxpbmVcbiAgICAgICAgaWYgKHNlbGYuc2V0dGluZ3MuaGlnaGxpZ2h0KSB7XG4gICAgICAgICAgICByZW1vdmVIaWdobGlnaHQoZHJvcGRvd25fY29udGVudCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0cy5xdWVyeS5sZW5ndGggJiYgcmVzdWx0cy50b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0ZShyZXN1bHRzLnRva2VucywgKHRvaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHQoZHJvcGRvd25fY29udGVudCwgdG9rLnJlZ2V4KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBoZWxwZXIgbWV0aG9kIGZvciBhZGRpbmcgdGVtcGxhdGVzIHRvIGRyb3Bkb3duXG4gICAgICAgIHZhciBhZGRfdGVtcGxhdGUgPSAodGVtcGxhdGUpID0+IHtcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gc2VsZi5yZW5kZXIodGVtcGxhdGUsIHsgaW5wdXQ6IHF1ZXJ5IH0pO1xuICAgICAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBzaG93X2Ryb3Bkb3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBkcm9wZG93bl9jb250ZW50Lmluc2VydEJlZm9yZShjb250ZW50LCBkcm9wZG93bl9jb250ZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGFkZCBsb2FkaW5nIG1lc3NhZ2VcbiAgICAgICAgaWYgKHNlbGYubG9hZGluZykge1xuICAgICAgICAgICAgYWRkX3RlbXBsYXRlKCdsb2FkaW5nJyk7XG4gICAgICAgICAgICAvLyBpbnZhbGlkIHF1ZXJ5XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXNlbGYuc2V0dGluZ3Muc2hvdWxkTG9hZC5jYWxsKHNlbGYsIHF1ZXJ5KSkge1xuICAgICAgICAgICAgYWRkX3RlbXBsYXRlKCdub3RfbG9hZGluZycpO1xuICAgICAgICAgICAgLy8gYWRkIG5vX3Jlc3VsdHMgbWVzc2FnZVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdHMuaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBhZGRfdGVtcGxhdGUoJ25vX3Jlc3VsdHMnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgY3JlYXRlIG9wdGlvblxuICAgICAgICBoYXNfY3JlYXRlX29wdGlvbiA9IHNlbGYuY2FuQ3JlYXRlKHF1ZXJ5KTtcbiAgICAgICAgaWYgKGhhc19jcmVhdGVfb3B0aW9uKSB7XG4gICAgICAgICAgICBjcmVhdGUgPSBhZGRfdGVtcGxhdGUoJ29wdGlvbl9jcmVhdGUnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhY3RpdmF0ZVxuICAgICAgICBzZWxmLmhhc09wdGlvbnMgPSByZXN1bHRzLml0ZW1zLmxlbmd0aCA+IDAgfHwgaGFzX2NyZWF0ZV9vcHRpb247XG4gICAgICAgIGlmIChzaG93X2Ryb3Bkb3duKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0cy5pdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhY3RpdmVfb3B0aW9uICYmIHNlbGYuc2V0dGluZ3MubW9kZSA9PT0gJ3NpbmdsZScgJiYgc2VsZi5pdGVtc1swXSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlX29wdGlvbiA9IHNlbGYuZ2V0T3B0aW9uKHNlbGYuaXRlbXNbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWRyb3Bkb3duX2NvbnRlbnQuY29udGFpbnMoYWN0aXZlX29wdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFjdGl2ZV9pbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjcmVhdGUgJiYgIXNlbGYuc2V0dGluZ3MuYWRkUHJlY2VkZW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlX2luZGV4ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhY3RpdmVfb3B0aW9uID0gc2VsZi5zZWxlY3RhYmxlKClbYWN0aXZlX2luZGV4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjcmVhdGUpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVfb3B0aW9uID0gY3JlYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyaWdnZXJEcm9wZG93biAmJiAhc2VsZi5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICBzZWxmLm9wZW4oKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNjcm9sbFRvT3B0aW9uKGFjdGl2ZV9vcHRpb24sICdhdXRvJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLnNldEFjdGl2ZU9wdGlvbihhY3RpdmVfb3B0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuY2xlYXJBY3RpdmVPcHRpb24oKTtcbiAgICAgICAgICAgIGlmICh0cmlnZ2VyRHJvcGRvd24gJiYgc2VsZi5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNsb3NlKGZhbHNlKTsgLy8gaWYgY3JlYXRlX29wdGlvbj1udWxsLCB3ZSB3YW50IHRoZSBkcm9wZG93biB0byBjbG9zZSBidXQgbm90IHJlc2V0IHRoZSB0ZXh0Ym94IHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGxpc3Qgb2Ygc2VsZWN0YWJsZSBvcHRpb25zXG4gICAgICpcbiAgICAgKi9cbiAgICBzZWxlY3RhYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kcm9wZG93bl9jb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNlbGVjdGFibGVdJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gYXZhaWxhYmxlIG9wdGlvbi4gSWYgaXQgYWxyZWFkeSBleGlzdHMsXG4gICAgICogbm90aGluZyB3aWxsIGhhcHBlbi4gTm90ZTogdGhpcyBkb2VzIG5vdCByZWZyZXNoXG4gICAgICogdGhlIG9wdGlvbnMgbGlzdCBkcm9wZG93biAodXNlIGByZWZyZXNoT3B0aW9uc2BcbiAgICAgKiBmb3IgdGhhdCkuXG4gICAgICpcbiAgICAgKiBVc2FnZTpcbiAgICAgKlxuICAgICAqICAgdGhpcy5hZGRPcHRpb24oZGF0YSlcbiAgICAgKlxuICAgICAqL1xuICAgIGFkZE9wdGlvbihkYXRhLCB1c2VyX2NyZWF0ZWQgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgLy8gQGRlcHJlY2F0ZWQgMS43LjdcbiAgICAgICAgLy8gdXNlIGFkZE9wdGlvbnMoIGFycmF5LCB1c2VyX2NyZWF0ZWQgKSBmb3IgYWRkaW5nIG11bHRpcGxlIG9wdGlvbnNcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIHNlbGYuYWRkT3B0aW9ucyhkYXRhLCB1c2VyX2NyZWF0ZWQpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleSA9IGhhc2hfa2V5KGRhdGFbc2VsZi5zZXR0aW5ncy52YWx1ZUZpZWxkXSk7XG4gICAgICAgIGlmIChrZXkgPT09IG51bGwgfHwgc2VsZi5vcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhLiRvcmRlciA9IGRhdGEuJG9yZGVyIHx8ICsrc2VsZi5vcmRlcjtcbiAgICAgICAgZGF0YS4kaWQgPSBzZWxmLmlucHV0SWQgKyAnLW9wdC0nICsgZGF0YS4kb3JkZXI7XG4gICAgICAgIHNlbGYub3B0aW9uc1trZXldID0gZGF0YTtcbiAgICAgICAgc2VsZi5sYXN0UXVlcnkgPSBudWxsO1xuICAgICAgICBpZiAodXNlcl9jcmVhdGVkKSB7XG4gICAgICAgICAgICBzZWxmLnVzZXJPcHRpb25zW2tleV0gPSB1c2VyX2NyZWF0ZWQ7XG4gICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ29wdGlvbl9hZGQnLCBrZXksIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBtdWx0aXBsZSBvcHRpb25zXG4gICAgICpcbiAgICAgKi9cbiAgICBhZGRPcHRpb25zKGRhdGEsIHVzZXJfY3JlYXRlZCA9IGZhbHNlKSB7XG4gICAgICAgIGl0ZXJhdGUoZGF0YSwgKGRhdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGRPcHRpb24oZGF0LCB1c2VyX2NyZWF0ZWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgMS43LjdcbiAgICAgKi9cbiAgICByZWdpc3Rlck9wdGlvbihkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE9wdGlvbihkYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGFuIG9wdGlvbiBncm91cCB0byB0aGUgcG9vbCBvZiBvcHRpb24gZ3JvdXBzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbnxzdHJpbmd9XG4gICAgICovXG4gICAgcmVnaXN0ZXJPcHRpb25Hcm91cChkYXRhKSB7XG4gICAgICAgIHZhciBrZXkgPSBoYXNoX2tleShkYXRhW3RoaXMuc2V0dGluZ3Mub3B0Z3JvdXBWYWx1ZUZpZWxkXSk7XG4gICAgICAgIGlmIChrZXkgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGRhdGEuJG9yZGVyID0gZGF0YS4kb3JkZXIgfHwgKyt0aGlzLm9yZGVyO1xuICAgICAgICB0aGlzLm9wdGdyb3Vwc1trZXldID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgbmV3IG9wdGdyb3VwIGZvciBvcHRpb25zXG4gICAgICogdG8gYmUgYnVja2V0ZWQgaW50by5cbiAgICAgKlxuICAgICAqL1xuICAgIGFkZE9wdGlvbkdyb3VwKGlkLCBkYXRhKSB7XG4gICAgICAgIHZhciBoYXNoZWRfaWQ7XG4gICAgICAgIGRhdGFbdGhpcy5zZXR0aW5ncy5vcHRncm91cFZhbHVlRmllbGRdID0gaWQ7XG4gICAgICAgIGlmIChoYXNoZWRfaWQgPSB0aGlzLnJlZ2lzdGVyT3B0aW9uR3JvdXAoZGF0YSkpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignb3B0Z3JvdXBfYWRkJywgaGFzaGVkX2lkLCBkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGV4aXN0aW5nIG9wdGlvbiBncm91cC5cbiAgICAgKlxuICAgICAqL1xuICAgIHJlbW92ZU9wdGlvbkdyb3VwKGlkKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm9wdGdyb3Vwc1tpZF07XG4gICAgICAgICAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignb3B0Z3JvdXBfcmVtb3ZlJywgaWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgZXhpc3Rpbmcgb3B0aW9uIGdyb3Vwcy5cbiAgICAgKi9cbiAgICBjbGVhck9wdGlvbkdyb3VwcygpIHtcbiAgICAgICAgdGhpcy5vcHRncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy5jbGVhckNhY2hlKCk7XG4gICAgICAgIHRoaXMudHJpZ2dlcignb3B0Z3JvdXBfY2xlYXInKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhbiBvcHRpb24gYXZhaWxhYmxlIGZvciBzZWxlY3Rpb24uIElmXG4gICAgICogaXQgaXMgdmlzaWJsZSBpbiB0aGUgc2VsZWN0ZWQgaXRlbXMgb3Igb3B0aW9uc1xuICAgICAqIGRyb3Bkb3duLCBpdCB3aWxsIGJlIHJlLXJlbmRlcmVkIGF1dG9tYXRpY2FsbHkuXG4gICAgICpcbiAgICAgKi9cbiAgICB1cGRhdGVPcHRpb24odmFsdWUsIGRhdGEpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBpdGVtX25ldztcbiAgICAgICAgdmFyIGluZGV4X2l0ZW07XG4gICAgICAgIGNvbnN0IHZhbHVlX29sZCA9IGhhc2hfa2V5KHZhbHVlKTtcbiAgICAgICAgY29uc3QgdmFsdWVfbmV3ID0gaGFzaF9rZXkoZGF0YVtzZWxmLnNldHRpbmdzLnZhbHVlRmllbGRdKTtcbiAgICAgICAgLy8gc2FuaXR5IGNoZWNrc1xuICAgICAgICBpZiAodmFsdWVfb2xkID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBkYXRhX29sZCA9IHNlbGYub3B0aW9uc1t2YWx1ZV9vbGRdO1xuICAgICAgICBpZiAoZGF0YV9vbGQgPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlX25ldyAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIG11c3QgYmUgc2V0IGluIG9wdGlvbiBkYXRhJyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IHNlbGYuZ2V0T3B0aW9uKHZhbHVlX29sZCk7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBzZWxmLmdldEl0ZW0odmFsdWVfb2xkKTtcbiAgICAgICAgZGF0YS4kb3JkZXIgPSBkYXRhLiRvcmRlciB8fCBkYXRhX29sZC4kb3JkZXI7XG4gICAgICAgIGRlbGV0ZSBzZWxmLm9wdGlvbnNbdmFsdWVfb2xkXTtcbiAgICAgICAgLy8gaW52YWxpZGF0ZSByZW5kZXIgY2FjaGVcbiAgICAgICAgLy8gZG9uJ3QgcmVtb3ZlIGV4aXN0aW5nIG5vZGUgeWV0LCB3ZSdsbCByZW1vdmUgaXQgYWZ0ZXIgcmVwbGFjaW5nIGl0XG4gICAgICAgIHNlbGYudW5jYWNoZVZhbHVlKHZhbHVlX25ldyk7XG4gICAgICAgIHNlbGYub3B0aW9uc1t2YWx1ZV9uZXddID0gZGF0YTtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBvcHRpb24gaWYgaXQncyBpbiB0aGUgZHJvcGRvd25cbiAgICAgICAgaWYgKG9wdGlvbikge1xuICAgICAgICAgICAgaWYgKHNlbGYuZHJvcGRvd25fY29udGVudC5jb250YWlucyhvcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9uX25ldyA9IHNlbGYuX3JlbmRlcignb3B0aW9uJywgZGF0YSk7XG4gICAgICAgICAgICAgICAgcmVwbGFjZU5vZGUob3B0aW9uLCBvcHRpb25fbmV3KTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5hY3RpdmVPcHRpb24gPT09IG9wdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNldEFjdGl2ZU9wdGlvbihvcHRpb25fbmV3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb24ucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBpdGVtIGlmIHdlIGhhdmUgb25lXG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICBpbmRleF9pdGVtID0gc2VsZi5pdGVtcy5pbmRleE9mKHZhbHVlX29sZCk7XG4gICAgICAgICAgICBpZiAoaW5kZXhfaXRlbSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzZWxmLml0ZW1zLnNwbGljZShpbmRleF9pdGVtLCAxLCB2YWx1ZV9uZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbV9uZXcgPSBzZWxmLl9yZW5kZXIoJ2l0ZW0nLCBkYXRhKTtcbiAgICAgICAgICAgIGlmIChpdGVtLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykpXG4gICAgICAgICAgICAgICAgYWRkQ2xhc3NlcyhpdGVtX25ldywgJ2FjdGl2ZScpO1xuICAgICAgICAgICAgcmVwbGFjZU5vZGUoaXRlbSwgaXRlbV9uZXcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGludmFsaWRhdGUgbGFzdCBxdWVyeSBiZWNhdXNlIHdlIG1pZ2h0IGhhdmUgdXBkYXRlZCB0aGUgc29ydEZpZWxkXG4gICAgICAgIHNlbGYubGFzdFF1ZXJ5ID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHNpbmdsZSBvcHRpb24uXG4gICAgICpcbiAgICAgKi9cbiAgICByZW1vdmVPcHRpb24odmFsdWUsIHNpbGVudCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgdmFsdWUgPSBnZXRfaGFzaCh2YWx1ZSk7XG4gICAgICAgIHNlbGYudW5jYWNoZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgZGVsZXRlIHNlbGYudXNlck9wdGlvbnNbdmFsdWVdO1xuICAgICAgICBkZWxldGUgc2VsZi5vcHRpb25zW3ZhbHVlXTtcbiAgICAgICAgc2VsZi5sYXN0UXVlcnkgPSBudWxsO1xuICAgICAgICBzZWxmLnRyaWdnZXIoJ29wdGlvbl9yZW1vdmUnLCB2YWx1ZSk7XG4gICAgICAgIHNlbGYucmVtb3ZlSXRlbSh2YWx1ZSwgc2lsZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCBvcHRpb25zLlxuICAgICAqL1xuICAgIGNsZWFyT3B0aW9ucyhmaWx0ZXIpIHtcbiAgICAgICAgY29uc3QgYm91bmRGaWx0ZXIgPSAoZmlsdGVyIHx8IHRoaXMuY2xlYXJGaWx0ZXIpLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubG9hZGVkU2VhcmNoZXMgPSB7fTtcbiAgICAgICAgdGhpcy51c2VyT3B0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSB7fTtcbiAgICAgICAgaXRlcmF0ZSh0aGlzLm9wdGlvbnMsIChvcHRpb24sIGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKGJvdW5kRmlsdGVyKG9wdGlvbiwga2V5KSkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkW2tleV0gPSBvcHRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLnNpZnRlci5pdGVtcyA9IHNlbGVjdGVkO1xuICAgICAgICB0aGlzLmxhc3RRdWVyeSA9IG51bGw7XG4gICAgICAgIHRoaXMudHJpZ2dlcignb3B0aW9uX2NsZWFyJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgY2xlYXJPcHRpb25zKCkgdG8gZGVjaWRlIHdoZXRoZXIgb3Igbm90IGFuIG9wdGlvbiBzaG91bGQgYmUgcmVtb3ZlZFxuICAgICAqIFJldHVybiB0cnVlIHRvIGtlZXAgYW4gb3B0aW9uLCBmYWxzZSB0byByZW1vdmVcbiAgICAgKlxuICAgICAqL1xuICAgIGNsZWFyRmlsdGVyKG9wdGlvbiwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXRlbXMuaW5kZXhPZih2YWx1ZSkgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkb20gZWxlbWVudCBvZiB0aGUgb3B0aW9uXG4gICAgICogbWF0Y2hpbmcgdGhlIGdpdmVuIHZhbHVlLlxuICAgICAqXG4gICAgICovXG4gICAgZ2V0T3B0aW9uKHZhbHVlLCBjcmVhdGUgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBoYXNoZWQgPSBoYXNoX2tleSh2YWx1ZSk7XG4gICAgICAgIGlmIChoYXNoZWQgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gdGhpcy5vcHRpb25zW2hhc2hlZF07XG4gICAgICAgIGlmIChvcHRpb24gIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9uLiRkaXYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9uLiRkaXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcignb3B0aW9uJywgb3B0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZG9tIGVsZW1lbnQgb2YgdGhlIG5leHQgb3IgcHJldmlvdXMgZG9tIGVsZW1lbnQgb2YgdGhlIHNhbWUgdHlwZVxuICAgICAqIE5vdGU6IGFkamFjZW50IG9wdGlvbnMgbWF5IG5vdCBiZSBhZGphY2VudCBET00gZWxlbWVudHMgKG9wdGdyb3VwcylcbiAgICAgKlxuICAgICAqL1xuICAgIGdldEFkamFjZW50KG9wdGlvbiwgZGlyZWN0aW9uLCB0eXBlID0gJ29wdGlvbicpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBhbGw7XG4gICAgICAgIGlmICghb3B0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PSAnaXRlbScpIHtcbiAgICAgICAgICAgIGFsbCA9IHNlbGYuY29udHJvbENoaWxkcmVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhbGwgPSBzZWxmLmRyb3Bkb3duX2NvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2VsZWN0YWJsZV0nKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGFsbFtpXSAhPSBvcHRpb24pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFsbFtpICsgMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWxsW2kgLSAxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZG9tIGVsZW1lbnQgb2YgdGhlIGl0ZW1cbiAgICAgKiBtYXRjaGluZyB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXRJdGVtKGl0ZW0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSBoYXNoX2tleShpdGVtKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSBudWxsXG4gICAgICAgICAgICA/IHRoaXMuY29udHJvbC5xdWVyeVNlbGVjdG9yKGBbZGF0YS12YWx1ZT1cIiR7YWRkU2xhc2hlcyh2YWx1ZSl9XCJdYClcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogXCJTZWxlY3RzXCIgbXVsdGlwbGUgaXRlbXMgYXQgb25jZS4gQWRkcyB0aGVtIHRvIHRoZSBsaXN0XG4gICAgICogYXQgdGhlIGN1cnJlbnQgY2FyZXQgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKi9cbiAgICBhZGRJdGVtcyh2YWx1ZXMsIHNpbGVudCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBpdGVtcyA9IEFycmF5LmlzQXJyYXkodmFsdWVzKSA/IHZhbHVlcyA6IFt2YWx1ZXNdO1xuICAgICAgICBpdGVtcyA9IGl0ZW1zLmZpbHRlcih4ID0+IHNlbGYuaXRlbXMuaW5kZXhPZih4KSA9PT0gLTEpO1xuICAgICAgICBjb25zdCBsYXN0X2l0ZW0gPSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIHNlbGYuaXNQZW5kaW5nID0gKGl0ZW0gIT09IGxhc3RfaXRlbSk7XG4gICAgICAgICAgICBzZWxmLmFkZEl0ZW0oaXRlbSwgc2lsZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFwiU2VsZWN0c1wiIGFuIGl0ZW0uIEFkZHMgaXQgdG8gdGhlIGxpc3RcbiAgICAgKiBhdCB0aGUgY3VycmVudCBjYXJldCBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqL1xuICAgIGFkZEl0ZW0odmFsdWUsIHNpbGVudCkge1xuICAgICAgICB2YXIgZXZlbnRzID0gc2lsZW50ID8gW10gOiBbJ2NoYW5nZScsICdkcm9wZG93bl9jbG9zZSddO1xuICAgICAgICBkZWJvdW5jZV9ldmVudHModGhpcywgZXZlbnRzLCAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgaXRlbSwgd2FzRnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRNb2RlID0gc2VsZi5zZXR0aW5ncy5tb2RlO1xuICAgICAgICAgICAgY29uc3QgaGFzaGVkID0gaGFzaF9rZXkodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGhhc2hlZCAmJiBzZWxmLml0ZW1zLmluZGV4T2YoaGFzaGVkKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRNb2RlID09PSAnc2luZ2xlJykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbnB1dE1vZGUgPT09ICdzaW5nbGUnIHx8ICFzZWxmLnNldHRpbmdzLmR1cGxpY2F0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNoZWQgPT09IG51bGwgfHwgIXNlbGYub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShoYXNoZWQpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChpbnB1dE1vZGUgPT09ICdzaW5nbGUnKVxuICAgICAgICAgICAgICAgIHNlbGYuY2xlYXIoc2lsZW50KTtcbiAgICAgICAgICAgIGlmIChpbnB1dE1vZGUgPT09ICdtdWx0aScgJiYgc2VsZi5pc0Z1bGwoKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpdGVtID0gc2VsZi5fcmVuZGVyKCdpdGVtJywgc2VsZi5vcHRpb25zW2hhc2hlZF0pO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29udHJvbC5jb250YWlucyhpdGVtKSkgeyAvLyBkdXBsaWNhdGVzXG4gICAgICAgICAgICAgICAgaXRlbSA9IGl0ZW0uY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2FzRnVsbCA9IHNlbGYuaXNGdWxsKCk7XG4gICAgICAgICAgICBzZWxmLml0ZW1zLnNwbGljZShzZWxmLmNhcmV0UG9zLCAwLCBoYXNoZWQpO1xuICAgICAgICAgICAgc2VsZi5pbnNlcnRBdENhcmV0KGl0ZW0pO1xuICAgICAgICAgICAgaWYgKHNlbGYuaXNTZXR1cCkge1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBtZW51IC8gcmVtb3ZlIHRoZSBvcHRpb24gKGlmIHRoaXMgaXMgbm90IG9uZSBpdGVtIGJlaW5nIGFkZGVkIGFzIHBhcnQgb2Ygc2VyaWVzKVxuICAgICAgICAgICAgICAgIGlmICghc2VsZi5pc1BlbmRpbmcgJiYgc2VsZi5zZXR0aW5ncy5oaWRlU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9wdGlvbiA9IHNlbGYuZ2V0T3B0aW9uKGhhc2hlZCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gc2VsZi5nZXRBZGphY2VudChvcHRpb24sIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXRBY3RpdmVPcHRpb24obmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmVmcmVzaE9wdGlvbnMgYWZ0ZXIgc2V0QWN0aXZlT3B0aW9uKCksXG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHNldEFjdGl2ZU9wdGlvbigpIHdpbGwgYmUgY2FsbGVkIGJ5IHJlZnJlc2hPcHRpb25zKCkgd2l0aCB0aGUgd3JvbmcgdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGYuaXNQZW5kaW5nICYmICFzZWxmLnNldHRpbmdzLmNsb3NlQWZ0ZXJTZWxlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZWZyZXNoT3B0aW9ucyhzZWxmLmlzRm9jdXNlZCAmJiBpbnB1dE1vZGUgIT09ICdzaW5nbGUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaGlkZSB0aGUgbWVudSBpZiB0aGUgbWF4aW11bSBudW1iZXIgb2YgaXRlbXMgaGF2ZSBiZWVuIHNlbGVjdGVkIG9yIG5vIG9wdGlvbnMgYXJlIGxlZnRcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5zZXR0aW5ncy5jbG9zZUFmdGVyU2VsZWN0ICE9IGZhbHNlICYmIHNlbGYuaXNGdWxsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghc2VsZi5pc1BlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wb3NpdGlvbkRyb3Bkb3duKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcignaXRlbV9hZGQnLCBoYXNoZWQsIGl0ZW0pO1xuICAgICAgICAgICAgICAgIGlmICghc2VsZi5pc1BlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi51cGRhdGVPcmlnaW5hbElucHV0KHsgc2lsZW50OiBzaWxlbnQgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzZWxmLmlzUGVuZGluZyB8fCAoIXdhc0Z1bGwgJiYgc2VsZi5pc0Z1bGwoKSkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmlucHV0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBzZWxmLnJlZnJlc2hTdGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgc2VsZWN0ZWQgaXRlbSBtYXRjaGluZ1xuICAgICAqIHRoZSBwcm92aWRlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqL1xuICAgIHJlbW92ZUl0ZW0oaXRlbSA9IG51bGwsIHNpbGVudCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgaXRlbSA9IHNlbGYuZ2V0SXRlbShpdGVtKTtcbiAgICAgICAgaWYgKCFpdGVtKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgaSwgaWR4O1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGl0ZW0uZGF0YXNldC52YWx1ZTtcbiAgICAgICAgaSA9IG5vZGVJbmRleChpdGVtKTtcbiAgICAgICAgaXRlbS5yZW1vdmUoKTtcbiAgICAgICAgaWYgKGl0ZW0uY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSkge1xuICAgICAgICAgICAgaWR4ID0gc2VsZi5hY3RpdmVJdGVtcy5pbmRleE9mKGl0ZW0pO1xuICAgICAgICAgICAgc2VsZi5hY3RpdmVJdGVtcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIHJlbW92ZUNsYXNzZXMoaXRlbSwgJ2FjdGl2ZScpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuaXRlbXMuc3BsaWNlKGksIDEpO1xuICAgICAgICBzZWxmLmxhc3RRdWVyeSA9IG51bGw7XG4gICAgICAgIGlmICghc2VsZi5zZXR0aW5ncy5wZXJzaXN0ICYmIHNlbGYudXNlck9wdGlvbnMuaGFzT3duUHJvcGVydHkodmFsdWUpKSB7XG4gICAgICAgICAgICBzZWxmLnJlbW92ZU9wdGlvbih2YWx1ZSwgc2lsZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA8IHNlbGYuY2FyZXRQb3MpIHtcbiAgICAgICAgICAgIHNlbGYuc2V0Q2FyZXQoc2VsZi5jYXJldFBvcyAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYudXBkYXRlT3JpZ2luYWxJbnB1dCh7IHNpbGVudDogc2lsZW50IH0pO1xuICAgICAgICBzZWxmLnJlZnJlc2hTdGF0ZSgpO1xuICAgICAgICBzZWxmLnBvc2l0aW9uRHJvcGRvd24oKTtcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdpdGVtX3JlbW92ZScsIHZhbHVlLCBpdGVtKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgYGNyZWF0ZWAgbWV0aG9kIHByb3ZpZGVkIGluIHRoZVxuICAgICAqIFRvbVNlbGVjdCBvcHRpb25zIHRoYXQgc2hvdWxkIHByb3ZpZGUgdGhlIGRhdGFcbiAgICAgKiBmb3IgdGhlIG5ldyBpdGVtLCBnaXZlbiB0aGUgdXNlciBpbnB1dC5cbiAgICAgKlxuICAgICAqIE9uY2UgdGhpcyBjb21wbGV0ZXMsIGl0IHdpbGwgYmUgYWRkZWRcbiAgICAgKiB0byB0aGUgaXRlbSBsaXN0LlxuICAgICAqXG4gICAgICovXG4gICAgY3JlYXRlSXRlbShpbnB1dCA9IG51bGwsIGNhbGxiYWNrID0gKCkgPT4geyB9KSB7XG4gICAgICAgIC8vIHRyaWdnZXJEcm9wZG93biBwYXJhbWV0ZXIgQGRlcHJlY2F0ZWQgMi4xLjFcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gYXJndW1lbnRzWzJdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSAoKSA9PiB7IH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgY2FyZXQgPSBzZWxmLmNhcmV0UG9zO1xuICAgICAgICB2YXIgb3V0cHV0O1xuICAgICAgICBpbnB1dCA9IGlucHV0IHx8IHNlbGYuaW5wdXRWYWx1ZSgpO1xuICAgICAgICBpZiAoIXNlbGYuY2FuQ3JlYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmxvY2soKTtcbiAgICAgICAgdmFyIGNyZWF0ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGNyZWF0ZSA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICBzZWxmLnVubG9jaygpO1xuICAgICAgICAgICAgaWYgKCFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGhhc2hfa2V5KGRhdGFbc2VsZi5zZXR0aW5ncy52YWx1ZUZpZWxkXSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5zZXRUZXh0Ym94VmFsdWUoKTtcbiAgICAgICAgICAgIHNlbGYuYWRkT3B0aW9uKGRhdGEsIHRydWUpO1xuICAgICAgICAgICAgc2VsZi5zZXRDYXJldChjYXJldCk7XG4gICAgICAgICAgICBzZWxmLmFkZEl0ZW0odmFsdWUpO1xuICAgICAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgICBjcmVhdGVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWxmLnNldHRpbmdzLmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb3V0cHV0ID0gc2VsZi5zZXR0aW5ncy5jcmVhdGUuY2FsbCh0aGlzLCBpbnB1dCwgY3JlYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dCA9IHtcbiAgICAgICAgICAgICAgICBbc2VsZi5zZXR0aW5ncy5sYWJlbEZpZWxkXTogaW5wdXQsXG4gICAgICAgICAgICAgICAgW3NlbGYuc2V0dGluZ3MudmFsdWVGaWVsZF06IGlucHV0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNyZWF0ZWQpIHtcbiAgICAgICAgICAgIGNyZWF0ZShvdXRwdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZS1yZW5kZXJzIHRoZSBzZWxlY3RlZCBpdGVtIGxpc3RzLlxuICAgICAqL1xuICAgIHJlZnJlc2hJdGVtcygpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBzZWxmLmxhc3RRdWVyeSA9IG51bGw7XG4gICAgICAgIGlmIChzZWxmLmlzU2V0dXApIHtcbiAgICAgICAgICAgIHNlbGYuYWRkSXRlbXMoc2VsZi5pdGVtcyk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi51cGRhdGVPcmlnaW5hbElucHV0KCk7XG4gICAgICAgIHNlbGYucmVmcmVzaFN0YXRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYWxsIHN0YXRlLWRlcGVuZGVudCBhdHRyaWJ1dGVzXG4gICAgICogYW5kIENTUyBjbGFzc2VzLlxuICAgICAqL1xuICAgIHJlZnJlc2hTdGF0ZSgpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIHNlbGYucmVmcmVzaFZhbGlkaXR5U3RhdGUoKTtcbiAgICAgICAgY29uc3QgaXNGdWxsID0gc2VsZi5pc0Z1bGwoKTtcbiAgICAgICAgY29uc3QgaXNMb2NrZWQgPSBzZWxmLmlzTG9ja2VkO1xuICAgICAgICBzZWxmLndyYXBwZXIuY2xhc3NMaXN0LnRvZ2dsZSgncnRsJywgc2VsZi5ydGwpO1xuICAgICAgICBjb25zdCB3cmFwX2NsYXNzTGlzdCA9IHNlbGYud3JhcHBlci5jbGFzc0xpc3Q7XG4gICAgICAgIHdyYXBfY2xhc3NMaXN0LnRvZ2dsZSgnZm9jdXMnLCBzZWxmLmlzRm9jdXNlZCk7XG4gICAgICAgIHdyYXBfY2xhc3NMaXN0LnRvZ2dsZSgnZGlzYWJsZWQnLCBzZWxmLmlzRGlzYWJsZWQpO1xuICAgICAgICB3cmFwX2NsYXNzTGlzdC50b2dnbGUoJ3JlYWRvbmx5Jywgc2VsZi5pc1JlYWRPbmx5KTtcbiAgICAgICAgd3JhcF9jbGFzc0xpc3QudG9nZ2xlKCdyZXF1aXJlZCcsIHNlbGYuaXNSZXF1aXJlZCk7XG4gICAgICAgIHdyYXBfY2xhc3NMaXN0LnRvZ2dsZSgnaW52YWxpZCcsICFzZWxmLmlzVmFsaWQpO1xuICAgICAgICB3cmFwX2NsYXNzTGlzdC50b2dnbGUoJ2xvY2tlZCcsIGlzTG9ja2VkKTtcbiAgICAgICAgd3JhcF9jbGFzc0xpc3QudG9nZ2xlKCdmdWxsJywgaXNGdWxsKTtcbiAgICAgICAgd3JhcF9jbGFzc0xpc3QudG9nZ2xlKCdpbnB1dC1hY3RpdmUnLCBzZWxmLmlzRm9jdXNlZCAmJiAhc2VsZi5pc0lucHV0SGlkZGVuKTtcbiAgICAgICAgd3JhcF9jbGFzc0xpc3QudG9nZ2xlKCdkcm9wZG93bi1hY3RpdmUnLCBzZWxmLmlzT3Blbik7XG4gICAgICAgIHdyYXBfY2xhc3NMaXN0LnRvZ2dsZSgnaGFzLW9wdGlvbnMnLCBpc0VtcHR5T2JqZWN0KHNlbGYub3B0aW9ucykpO1xuICAgICAgICB3cmFwX2NsYXNzTGlzdC50b2dnbGUoJ2hhcy1pdGVtcycsIHNlbGYuaXRlbXMubGVuZ3RoID4gMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgYHJlcXVpcmVkYCBhdHRyaWJ1dGUgb2YgYm90aCBpbnB1dCBhbmQgY29udHJvbCBpbnB1dC5cbiAgICAgKlxuICAgICAqIFRoZSBgcmVxdWlyZWRgIHByb3BlcnR5IG5lZWRzIHRvIGJlIGFjdGl2YXRlZCBvbiB0aGUgY29udHJvbCBpbnB1dFxuICAgICAqIGZvciB0aGUgZXJyb3IgdG8gYmUgZGlzcGxheWVkIGF0IHRoZSByaWdodCBwbGFjZS4gYHJlcXVpcmVkYCBhbHNvXG4gICAgICogbmVlZHMgdG8gYmUgdGVtcG9yYXJpbHkgZGVhY3RpdmF0ZWQgb24gdGhlIGlucHV0IHNpbmNlIHRoZSBpbnB1dCBpc1xuICAgICAqIGhpZGRlbiBhbmQgY2FuJ3Qgc2hvdyBlcnJvcnMuXG4gICAgICovXG4gICAgcmVmcmVzaFZhbGlkaXR5U3RhdGUoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCFzZWxmLmlucHV0LnZhbGlkaXR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5pc1ZhbGlkID0gc2VsZi5pbnB1dC52YWxpZGl0eS52YWxpZDtcbiAgICAgICAgc2VsZi5pc0ludmFsaWQgPSAhc2VsZi5pc1ZhbGlkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IG1vcmUgaXRlbXMgY2FuIGJlIGFkZGVkXG4gICAgICogdG8gdGhlIGNvbnRyb2wgd2l0aG91dCBleGNlZWRpbmcgdGhlIHVzZXItZGVmaW5lZCBtYXhpbXVtLlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNGdWxsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5tYXhJdGVtcyAhPT0gbnVsbCAmJiB0aGlzLml0ZW1zLmxlbmd0aCA+PSB0aGlzLnNldHRpbmdzLm1heEl0ZW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWZyZXNoZXMgdGhlIG9yaWdpbmFsIDxzZWxlY3Q+IG9yIDxpbnB1dD5cbiAgICAgKiBlbGVtZW50IHRvIHJlZmxlY3QgdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAgICpcbiAgICAgKi9cbiAgICB1cGRhdGVPcmlnaW5hbElucHV0KG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIG9wdGlvbiwgbGFiZWw7XG4gICAgICAgIGNvbnN0IGVtcHR5X29wdGlvbiA9IHNlbGYuaW5wdXQucXVlcnlTZWxlY3Rvcignb3B0aW9uW3ZhbHVlPVwiXCJdJyk7XG4gICAgICAgIGlmIChzZWxmLmlzX3NlbGVjdF90YWcpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkID0gW107XG4gICAgICAgICAgICBjb25zdCBoYXNfc2VsZWN0ZWQgPSBzZWxmLmlucHV0LnF1ZXJ5U2VsZWN0b3JBbGwoJ29wdGlvbjpjaGVja2VkJykubGVuZ3RoO1xuICAgICAgICAgICAgZnVuY3Rpb24gQWRkU2VsZWN0ZWQob3B0aW9uX2VsLCB2YWx1ZSwgbGFiZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbl9lbCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25fZWwgPSBnZXREb20oJzxvcHRpb24gdmFsdWU9XCInICsgZXNjYXBlX2h0bWwodmFsdWUpICsgJ1wiPicgKyBlc2NhcGVfaHRtbChsYWJlbCkgKyAnPC9vcHRpb24+Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGRvbid0IG1vdmUgZW1wdHkgb3B0aW9uIGZyb20gdG9wIG9mIGxpc3RcbiAgICAgICAgICAgICAgICAvLyBmaXhlcyBidWcgaW4gZmlyZWZveCBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzI1MjkzXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbl9lbCAhPSBlbXB0eV9vcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbnB1dC5hcHBlbmQob3B0aW9uX2VsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQucHVzaChvcHRpb25fZWwpO1xuICAgICAgICAgICAgICAgIC8vIG1hcmtpbmcgZW1wdHkgb3B0aW9uIGFzIHNlbGVjdGVkIGNhbiBicmVhayB2YWxpZGF0aW9uXG4gICAgICAgICAgICAgICAgLy8gZml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL29yY2hpZGpzL3RvbS1zZWxlY3QvaXNzdWVzLzMwM1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25fZWwgIT0gZW1wdHlfb3B0aW9uIHx8IGhhc19zZWxlY3RlZCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uX2VsLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbl9lbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVuc2VsZWN0IGFsbCBzZWxlY3RlZCBvcHRpb25zXG4gICAgICAgICAgICBzZWxmLmlucHV0LnF1ZXJ5U2VsZWN0b3JBbGwoJ29wdGlvbjpjaGVja2VkJykuZm9yRWFjaCgob3B0aW9uX2VsKSA9PiB7XG4gICAgICAgICAgICAgICAgb3B0aW9uX2VsLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgc2VsZWN0ZWQ/XG4gICAgICAgICAgICBpZiAoc2VsZi5pdGVtcy5sZW5ndGggPT0gMCAmJiBzZWxmLnNldHRpbmdzLm1vZGUgPT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICAgICAgICBBZGRTZWxlY3RlZChlbXB0eV9vcHRpb24sIFwiXCIsIFwiXCIpO1xuICAgICAgICAgICAgICAgIC8vIG9yZGVyIHNlbGVjdGVkIDxvcHRpb24+IHRhZ3MgZm9yIHZhbHVlcyBpbiBzZWxmLml0ZW1zXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLml0ZW1zLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbiA9IHNlbGYub3B0aW9uc1t2YWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsID0gb3B0aW9uW3NlbGYuc2V0dGluZ3MubGFiZWxGaWVsZF0gfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZC5pbmNsdWRlcyhvcHRpb24uJG9wdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldXNlX29wdCA9IHNlbGYuaW5wdXQucXVlcnlTZWxlY3Rvcihgb3B0aW9uW3ZhbHVlPVwiJHthZGRTbGFzaGVzKHZhbHVlKX1cIl06bm90KDpjaGVja2VkKWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgQWRkU2VsZWN0ZWQocmV1c2Vfb3B0LCB2YWx1ZSwgbGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uLiRvcHRpb24gPSBBZGRTZWxlY3RlZChvcHRpb24uJG9wdGlvbiwgdmFsdWUsIGxhYmVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5pbnB1dC52YWx1ZSA9IHNlbGYuZ2V0VmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5pc1NldHVwKSB7XG4gICAgICAgICAgICBpZiAoIW9wdHMuc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdjaGFuZ2UnLCBzZWxmLmdldFZhbHVlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIHRoZSBhdXRvY29tcGxldGUgZHJvcGRvd24gY29udGFpbmluZ1xuICAgICAqIHRoZSBhdmFpbGFibGUgb3B0aW9ucy5cbiAgICAgKi9cbiAgICBvcGVuKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChzZWxmLmlzTG9ja2VkIHx8IHNlbGYuaXNPcGVuIHx8IChzZWxmLnNldHRpbmdzLm1vZGUgPT09ICdtdWx0aScgJiYgc2VsZi5pc0Z1bGwoKSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHNlbGYuaXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgc2V0QXR0cihzZWxmLmZvY3VzX25vZGUsIHsgJ2FyaWEtZXhwYW5kZWQnOiAndHJ1ZScgfSk7XG4gICAgICAgIHNlbGYucmVmcmVzaFN0YXRlKCk7XG4gICAgICAgIGFwcGx5Q1NTKHNlbGYuZHJvcGRvd24sIHsgdmlzaWJpbGl0eTogJ2hpZGRlbicsIGRpc3BsYXk6ICdibG9jaycgfSk7XG4gICAgICAgIHNlbGYucG9zaXRpb25Ecm9wZG93bigpO1xuICAgICAgICBhcHBseUNTUyhzZWxmLmRyb3Bkb3duLCB7IHZpc2liaWxpdHk6ICd2aXNpYmxlJywgZGlzcGxheTogJ2Jsb2NrJyB9KTtcbiAgICAgICAgc2VsZi5mb2N1cygpO1xuICAgICAgICBzZWxmLnRyaWdnZXIoJ2Ryb3Bkb3duX29wZW4nLCBzZWxmLmRyb3Bkb3duKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBhdXRvY29tcGxldGUgZHJvcGRvd24gbWVudS5cbiAgICAgKi9cbiAgICBjbG9zZShzZXRUZXh0Ym94VmFsdWUgPSB0cnVlKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHRyaWdnZXIgPSBzZWxmLmlzT3BlbjtcbiAgICAgICAgaWYgKHNldFRleHRib3hWYWx1ZSkge1xuICAgICAgICAgICAgLy8gYmVmb3JlIGJsdXIoKSB0byBwcmV2ZW50IGZvcm0gb25jaGFuZ2UgZXZlbnRcbiAgICAgICAgICAgIHNlbGYuc2V0VGV4dGJveFZhbHVlKCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5zZXR0aW5ncy5tb2RlID09PSAnc2luZ2xlJyAmJiBzZWxmLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXRTdGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNlbGYuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgIHNldEF0dHIoc2VsZi5mb2N1c19ub2RlLCB7ICdhcmlhLWV4cGFuZGVkJzogJ2ZhbHNlJyB9KTtcbiAgICAgICAgYXBwbHlDU1Moc2VsZi5kcm9wZG93biwgeyBkaXNwbGF5OiAnbm9uZScgfSk7XG4gICAgICAgIGlmIChzZWxmLnNldHRpbmdzLmhpZGVTZWxlY3RlZCkge1xuICAgICAgICAgICAgc2VsZi5jbGVhckFjdGl2ZU9wdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYucmVmcmVzaFN0YXRlKCk7XG4gICAgICAgIGlmICh0cmlnZ2VyKVxuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdkcm9wZG93bl9jbG9zZScsIHNlbGYuZHJvcGRvd24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGFuZCBhcHBsaWVzIHRoZSBhcHByb3ByaWF0ZVxuICAgICAqIHBvc2l0aW9uIG9mIHRoZSBkcm9wZG93biBpZiBkcm9wZG93blBhcmVudCA9ICdib2R5Jy5cbiAgICAgKiBPdGhlcndpc2UsIHBvc2l0aW9uIGlzIGRldGVybWluZWQgYnkgY3NzXG4gICAgICovXG4gICAgcG9zaXRpb25Ecm9wZG93bigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZHJvcGRvd25QYXJlbnQgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250cm9sO1xuICAgICAgICB2YXIgcmVjdCA9IGNvbnRleHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciB0b3AgPSBjb250ZXh0Lm9mZnNldEhlaWdodCArIHJlY3QudG9wICsgd2luZG93LnNjcm9sbFk7XG4gICAgICAgIHZhciBsZWZ0ID0gcmVjdC5sZWZ0ICsgd2luZG93LnNjcm9sbFg7XG4gICAgICAgIGFwcGx5Q1NTKHRoaXMuZHJvcGRvd24sIHtcbiAgICAgICAgICAgIHdpZHRoOiByZWN0LndpZHRoICsgJ3B4JyxcbiAgICAgICAgICAgIHRvcDogdG9wICsgJ3B4JyxcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQgKyAncHgnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgLyBjbGVhcnMgYWxsIHNlbGVjdGVkIGl0ZW1zXG4gICAgICogZnJvbSB0aGUgY29udHJvbC5cbiAgICAgKlxuICAgICAqL1xuICAgIGNsZWFyKHNpbGVudCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICghc2VsZi5pdGVtcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBpdGVtcyA9IHNlbGYuY29udHJvbENoaWxkcmVuKCk7XG4gICAgICAgIGl0ZXJhdGUoaXRlbXMsIChpdGVtKSA9PiB7XG4gICAgICAgICAgICBzZWxmLnJlbW92ZUl0ZW0oaXRlbSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzZWxmLmlucHV0U3RhdGUoKTtcbiAgICAgICAgaWYgKCFzaWxlbnQpXG4gICAgICAgICAgICBzZWxmLnVwZGF0ZU9yaWdpbmFsSW5wdXQoKTtcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdjbGVhcicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGhlbHBlciBtZXRob2QgZm9yIGluc2VydGluZyBhbiBlbGVtZW50XG4gICAgICogYXQgdGhlIGN1cnJlbnQgY2FyZXQgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKi9cbiAgICBpbnNlcnRBdENhcmV0KGVsKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBjb25zdCBjYXJldCA9IHNlbGYuY2FyZXRQb3M7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHNlbGYuY29udHJvbDtcbiAgICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZShlbCwgdGFyZ2V0LmNoaWxkcmVuW2NhcmV0XSB8fCBudWxsKTtcbiAgICAgICAgc2VsZi5zZXRDYXJldChjYXJldCArIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBjdXJyZW50IHNlbGVjdGVkIGl0ZW0ocykuXG4gICAgICpcbiAgICAgKi9cbiAgICBkZWxldGVTZWxlY3Rpb24oZSkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uLCBzZWxlY3Rpb24sIGNhcmV0LCB0YWlsO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGRpcmVjdGlvbiA9IChlICYmIGUua2V5Q29kZSA9PT0gY29uc3RhbnRzLktFWV9CQUNLU1BBQ0UpID8gLTEgOiAxO1xuICAgICAgICBzZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb24oc2VsZi5jb250cm9sX2lucHV0KTtcbiAgICAgICAgLy8gZGV0ZXJtaW5lIGl0ZW1zIHRoYXQgd2lsbCBiZSByZW1vdmVkXG4gICAgICAgIGNvbnN0IHJtX2l0ZW1zID0gW107XG4gICAgICAgIGlmIChzZWxmLmFjdGl2ZUl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGFpbCA9IGdldFRhaWwoc2VsZi5hY3RpdmVJdGVtcywgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIGNhcmV0ID0gbm9kZUluZGV4KHRhaWwpO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICBjYXJldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlcmF0ZShzZWxmLmFjdGl2ZUl0ZW1zLCAoaXRlbSkgPT4gcm1faXRlbXMucHVzaChpdGVtKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHNlbGYuaXNGb2N1c2VkIHx8IHNlbGYuc2V0dGluZ3MubW9kZSA9PT0gJ3NpbmdsZScpICYmIHNlbGYuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IHNlbGYuY29udHJvbENoaWxkcmVuKCk7XG4gICAgICAgICAgICBsZXQgcm1faXRlbTtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPCAwICYmIHNlbGVjdGlvbi5zdGFydCA9PT0gMCAmJiBzZWxlY3Rpb24ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcm1faXRlbSA9IGl0ZW1zW3NlbGYuY2FyZXRQb3MgLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRpcmVjdGlvbiA+IDAgJiYgc2VsZWN0aW9uLnN0YXJ0ID09PSBzZWxmLmlucHV0VmFsdWUoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBybV9pdGVtID0gaXRlbXNbc2VsZi5jYXJldFBvc107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocm1faXRlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcm1faXRlbXMucHVzaChybV9pdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNlbGYuc2hvdWxkRGVsZXRlKHJtX2l0ZW1zLCBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHByZXZlbnREZWZhdWx0KGUsIHRydWUpO1xuICAgICAgICAvLyBwZXJmb3JtIHJlbW92YWxcbiAgICAgICAgaWYgKHR5cGVvZiBjYXJldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHNlbGYuc2V0Q2FyZXQoY2FyZXQpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChybV9pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNlbGYucmVtb3ZlSXRlbShybV9pdGVtcy5wb3AoKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5pbnB1dFN0YXRlKCk7XG4gICAgICAgIHNlbGYucG9zaXRpb25Ecm9wZG93bigpO1xuICAgICAgICBzZWxmLnJlZnJlc2hPcHRpb25zKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSBpdGVtcyBzaG91bGQgYmUgZGVsZXRlZFxuICAgICAqL1xuICAgIHNob3VsZERlbGV0ZShpdGVtcywgZXZ0KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGl0ZW1zLm1hcChpdGVtID0+IGl0ZW0uZGF0YXNldC52YWx1ZSk7XG4gICAgICAgIC8vIGFsbG93IHRoZSBjYWxsYmFjayB0byBhYm9ydFxuICAgICAgICBpZiAoIXZhbHVlcy5sZW5ndGggfHwgKHR5cGVvZiB0aGlzLnNldHRpbmdzLm9uRGVsZXRlID09PSAnZnVuY3Rpb24nICYmIHRoaXMuc2V0dGluZ3Mub25EZWxldGUodmFsdWVzLCBldnQpID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VsZWN0cyB0aGUgcHJldmlvdXMgLyBuZXh0IGl0ZW0gKGRlcGVuZGluZyBvbiB0aGUgYGRpcmVjdGlvbmAgYXJndW1lbnQpLlxuICAgICAqXG4gICAgICogPiAwIC0gcmlnaHRcbiAgICAgKiA8IDAgLSBsZWZ0XG4gICAgICpcbiAgICAgKi9cbiAgICBhZHZhbmNlU2VsZWN0aW9uKGRpcmVjdGlvbiwgZSkge1xuICAgICAgICB2YXIgbGFzdF9hY3RpdmUsIGFkamFjZW50LCBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKHNlbGYucnRsKVxuICAgICAgICAgICAgZGlyZWN0aW9uICo9IC0xO1xuICAgICAgICBpZiAoc2VsZi5pbnB1dFZhbHVlKCkubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBhZGQgb3IgcmVtb3ZlIHRvIGFjdGl2ZSBpdGVtc1xuICAgICAgICBpZiAoaXNLZXlEb3duKGNvbnN0YW50cy5LRVlfU0hPUlRDVVQsIGUpIHx8IGlzS2V5RG93bignc2hpZnRLZXknLCBlKSkge1xuICAgICAgICAgICAgbGFzdF9hY3RpdmUgPSBzZWxmLmdldExhc3RBY3RpdmUoZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChsYXN0X2FjdGl2ZSkge1xuICAgICAgICAgICAgICAgIGlmICghbGFzdF9hY3RpdmUuY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSkge1xuICAgICAgICAgICAgICAgICAgICBhZGphY2VudCA9IGxhc3RfYWN0aXZlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnQgPSBzZWxmLmdldEFkamFjZW50KGxhc3RfYWN0aXZlLCBkaXJlY3Rpb24sICdpdGVtJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIG5vIGFjdGl2ZSBpdGVtLCBnZXQgaXRlbXMgYWRqYWNlbnQgdG8gdGhlIGNvbnRyb2wgaW5wdXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRpcmVjdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICBhZGphY2VudCA9IHNlbGYuY29udHJvbF9pbnB1dC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGphY2VudCA9IHNlbGYuY29udHJvbF9pbnB1dC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFkamFjZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGFkamFjZW50LmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZW1vdmVBY3RpdmVJdGVtKGxhc3RfYWN0aXZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5zZXRBY3RpdmVJdGVtQ2xhc3MoYWRqYWNlbnQpOyAvLyBtYXJrIGFzIGxhc3RfYWN0aXZlICEhIGFmdGVyIHJlbW92ZUFjdGl2ZUl0ZW0oKSBvbiBsYXN0X2FjdGl2ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbW92ZSBjYXJldCB0byB0aGUgbGVmdCBvciByaWdodFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5tb3ZlQ2FyZXQoZGlyZWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3ZlQ2FyZXQoZGlyZWN0aW9uKSB7IH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGxhc3QgYWN0aXZlIGl0ZW1cbiAgICAgKlxuICAgICAqL1xuICAgIGdldExhc3RBY3RpdmUoZGlyZWN0aW9uKSB7XG4gICAgICAgIGxldCBsYXN0X2FjdGl2ZSA9IHRoaXMuY29udHJvbC5xdWVyeVNlbGVjdG9yKCcubGFzdC1hY3RpdmUnKTtcbiAgICAgICAgaWYgKGxhc3RfYWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFzdF9hY3RpdmU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY29udHJvbC5xdWVyeVNlbGVjdG9yQWxsKCcuYWN0aXZlJyk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRUYWlsKHJlc3VsdCwgZGlyZWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb3ZlcyB0aGUgY2FyZXQgdG8gdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICAgKlxuICAgICAqIFRoZSBpbnB1dCBtdXN0IGJlIG1vdmVkIGJ5IGxlYXZpbmcgaXQgaW4gcGxhY2UgYW5kIG1vdmluZyB0aGVcbiAgICAgKiBzaWJsaW5ncywgZHVlIHRvIHRoZSBmYWN0IHRoYXQgZm9jdXMgY2Fubm90IGJlIHJlc3RvcmVkIG9uY2UgbG9zdFxuICAgICAqIG9uIG1vYmlsZSB3ZWJraXQgZGV2aWNlc1xuICAgICAqXG4gICAgICovXG4gICAgc2V0Q2FyZXQobmV3X3Bvcykge1xuICAgICAgICB0aGlzLmNhcmV0UG9zID0gdGhpcy5pdGVtcy5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBsaXN0IG9mIGl0ZW0gZG9tIGVsZW1lbnRzXG4gICAgICpcbiAgICAgKi9cbiAgICBjb250cm9sQ2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuY29udHJvbC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS10cy1pdGVtXScpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMgdXNlciBpbnB1dCBvbiB0aGUgY29udHJvbC4gVXNlZCB3aGlsZVxuICAgICAqIGl0ZW1zIGFyZSBiZWluZyBhc3luY2hyb25vdXNseSBjcmVhdGVkLlxuICAgICAqL1xuICAgIGxvY2soKSB7XG4gICAgICAgIHRoaXMuc2V0TG9ja2VkKHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZS1lbmFibGVzIHVzZXIgaW5wdXQgb24gdGhlIGNvbnRyb2wuXG4gICAgICovXG4gICAgdW5sb2NrKCkge1xuICAgICAgICB0aGlzLnNldExvY2tlZChmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2FibGUgb3IgZW5hYmxlIHVzZXIgaW5wdXQgb24gdGhlIGNvbnRyb2xcbiAgICAgKi9cbiAgICBzZXRMb2NrZWQobG9jayA9IHRoaXMuaXNSZWFkT25seSB8fCB0aGlzLmlzRGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5pc0xvY2tlZCA9IGxvY2s7XG4gICAgICAgIHRoaXMucmVmcmVzaFN0YXRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2FibGVzIHVzZXIgaW5wdXQgb24gdGhlIGNvbnRyb2wgY29tcGxldGVseS5cbiAgICAgKiBXaGlsZSBkaXNhYmxlZCwgaXQgY2Fubm90IHJlY2VpdmUgZm9jdXMuXG4gICAgICovXG4gICAgZGlzYWJsZSgpIHtcbiAgICAgICAgdGhpcy5zZXREaXNhYmxlZCh0cnVlKTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIHRoZSBjb250cm9sIHNvIHRoYXQgaXQgY2FuIHJlc3BvbmRcbiAgICAgKiB0byBmb2N1cyBhbmQgdXNlciBpbnB1dC5cbiAgICAgKi9cbiAgICBlbmFibGUoKSB7XG4gICAgICAgIHRoaXMuc2V0RGlzYWJsZWQoZmFsc2UpO1xuICAgIH1cbiAgICBzZXREaXNhYmxlZChkaXNhYmxlZCkge1xuICAgICAgICB0aGlzLmZvY3VzX25vZGUudGFiSW5kZXggPSBkaXNhYmxlZCA/IC0xIDogdGhpcy50YWJJbmRleDtcbiAgICAgICAgdGhpcy5pc0Rpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgICAgIHRoaXMuaW5wdXQuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICAgICAgdGhpcy5jb250cm9sX2lucHV0LmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgICAgIHRoaXMuc2V0TG9ja2VkKCk7XG4gICAgfVxuICAgIHNldFJlYWRPbmx5KGlzUmVhZE9ubHkpIHtcbiAgICAgICAgdGhpcy5pc1JlYWRPbmx5ID0gaXNSZWFkT25seTtcbiAgICAgICAgdGhpcy5pbnB1dC5yZWFkT25seSA9IGlzUmVhZE9ubHk7XG4gICAgICAgIHRoaXMuY29udHJvbF9pbnB1dC5yZWFkT25seSA9IGlzUmVhZE9ubHk7XG4gICAgICAgIHRoaXMuc2V0TG9ja2VkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBsZXRlbHkgZGVzdHJveXMgdGhlIGNvbnRyb2wgYW5kXG4gICAgICogdW5iaW5kcyBhbGwgZXZlbnQgbGlzdGVuZXJzIHNvIHRoYXQgaXQgY2FuXG4gICAgICogYmUgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcmV2ZXJ0U2V0dGluZ3MgPSBzZWxmLnJldmVydFNldHRpbmdzO1xuICAgICAgICBzZWxmLnRyaWdnZXIoJ2Rlc3Ryb3knKTtcbiAgICAgICAgc2VsZi5vZmYoKTtcbiAgICAgICAgc2VsZi53cmFwcGVyLnJlbW92ZSgpO1xuICAgICAgICBzZWxmLmRyb3Bkb3duLnJlbW92ZSgpO1xuICAgICAgICBzZWxmLmlucHV0LmlubmVySFRNTCA9IHJldmVydFNldHRpbmdzLmlubmVySFRNTDtcbiAgICAgICAgc2VsZi5pbnB1dC50YWJJbmRleCA9IHJldmVydFNldHRpbmdzLnRhYkluZGV4O1xuICAgICAgICByZW1vdmVDbGFzc2VzKHNlbGYuaW5wdXQsICd0b21zZWxlY3RlZCcsICd0cy1oaWRkZW4tYWNjZXNzaWJsZScpO1xuICAgICAgICBzZWxmLl9kZXN0cm95KCk7XG4gICAgICAgIGRlbGV0ZSBzZWxmLmlucHV0LnRvbXNlbGVjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBoZWxwZXIgbWV0aG9kIGZvciByZW5kZXJpbmcgXCJpdGVtXCIgYW5kXG4gICAgICogXCJvcHRpb25cIiB0ZW1wbGF0ZXMsIGdpdmVuIHRoZSBkYXRhLlxuICAgICAqXG4gICAgICovXG4gICAgcmVuZGVyKHRlbXBsYXRlTmFtZSwgZGF0YSkge1xuICAgICAgICB2YXIgaWQsIGh0bWw7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuc2V0dGluZ3MucmVuZGVyW3RlbXBsYXRlTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbmRlciBtYXJrdXBcbiAgICAgICAgaHRtbCA9IHNlbGYuc2V0dGluZ3MucmVuZGVyW3RlbXBsYXRlTmFtZV0uY2FsbCh0aGlzLCBkYXRhLCBlc2NhcGVfaHRtbCk7XG4gICAgICAgIGlmICghaHRtbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaHRtbCA9IGdldERvbShodG1sKTtcbiAgICAgICAgLy8gYWRkIG1hbmRhdG9yeSBhdHRyaWJ1dGVzXG4gICAgICAgIGlmICh0ZW1wbGF0ZU5hbWUgPT09ICdvcHRpb24nIHx8IHRlbXBsYXRlTmFtZSA9PT0gJ29wdGlvbl9jcmVhdGUnKSB7XG4gICAgICAgICAgICBpZiAoZGF0YVtzZWxmLnNldHRpbmdzLmRpc2FibGVkRmllbGRdKSB7XG4gICAgICAgICAgICAgICAgc2V0QXR0cihodG1sLCB7ICdhcmlhLWRpc2FibGVkJzogJ3RydWUnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0QXR0cihodG1sLCB7ICdkYXRhLXNlbGVjdGFibGUnOiAnJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0ZW1wbGF0ZU5hbWUgPT09ICdvcHRncm91cCcpIHtcbiAgICAgICAgICAgIGlkID0gZGF0YS5ncm91cFtzZWxmLnNldHRpbmdzLm9wdGdyb3VwVmFsdWVGaWVsZF07XG4gICAgICAgICAgICBzZXRBdHRyKGh0bWwsIHsgJ2RhdGEtZ3JvdXAnOiBpZCB9KTtcbiAgICAgICAgICAgIGlmIChkYXRhLmdyb3VwW3NlbGYuc2V0dGluZ3MuZGlzYWJsZWRGaWVsZF0pIHtcbiAgICAgICAgICAgICAgICBzZXRBdHRyKGh0bWwsIHsgJ2RhdGEtZGlzYWJsZWQnOiAnJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGVtcGxhdGVOYW1lID09PSAnb3B0aW9uJyB8fCB0ZW1wbGF0ZU5hbWUgPT09ICdpdGVtJykge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRfaGFzaChkYXRhW3NlbGYuc2V0dGluZ3MudmFsdWVGaWVsZF0pO1xuICAgICAgICAgICAgc2V0QXR0cihodG1sLCB7ICdkYXRhLXZhbHVlJzogdmFsdWUgfSk7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2UgaGF2ZSBzb21lIGNsYXNzZXMgaWYgYSB0ZW1wbGF0ZSBpcyBvdmVyd3JpdHRlblxuICAgICAgICAgICAgaWYgKHRlbXBsYXRlTmFtZSA9PT0gJ2l0ZW0nKSB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3NlcyhodG1sLCBzZWxmLnNldHRpbmdzLml0ZW1DbGFzcyk7XG4gICAgICAgICAgICAgICAgc2V0QXR0cihodG1sLCB7ICdkYXRhLXRzLWl0ZW0nOiAnJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZENsYXNzZXMoaHRtbCwgc2VsZi5zZXR0aW5ncy5vcHRpb25DbGFzcyk7XG4gICAgICAgICAgICAgICAgc2V0QXR0cihodG1sLCB7XG4gICAgICAgICAgICAgICAgICAgIHJvbGU6ICdvcHRpb24nLFxuICAgICAgICAgICAgICAgICAgICBpZDogZGF0YS4kaWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgY2FjaGVcbiAgICAgICAgICAgICAgICBkYXRhLiRkaXYgPSBodG1sO1xuICAgICAgICAgICAgICAgIHNlbGYub3B0aW9uc1t2YWx1ZV0gPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBodG1sO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUeXBlIGd1YXJkZWQgcmVuZGVyaW5nXG4gICAgICpcbiAgICAgKi9cbiAgICBfcmVuZGVyKHRlbXBsYXRlTmFtZSwgZGF0YSkge1xuICAgICAgICBjb25zdCBodG1sID0gdGhpcy5yZW5kZXIodGVtcGxhdGVOYW1lLCBkYXRhKTtcbiAgICAgICAgaWYgKGh0bWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgJ0hUTUxFbGVtZW50IGV4cGVjdGVkJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSByZW5kZXIgY2FjaGUgZm9yIGEgdGVtcGxhdGUuIElmXG4gICAgICogbm8gdGVtcGxhdGUgaXMgZ2l2ZW4sIGNsZWFycyBhbGwgcmVuZGVyXG4gICAgICogY2FjaGVzLlxuICAgICAqXG4gICAgICovXG4gICAgY2xlYXJDYWNoZSgpIHtcbiAgICAgICAgaXRlcmF0ZSh0aGlzLm9wdGlvbnMsIChvcHRpb24pID0+IHtcbiAgICAgICAgICAgIGlmIChvcHRpb24uJGRpdikge1xuICAgICAgICAgICAgICAgIG9wdGlvbi4kZGl2LnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb24uJGRpdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSB2YWx1ZSBmcm9tIGl0ZW0gYW5kIG9wdGlvbiBjYWNoZXNcbiAgICAgKlxuICAgICAqL1xuICAgIHVuY2FjaGVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBvcHRpb25fZWwgPSB0aGlzLmdldE9wdGlvbih2YWx1ZSk7XG4gICAgICAgIGlmIChvcHRpb25fZWwpXG4gICAgICAgICAgICBvcHRpb25fZWwucmVtb3ZlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdG8gZGlzcGxheSB0aGVcbiAgICAgKiBjcmVhdGUgaXRlbSBwcm9tcHQsIGdpdmVuIGEgdXNlciBpbnB1dC5cbiAgICAgKlxuICAgICAqL1xuICAgIGNhbkNyZWF0ZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5jcmVhdGUgJiYgKGlucHV0Lmxlbmd0aCA+IDApICYmIHRoaXMuc2V0dGluZ3MuY3JlYXRlRmlsdGVyLmNhbGwodGhpcywgaW5wdXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcmFwcyB0aGlzLmBtZXRob2RgIHNvIHRoYXQgYG5ld19mbmAgY2FuIGJlIGludm9rZWQgJ2JlZm9yZScsICdhZnRlcicsIG9yICdpbnN0ZWFkJyBvZiB0aGUgb3JpZ2luYWwgbWV0aG9kXG4gICAgICpcbiAgICAgKiB0aGlzLmhvb2soJ2luc3RlYWQnLCdvbktleURvd24nLGZ1bmN0aW9uKCBhcmcxLCBhcmcyIC4uLil7XG4gICAgICpcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBob29rKHdoZW4sIG1ldGhvZCwgbmV3X2ZuKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIG9yaWdfbWV0aG9kID0gc2VsZlttZXRob2RdO1xuICAgICAgICBzZWxmW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCByZXN1bHRfbmV3O1xuICAgICAgICAgICAgaWYgKHdoZW4gPT09ICdhZnRlcicpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBvcmlnX21ldGhvZC5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0X25ldyA9IG5ld19mbi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKHdoZW4gPT09ICdpbnN0ZWFkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRfbmV3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdoZW4gPT09ICdiZWZvcmUnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gb3JpZ19tZXRob2QuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxufVxuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9tLXNlbGVjdC5qcy5tYXAiLCIvKipcbiAqIENvbnZlcnRzIGEgc2NhbGFyIHRvIGl0cyBiZXN0IHN0cmluZyByZXByZXNlbnRhdGlvblxuICogZm9yIGhhc2gga2V5cyBhbmQgSFRNTCBhdHRyaWJ1dGUgdmFsdWVzLlxuICpcbiAqIFRyYW5zZm9ybWF0aW9uczpcbiAqICAgJ3N0cicgICAgIC0+ICdzdHInXG4gKiAgIG51bGwgICAgICAtPiAnJ1xuICogICB1bmRlZmluZWQgLT4gJydcbiAqICAgdHJ1ZSAgICAgIC0+ICcxJ1xuICogICBmYWxzZSAgICAgLT4gJzAnXG4gKiAgIDAgICAgICAgICAtPiAnMCdcbiAqICAgMSAgICAgICAgIC0+ICcxJ1xuICpcbiAqL1xuZXhwb3J0IGNvbnN0IGhhc2hfa2V5ID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdmFsdWUgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBnZXRfaGFzaCh2YWx1ZSk7XG59O1xuZXhwb3J0IGNvbnN0IGdldF9oYXNoID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKVxuICAgICAgICByZXR1cm4gdmFsdWUgPyAnMScgOiAnMCc7XG4gICAgcmV0dXJuIHZhbHVlICsgJyc7XG59O1xuLyoqXG4gKiBFc2NhcGVzIGEgc3RyaW5nIGZvciB1c2Ugd2l0aGluIEhUTUwuXG4gKlxuICovXG5leHBvcnQgY29uc3QgZXNjYXBlX2h0bWwgPSAoc3RyKSA9PiB7XG4gICAgcmV0dXJuIChzdHIgKyAnJylcbiAgICAgICAgLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAgICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG59O1xuLyoqXG4gKiB1c2Ugc2V0VGltZW91dCBpZiB0aW1lb3V0ID4gMFxuICovXG5leHBvcnQgY29uc3QgdGltZW91dCA9IChmbiwgdGltZW91dCkgPT4ge1xuICAgIGlmICh0aW1lb3V0ID4gMCkge1xuICAgICAgICByZXR1cm4gd2luZG93LnNldFRpbWVvdXQoZm4sIHRpbWVvdXQpO1xuICAgIH1cbiAgICBmbi5jYWxsKG51bGwpO1xuICAgIHJldHVybiBudWxsO1xufTtcbi8qKlxuICogRGVib3VuY2UgdGhlIHVzZXIgcHJvdmlkZWQgbG9hZCBmdW5jdGlvblxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IGxvYWREZWJvdW5jZSA9IChmbiwgZGVsYXkpID0+IHtcbiAgICB2YXIgdGltZW91dDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICBzZWxmLmxvYWRpbmcgPSBNYXRoLm1heChzZWxmLmxvYWRpbmcgLSAxLCAwKTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIHNlbGYubG9hZGVkU2VhcmNoZXNbdmFsdWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIGZuLmNhbGwoc2VsZiwgdmFsdWUsIGNhbGxiYWNrKTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgIH07XG59O1xuLyoqXG4gKiBEZWJvdW5jZSBhbGwgZmlyZWQgZXZlbnRzIHR5cGVzIGxpc3RlZCBpbiBgdHlwZXNgXG4gKiB3aGlsZSBleGVjdXRpbmcgdGhlIHByb3ZpZGVkIGBmbmAuXG4gKlxuICovXG5leHBvcnQgY29uc3QgZGVib3VuY2VfZXZlbnRzID0gKHNlbGYsIHR5cGVzLCBmbikgPT4ge1xuICAgIHZhciB0eXBlO1xuICAgIHZhciB0cmlnZ2VyID0gc2VsZi50cmlnZ2VyO1xuICAgIHZhciBldmVudF9hcmdzID0ge307XG4gICAgLy8gb3ZlcnJpZGUgdHJpZ2dlciBtZXRob2RcbiAgICBzZWxmLnRyaWdnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0eXBlID0gYXJndW1lbnRzWzBdO1xuICAgICAgICBpZiAodHlwZXMuaW5kZXhPZih0eXBlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGV2ZW50X2FyZ3NbdHlwZV0gPSBhcmd1bWVudHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJpZ2dlci5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBpbnZva2UgcHJvdmlkZWQgZnVuY3Rpb25cbiAgICBmbi5hcHBseShzZWxmLCBbXSk7XG4gICAgc2VsZi50cmlnZ2VyID0gdHJpZ2dlcjtcbiAgICAvLyB0cmlnZ2VyIHF1ZXVlZCBldmVudHNcbiAgICBmb3IgKHR5cGUgb2YgdHlwZXMpIHtcbiAgICAgICAgaWYgKHR5cGUgaW4gZXZlbnRfYXJncykge1xuICAgICAgICAgICAgdHJpZ2dlci5hcHBseShzZWxmLCBldmVudF9hcmdzW3R5cGVdKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKipcbiAqIERldGVybWluZXMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHdpdGhpbiBhIHRleHQgaW5wdXQgY29udHJvbC5cbiAqIFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmc6XG4gKiAgIC0gc3RhcnRcbiAqICAgLSBsZW5ndGhcbiAqXG4gKiBOb3RlOiBcInNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQgLi4uIGFwcGx5IG9ubHkgdG8gaW5wdXRzIG9mIHR5cGVzIHRleHQsIHNlYXJjaCwgVVJMLCB0ZWwgYW5kIHBhc3N3b3JkXCJcbiAqIFx0LSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTElucHV0RWxlbWVudC9zZXRTZWxlY3Rpb25SYW5nZVxuICovXG5leHBvcnQgY29uc3QgZ2V0U2VsZWN0aW9uID0gKGlucHV0KSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0IHx8IDAsXG4gICAgICAgIGxlbmd0aDogKGlucHV0LnNlbGVjdGlvbkVuZCB8fCAwKSAtIChpbnB1dC5zZWxlY3Rpb25TdGFydCB8fCAwKSxcbiAgICB9O1xufTtcbi8qKlxuICogUHJldmVudCBkZWZhdWx0XG4gKlxuICovXG5leHBvcnQgY29uc3QgcHJldmVudERlZmF1bHQgPSAoZXZ0LCBzdG9wID0gZmFsc2UpID0+IHtcbiAgICBpZiAoZXZ0KSB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAoc3RvcCkge1xuICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICogQWRkIGV2ZW50IGhlbHBlclxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IGFkZEV2ZW50ID0gKHRhcmdldCwgdHlwZSwgY2FsbGJhY2ssIG9wdGlvbnMpID0+IHtcbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaywgb3B0aW9ucyk7XG59O1xuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgcmVxdWVzdGVkIGtleSBpcyBkb3duXG4gKiBXaWxsIHJldHVybiBmYWxzZSBpZiBtb3JlIHRoYW4gb25lIGNvbnRyb2wgY2hhcmFjdGVyIGlzIHByZXNzZWQgKCB3aGVuIFtjdHJsK3NoaWZ0K2FdICE9IFtjdHJsK2FdIClcbiAqIFRoZSBjdXJyZW50IGV2dCBtYXkgbm90IGFsd2F5cyBzZXQgKCBlZyBjYWxsaW5nIGFkdmFuY2VTZWxlY3Rpb24oKSApXG4gKlxuICovXG5leHBvcnQgY29uc3QgaXNLZXlEb3duID0gKGtleV9uYW1lLCBldnQpID0+IHtcbiAgICBpZiAoIWV2dCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghZXZ0W2tleV9uYW1lXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBjb3VudCA9IChldnQuYWx0S2V5ID8gMSA6IDApICsgKGV2dC5jdHJsS2V5ID8gMSA6IDApICsgKGV2dC5zaGlmdEtleSA/IDEgOiAwKSArIChldnQubWV0YUtleSA/IDEgOiAwKTtcbiAgICBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4vKipcbiAqIEdldCB0aGUgaWQgb2YgYW4gZWxlbWVudFxuICogSWYgdGhlIGlkIGF0dHJpYnV0ZSBpcyBub3Qgc2V0LCBzZXQgdGhlIGF0dHJpYnV0ZSB3aXRoIHRoZSBnaXZlbiBpZFxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IGdldElkID0gKGVsLCBpZCkgPT4ge1xuICAgIGNvbnN0IGV4aXN0aW5nX2lkID0gZWwuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgIGlmIChleGlzdGluZ19pZCkge1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdfaWQ7XG4gICAgfVxuICAgIGVsLnNldEF0dHJpYnV0ZSgnaWQnLCBpZCk7XG4gICAgcmV0dXJuIGlkO1xufTtcbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyB3aXRoIGJhY2tzbGFzaGVzIGFkZGVkIGJlZm9yZSBjaGFyYWN0ZXJzIHRoYXQgbmVlZCB0byBiZSBlc2NhcGVkLlxuICovXG5leHBvcnQgY29uc3QgYWRkU2xhc2hlcyA9IChzdHIpID0+IHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1tcXFxcXCInXS9nLCAnXFxcXCQmJyk7XG59O1xuLyoqXG4gKlxuICovXG5leHBvcnQgY29uc3QgYXBwZW5kID0gKHBhcmVudCwgbm9kZSkgPT4ge1xuICAgIGlmIChub2RlKVxuICAgICAgICBwYXJlbnQuYXBwZW5kKG5vZGUpO1xufTtcbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBhcnJheXMgYW5kIGhhc2hlcy5cbiAqXG4gKiBgYGBcbiAqIGl0ZXJhdGUodGhpcy5pdGVtcywgZnVuY3Rpb24oaXRlbSwgaWQpIHtcbiAqICAgIC8vIGludm9rZWQgZm9yIGVhY2ggaXRlbVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBpdGVyYXRlID0gKG9iamVjdCwgY2FsbGJhY2spID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIG9iamVjdC5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG9iamVjdFtrZXldLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsImltcG9ydCB7IGl0ZXJhdGUgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuLyoqXG4gKiBSZXR1cm4gYSBkb20gZWxlbWVudCBmcm9tIGVpdGhlciBhIGRvbSBxdWVyeSBzdHJpbmcsIGpRdWVyeSBvYmplY3QsIGEgZG9tIGVsZW1lbnQgb3IgaHRtbCBzdHJpbmdcbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ5NDE0My9jcmVhdGluZy1hLW5ldy1kb20tZWxlbWVudC1mcm9tLWFuLWh0bWwtc3RyaW5nLXVzaW5nLWJ1aWx0LWluLWRvbS1tZXRob2RzLW9yLXByby8zNTM4NTUxOCMzNTM4NTUxOFxuICpcbiAqIHBhcmFtIHF1ZXJ5IHNob3VsZCBiZSB7fVxuICovXG5leHBvcnQgY29uc3QgZ2V0RG9tID0gKHF1ZXJ5KSA9PiB7XG4gICAgaWYgKHF1ZXJ5LmpxdWVyeSkge1xuICAgICAgICByZXR1cm4gcXVlcnlbMF07XG4gICAgfVxuICAgIGlmIChxdWVyeSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBxdWVyeTtcbiAgICB9XG4gICAgaWYgKGlzSHRtbFN0cmluZyhxdWVyeSkpIHtcbiAgICAgICAgdmFyIHRwbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRwbC5pbm5lckhUTUwgPSBxdWVyeS50cmltKCk7IC8vIE5ldmVyIHJldHVybiBhIHRleHQgbm9kZSBvZiB3aGl0ZXNwYWNlIGFzIHRoZSByZXN1bHRcbiAgICAgICAgcmV0dXJuIHRwbC5jb250ZW50LmZpcnN0Q2hpbGQ7XG4gICAgfVxuICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHF1ZXJ5KTtcbn07XG5leHBvcnQgY29uc3QgaXNIdG1sU3RyaW5nID0gKGFyZykgPT4ge1xuICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJyAmJiBhcmcuaW5kZXhPZignPCcpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5leHBvcnQgY29uc3QgZXNjYXBlUXVlcnkgPSAocXVlcnkpID0+IHtcbiAgICByZXR1cm4gcXVlcnkucmVwbGFjZSgvWydcIlxcXFxdL2csICdcXFxcJCYnKTtcbn07XG4vKipcbiAqIERpc3BhdGNoIGFuIGV2ZW50XG4gKlxuICovXG5leHBvcnQgY29uc3QgdHJpZ2dlckV2ZW50ID0gKGRvbV9lbCwgZXZlbnRfbmFtZSkgPT4ge1xuICAgIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gICAgZXZlbnQuaW5pdEV2ZW50KGV2ZW50X25hbWUsIHRydWUsIGZhbHNlKTtcbiAgICBkb21fZWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG59O1xuLyoqXG4gKiBBcHBseSBDU1MgcnVsZXMgdG8gYSBkb20gZWxlbWVudFxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IGFwcGx5Q1NTID0gKGRvbV9lbCwgY3NzKSA9PiB7XG4gICAgT2JqZWN0LmFzc2lnbihkb21fZWwuc3R5bGUsIGNzcyk7XG59O1xuLyoqXG4gKiBBZGQgY3NzIGNsYXNzZXNcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBhZGRDbGFzc2VzID0gKGVsbXRzLCAuLi5jbGFzc2VzKSA9PiB7XG4gICAgdmFyIG5vcm1fY2xhc3NlcyA9IGNsYXNzZXNBcnJheShjbGFzc2VzKTtcbiAgICBlbG10cyA9IGNhc3RBc0FycmF5KGVsbXRzKTtcbiAgICBlbG10cy5tYXAoZWwgPT4ge1xuICAgICAgICBub3JtX2NsYXNzZXMubWFwKGNscyA9PiB7XG4gICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbi8qKlxuICogUmVtb3ZlIGNzcyBjbGFzc2VzXG4gKlxuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlQ2xhc3NlcyA9IChlbG10cywgLi4uY2xhc3NlcykgPT4ge1xuICAgIHZhciBub3JtX2NsYXNzZXMgPSBjbGFzc2VzQXJyYXkoY2xhc3Nlcyk7XG4gICAgZWxtdHMgPSBjYXN0QXNBcnJheShlbG10cyk7XG4gICAgZWxtdHMubWFwKGVsID0+IHtcbiAgICAgICAgbm9ybV9jbGFzc2VzLm1hcChjbHMgPT4ge1xuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG4vKipcbiAqIFJldHVybiBhcmd1bWVudHNcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBjbGFzc2VzQXJyYXkgPSAoYXJncykgPT4ge1xuICAgIHZhciBjbGFzc2VzID0gW107XG4gICAgaXRlcmF0ZShhcmdzLCAoX2NsYXNzZXMpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBfY2xhc3NlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIF9jbGFzc2VzID0gX2NsYXNzZXMudHJpbSgpLnNwbGl0KC9bXFx0XFxuXFxmXFxyXFxzXS8pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KF9jbGFzc2VzKSkge1xuICAgICAgICAgICAgY2xhc3NlcyA9IGNsYXNzZXMuY29uY2F0KF9jbGFzc2VzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjbGFzc2VzLmZpbHRlcihCb29sZWFuKTtcbn07XG4vKipcbiAqIENyZWF0ZSBhbiBhcnJheSBmcm9tIGFyZyBpZiBpdCdzIG5vdCBhbHJlYWR5IGFuIGFycmF5XG4gKlxuICovXG5leHBvcnQgY29uc3QgY2FzdEFzQXJyYXkgPSAoYXJnKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgYXJnID0gW2FyZ107XG4gICAgfVxuICAgIHJldHVybiBhcmc7XG59O1xuLyoqXG4gKiBHZXQgdGhlIGNsb3Nlc3Qgbm9kZSB0byB0aGUgZXZ0LnRhcmdldCBtYXRjaGluZyB0aGUgc2VsZWN0b3JcbiAqIFN0b3BzIGF0IHdyYXBwZXJcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBwYXJlbnRNYXRjaCA9ICh0YXJnZXQsIHNlbGVjdG9yLCB3cmFwcGVyKSA9PiB7XG4gICAgaWYgKHdyYXBwZXIgJiYgIXdyYXBwZXIuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHdoaWxlICh0YXJnZXQgJiYgdGFyZ2V0Lm1hdGNoZXMpIHtcbiAgICAgICAgaWYgKHRhcmdldC5tYXRjaGVzKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICB9XG59O1xuLyoqXG4gKiBHZXQgdGhlIGZpcnN0IG9yIGxhc3QgaXRlbSBmcm9tIGFuIGFycmF5XG4gKlxuICogPiAwIC0gcmlnaHQgKGxhc3QpXG4gKiA8PSAwIC0gbGVmdCAoZmlyc3QpXG4gKlxuICovXG5leHBvcnQgY29uc3QgZ2V0VGFpbCA9IChsaXN0LCBkaXJlY3Rpb24gPSAwKSA9PiB7XG4gICAgaWYgKGRpcmVjdGlvbiA+IDApIHtcbiAgICAgICAgcmV0dXJuIGxpc3RbbGlzdC5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3RbMF07XG59O1xuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiBhbiBvYmplY3QgaXMgZW1wdHlcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBpc0VtcHR5T2JqZWN0ID0gKG9iaikgPT4ge1xuICAgIHJldHVybiAoT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDApO1xufTtcbi8qKlxuICogR2V0IHRoZSBpbmRleCBvZiBhbiBlbGVtZW50IGFtb25nc3Qgc2libGluZyBub2RlcyBvZiB0aGUgc2FtZSB0eXBlXG4gKlxuICovXG5leHBvcnQgY29uc3Qgbm9kZUluZGV4ID0gKGVsLCBhbW9uZ3N0KSA9PiB7XG4gICAgaWYgKCFlbClcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIGFtb25nc3QgPSBhbW9uZ3N0IHx8IGVsLm5vZGVOYW1lO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoZWwgPSBlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSB7XG4gICAgICAgIGlmIChlbC5tYXRjaGVzKGFtb25nc3QpKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGk7XG59O1xuLyoqXG4gKiBTZXQgYXR0cmlidXRlcyBvZiBhbiBlbGVtZW50XG4gKlxuICovXG5leHBvcnQgY29uc3Qgc2V0QXR0ciA9IChlbCwgYXR0cnMpID0+IHtcbiAgICBpdGVyYXRlKGF0dHJzLCAodmFsLCBhdHRyKSA9PiB7XG4gICAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHIsICcnICsgdmFsKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbi8qKlxuICogUmVwbGFjZSBhIG5vZGVcbiAqL1xuZXhwb3J0IGNvbnN0IHJlcGxhY2VOb2RlID0gKGV4aXN0aW5nLCByZXBsYWNlbWVudCkgPT4ge1xuICAgIGlmIChleGlzdGluZy5wYXJlbnROb2RlKVxuICAgICAgICBleGlzdGluZy5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChyZXBsYWNlbWVudCwgZXhpc3RpbmcpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbmlsbGEuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9