"use strict";
(self["webpackChunkjja_dev"] = self["webpackChunkjja_dev"] || []).push([["vendors-node_modules_core-js_modules_es_array_concat_js-node_modules_core-js_modules_es_array-e3d437"],{

/***/ "./node_modules/@orchidjs/sifter/dist/esm/sifter.js":
/*!**********************************************************!*\
  !*** ./node_modules/@orchidjs/sifter/dist/esm/sifter.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Sifter: function() { return /* binding */ Sifter; },
/* harmony export */   cmp: function() { return /* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.cmp; },
/* harmony export */   getAttr: function() { return /* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.getAttr; },
/* harmony export */   getAttrNesting: function() { return /* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.getAttrNesting; },
/* harmony export */   getPattern: function() { return /* reexport safe */ _orchidjs_unicode_variants__WEBPACK_IMPORTED_MODULE_1__.getPattern; },
/* harmony export */   iterate: function() { return /* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.iterate; },
/* harmony export */   propToArray: function() { return /* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.propToArray; },
/* harmony export */   scoreValue: function() { return /* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.scoreValue; }
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@orchidjs/sifter/dist/esm/utils.js");
/* harmony import */ var _orchidjs_unicode_variants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @orchidjs/unicode-variants */ "./node_modules/@orchidjs/unicode-variants/dist/esm/index.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types.js */ "./node_modules/@orchidjs/sifter/dist/esm/types.js");
/**
 * sifter.js
 * Copyright (c) 2013–2020 Brian Reavis & contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 * @author Brian Reavis <brian@thirdroute.com>
 */


class Sifter {
    items; // []|{};
    settings;
    /**
     * Textually searches arrays and hashes of objects
     * by property (or multiple properties). Designed
     * specifically for autocomplete.
     *
     */
    constructor(items, settings) {
        this.items = items;
        this.settings = settings || { diacritics: true };
    }
    ;
    /**
     * Splits a search string into an array of individual
     * regexps to be used to match results.
     *
     */
    tokenize(query, respect_word_boundaries, weights) {
        if (!query || !query.length)
            return [];
        const tokens = [];
        const words = query.split(/\s+/);
        var field_regex;
        if (weights) {
            field_regex = new RegExp('^(' + Object.keys(weights).map(_orchidjs_unicode_variants__WEBPACK_IMPORTED_MODULE_1__.escape_regex).join('|') + ')\:(.*)$');
        }
        words.forEach((word) => {
            let field_match;
            let field = null;
            let regex = null;
            // look for "field:query" tokens
            if (field_regex && (field_match = word.match(field_regex))) {
                field = field_match[1];
                word = field_match[2];
            }
            if (word.length > 0) {
                if (this.settings.diacritics) {
                    regex = (0,_orchidjs_unicode_variants__WEBPACK_IMPORTED_MODULE_1__.getPattern)(word) || null;
                }
                else {
                    regex = (0,_orchidjs_unicode_variants__WEBPACK_IMPORTED_MODULE_1__.escape_regex)(word);
                }
                if (regex && respect_word_boundaries)
                    regex = "\\b" + regex;
            }
            tokens.push({
                string: word,
                regex: regex ? new RegExp(regex, 'iu') : null,
                field: field,
            });
        });
        return tokens;
    }
    ;
    /**
     * Returns a function to be used to score individual results.
     *
     * Good matches will have a higher score than poor matches.
     * If an item is not a match, 0 will be returned by the function.
     *
     * @returns {T.ScoreFn}
     */
    getScoreFunction(query, options) {
        var search = this.prepareSearch(query, options);
        return this._getScoreFunction(search);
    }
    /**
     * @returns {T.ScoreFn}
     *
     */
    _getScoreFunction(search) {
        const tokens = search.tokens, token_count = tokens.length;
        if (!token_count) {
            return function () { return 0; };
        }
        const fields = search.options.fields, weights = search.weights, field_count = fields.length, getAttrFn = search.getAttrFn;
        if (!field_count) {
            return function () { return 1; };
        }
        /**
         * Calculates the score of an object
         * against the search query.
         *
         */
        const scoreObject = (function () {
            if (field_count === 1) {
                return function (token, data) {
                    const field = fields[0].field;
                    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.scoreValue)(getAttrFn(data, field), token, weights[field] || 1);
                };
            }
            return function (token, data) {
                var sum = 0;
                // is the token specific to a field?
                if (token.field) {
                    const value = getAttrFn(data, token.field);
                    if (!token.regex && value) {
                        sum += (1 / field_count);
                    }
                    else {
                        sum += (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.scoreValue)(value, token, 1);
                    }
                }
                else {
                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.iterate)(weights, (weight, field) => {
                        sum += (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.scoreValue)(getAttrFn(data, field), token, weight);
                    });
                }
                return sum / field_count;
            };
        })();
        if (token_count === 1) {
            return function (data) {
                return scoreObject(tokens[0], data);
            };
        }
        if (search.options.conjunction === 'and') {
            return function (data) {
                var score, sum = 0;
                for (let token of tokens) {
                    score = scoreObject(token, data);
                    if (score <= 0)
                        return 0;
                    sum += score;
                }
                return sum / token_count;
            };
        }
        else {
            return function (data) {
                var sum = 0;
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.iterate)(tokens, (token) => {
                    sum += scoreObject(token, data);
                });
                return sum / token_count;
            };
        }
    }
    ;
    /**
     * Returns a function that can be used to compare two
     * results, for sorting purposes. If no sorting should
     * be performed, `null` will be returned.
     *
     * @return function(a,b)
     */
    getSortFunction(query, options) {
        var search = this.prepareSearch(query, options);
        return this._getSortFunction(search);
    }
    _getSortFunction(search) {
        var implicit_score, sort_flds = [];
        const self = this, options = search.options, sort = (!search.query && options.sort_empty) ? options.sort_empty : options.sort;
        if (typeof sort == 'function') {
            return sort.bind(this);
        }
        /**
         * Fetches the specified sort field value
         * from a search result item.
         *
         */
        const get_field = function (name, result) {
            if (name === '$score')
                return result.score;
            return search.getAttrFn(self.items[result.id], name);
        };
        // parse options
        if (sort) {
            for (let s of sort) {
                if (search.query || s.field !== '$score') {
                    sort_flds.push(s);
                }
            }
        }
        // the "$score" field is implied to be the primary
        // sort field, unless it's manually specified
        if (search.query) {
            implicit_score = true;
            for (let fld of sort_flds) {
                if (fld.field === '$score') {
                    implicit_score = false;
                    break;
                }
            }
            if (implicit_score) {
                sort_flds.unshift({ field: '$score', direction: 'desc' });
            }
            // without a search.query, all items will have the same score
        }
        else {
            sort_flds = sort_flds.filter((fld) => fld.field !== '$score');
        }
        // build function
        const sort_flds_count = sort_flds.length;
        if (!sort_flds_count) {
            return null;
        }
        return function (a, b) {
            var result, field;
            for (let sort_fld of sort_flds) {
                field = sort_fld.field;
                let multiplier = sort_fld.direction === 'desc' ? -1 : 1;
                result = multiplier * (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cmp)(get_field(field, a), get_field(field, b));
                if (result)
                    return result;
            }
            return 0;
        };
    }
    ;
    /**
     * Parses a search query and returns an object
     * with tokens and fields ready to be populated
     * with results.
     *
     */
    prepareSearch(query, optsUser) {
        const weights = {};
        var options = Object.assign({}, optsUser);
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.propToArray)(options, 'sort');
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.propToArray)(options, 'sort_empty');
        // convert fields to new format
        if (options.fields) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.propToArray)(options, 'fields');
            const fields = [];
            options.fields.forEach((field) => {
                if (typeof field == 'string') {
                    field = { field: field, weight: 1 };
                }
                fields.push(field);
                weights[field.field] = ('weight' in field) ? field.weight : 1;
            });
            options.fields = fields;
        }
        return {
            options: options,
            query: query.toLowerCase().trim(),
            tokens: this.tokenize(query, options.respect_word_boundaries, weights),
            total: 0,
            items: [],
            weights: weights,
            getAttrFn: (options.nesting) ? _utils_js__WEBPACK_IMPORTED_MODULE_0__.getAttrNesting : _utils_js__WEBPACK_IMPORTED_MODULE_0__.getAttr,
        };
    }
    ;
    /**
     * Searches through all items and returns a sorted array of matches.
     *
     */
    search(query, options) {
        var self = this, score, search;
        search = this.prepareSearch(query, options);
        options = search.options;
        query = search.query;
        // generate result scoring function
        const fn_score = options.score || self._getScoreFunction(search);
        // perform search and sort
        if (query.length) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.iterate)(self.items, (item, id) => {
                score = fn_score(item);
                if (options.filter === false || score > 0) {
                    search.items.push({ 'score': score, 'id': id });
                }
            });
        }
        else {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.iterate)(self.items, (_, id) => {
                search.items.push({ 'score': 1, 'id': id });
            });
        }
        const fn_sort = self._getSortFunction(search);
        if (fn_sort)
            search.items.sort(fn_sort);
        // apply limits
        search.total = search.items.length;
        if (typeof options.limit === 'number') {
            search.items = search.items.slice(0, options.limit);
        }
        return search;
    }
    ;
}


//# sourceMappingURL=sifter.js.map

/***/ }),

/***/ "./node_modules/@orchidjs/sifter/dist/esm/types.js":
/*!*********************************************************!*\
  !*** ./node_modules/@orchidjs/sifter/dist/esm/types.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/@orchidjs/sifter/dist/esm/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/@orchidjs/sifter/dist/esm/utils.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cmp: function() { return /* binding */ cmp; },
/* harmony export */   getAttr: function() { return /* binding */ getAttr; },
/* harmony export */   getAttrNesting: function() { return /* binding */ getAttrNesting; },
/* harmony export */   iterate: function() { return /* binding */ iterate; },
/* harmony export */   propToArray: function() { return /* binding */ propToArray; },
/* harmony export */   scoreValue: function() { return /* binding */ scoreValue; }
/* harmony export */ });
/* harmony import */ var _orchidjs_unicode_variants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @orchidjs/unicode-variants */ "./node_modules/@orchidjs/unicode-variants/dist/esm/index.js");

/**
 * A property getter resolving dot-notation
 * @param  {Object}  obj     The root object to fetch property on
 * @param  {String}  name    The optionally dotted property name to fetch
 * @return {Object}          The resolved property value
 */
const getAttr = (obj, name) => {
    if (!obj)
        return;
    return obj[name];
};
/**
 * A property getter resolving dot-notation
 * @param  {Object}  obj     The root object to fetch property on
 * @param  {String}  name    The optionally dotted property name to fetch
 * @return {Object}          The resolved property value
 */
const getAttrNesting = (obj, name) => {
    if (!obj)
        return;
    var part, names = name.split(".");
    while ((part = names.shift()) && (obj = obj[part]))
        ;
    return obj;
};
/**
 * Calculates how close of a match the
 * given value is against a search token.
 *
 */
const scoreValue = (value, token, weight) => {
    var score, pos;
    if (!value)
        return 0;
    value = value + '';
    if (token.regex == null)
        return 0;
    pos = value.search(token.regex);
    if (pos === -1)
        return 0;
    score = token.string.length / value.length;
    if (pos === 0)
        score += 0.5;
    return score * weight;
};
/**
 * Cast object property to an array if it exists and has a value
 *
 */
const propToArray = (obj, key) => {
    var value = obj[key];
    if (typeof value == 'function')
        return value;
    if (value && !Array.isArray(value)) {
        obj[key] = [value];
    }
};
/**
 * Iterates over arrays and hashes.
 *
 * ```
 * iterate(this.items, function(item, id) {
 *    // invoked for each item
 * });
 * ```
 *
 */
const iterate = (object, callback) => {
    if (Array.isArray(object)) {
        object.forEach(callback);
    }
    else {
        for (var key in object) {
            if (object.hasOwnProperty(key)) {
                callback(object[key], key);
            }
        }
    }
};
const cmp = (a, b) => {
    if (typeof a === 'number' && typeof b === 'number') {
        return a > b ? 1 : (a < b ? -1 : 0);
    }
    a = (0,_orchidjs_unicode_variants__WEBPACK_IMPORTED_MODULE_0__.asciifold)(a + '').toLowerCase();
    b = (0,_orchidjs_unicode_variants__WEBPACK_IMPORTED_MODULE_0__.asciifold)(b + '').toLowerCase();
    if (a > b)
        return 1;
    if (b > a)
        return -1;
    return 0;
};
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/@orchidjs/unicode-variants/dist/esm/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@orchidjs/unicode-variants/dist/esm/index.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _asciifold: function() { return /* binding */ _asciifold; },
/* harmony export */   asciifold: function() { return /* binding */ asciifold; },
/* harmony export */   code_points: function() { return /* binding */ code_points; },
/* harmony export */   escape_regex: function() { return /* reexport safe */ _regex_js__WEBPACK_IMPORTED_MODULE_0__.escape_regex; },
/* harmony export */   generateMap: function() { return /* binding */ generateMap; },
/* harmony export */   generateSets: function() { return /* binding */ generateSets; },
/* harmony export */   generator: function() { return /* binding */ generator; },
/* harmony export */   getPattern: function() { return /* binding */ getPattern; },
/* harmony export */   initialize: function() { return /* binding */ initialize; },
/* harmony export */   mapSequence: function() { return /* binding */ mapSequence; },
/* harmony export */   normalize: function() { return /* binding */ normalize; },
/* harmony export */   substringsToPattern: function() { return /* binding */ substringsToPattern; },
/* harmony export */   unicode_map: function() { return /* binding */ unicode_map; }
/* harmony export */ });
/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ "./node_modules/@orchidjs/unicode-variants/dist/esm/regex.js");
/* harmony import */ var _strings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./strings.js */ "./node_modules/@orchidjs/unicode-variants/dist/esm/strings.js");


const code_points = [[0, 65535]];
const accent_pat = '[\u0300-\u036F\u{b7}\u{2be}\u{2bc}]';
let unicode_map;
let multi_char_reg;
const max_char_length = 3;
const latin_convert = {};
const latin_condensed = {
    '/': '⁄∕',
    '0': '߀',
    "a": "ⱥɐɑ",
    "aa": "ꜳ",
    "ae": "æǽǣ",
    "ao": "ꜵ",
    "au": "ꜷ",
    "av": "ꜹꜻ",
    "ay": "ꜽ",
    "b": "ƀɓƃ",
    "c": "ꜿƈȼↄ",
    "d": "đɗɖᴅƌꮷԁɦ",
    "e": "ɛǝᴇɇ",
    "f": "ꝼƒ",
    "g": "ǥɠꞡᵹꝿɢ",
    "h": "ħⱨⱶɥ",
    "i": "ɨı",
    "j": "ɉȷ",
    "k": "ƙⱪꝁꝃꝅꞣ",
    "l": "łƚɫⱡꝉꝇꞁɭ",
    "m": "ɱɯϻ",
    "n": "ꞥƞɲꞑᴎлԉ",
    "o": "øǿɔɵꝋꝍᴑ",
    "oe": "œ",
    "oi": "ƣ",
    "oo": "ꝏ",
    "ou": "ȣ",
    "p": "ƥᵽꝑꝓꝕρ",
    "q": "ꝗꝙɋ",
    "r": "ɍɽꝛꞧꞃ",
    "s": "ßȿꞩꞅʂ",
    "t": "ŧƭʈⱦꞇ",
    "th": "þ",
    "tz": "ꜩ",
    "u": "ʉ",
    "v": "ʋꝟʌ",
    "vy": "ꝡ",
    "w": "ⱳ",
    "y": "ƴɏỿ",
    "z": "ƶȥɀⱬꝣ",
    "hv": "ƕ"
};
for (let latin in latin_condensed) {
    let unicode = latin_condensed[latin] || '';
    for (let i = 0; i < unicode.length; i++) {
        let char = unicode.substring(i, i + 1);
        latin_convert[char] = latin;
    }
}
const convert_pat = new RegExp(Object.keys(latin_convert).join('|') + '|' + accent_pat, 'gu');
/**
 * Initialize the unicode_map from the give code point ranges
 */
const initialize = (_code_points) => {
    if (unicode_map !== undefined)
        return;
    unicode_map = generateMap(_code_points || code_points);
};
/**
 * Helper method for normalize a string
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize
 */
const normalize = (str, form = 'NFKD') => str.normalize(form);
/**
 * Remove accents without reordering string
 * calling str.normalize('NFKD') on \u{594}\u{595}\u{596} becomes \u{596}\u{594}\u{595}
 * via https://github.com/krisk/Fuse/issues/133#issuecomment-318692703
 */
const asciifold = (str) => {
    return Array.from(str).reduce(
    /**
     * @param {string} result
     * @param {string} char
     */
    (result, char) => {
        return result + _asciifold(char);
    }, '');
};
const _asciifold = (str) => {
    str = normalize(str)
        .toLowerCase()
        .replace(convert_pat, (/** @type {string} */ char) => {
        return latin_convert[char] || '';
    });
    //return str;
    return normalize(str, 'NFC');
};
/**
 * Generate a list of unicode variants from the list of code points
 */
function* generator(code_points) {
    for (const [code_point_min, code_point_max] of code_points) {
        for (let i = code_point_min; i <= code_point_max; i++) {
            let composed = String.fromCharCode(i);
            let folded = asciifold(composed);
            if (folded == composed.toLowerCase()) {
                continue;
            }
            // skip when folded is a string longer than 3 characters long
            // bc the resulting regex patterns will be long
            // eg:
            // folded صلى الله عليه وسلم length 18 code point 65018
            // folded جل جلاله length 8 code point 65019
            if (folded.length > max_char_length) {
                continue;
            }
            if (folded.length == 0) {
                continue;
            }
            yield { folded: folded, composed: composed, code_point: i };
        }
    }
}
/**
 * Generate a unicode map from the list of code points
 */
const generateSets = (code_points) => {
    const unicode_sets = {};
    const addMatching = (folded, to_add) => {
        /** @type {Set<string>} */
        const folded_set = unicode_sets[folded] || new Set();
        const patt = new RegExp('^' + (0,_regex_js__WEBPACK_IMPORTED_MODULE_0__.setToPattern)(folded_set) + '$', 'iu');
        if (to_add.match(patt)) {
            return;
        }
        folded_set.add((0,_regex_js__WEBPACK_IMPORTED_MODULE_0__.escape_regex)(to_add));
        unicode_sets[folded] = folded_set;
    };
    for (let value of generator(code_points)) {
        addMatching(value.folded, value.folded);
        addMatching(value.folded, value.composed);
    }
    return unicode_sets;
};
/**
 * Generate a unicode map from the list of code points
 * ae => (?:(?:ae|Æ|Ǽ|Ǣ)|(?:A|Ⓐ|Ａ...)(?:E|ɛ|Ⓔ...))
 */
const generateMap = (code_points) => {
    const unicode_sets = generateSets(code_points);
    const unicode_map = {};
    let multi_char = [];
    for (let folded in unicode_sets) {
        let set = unicode_sets[folded];
        if (set) {
            unicode_map[folded] = (0,_regex_js__WEBPACK_IMPORTED_MODULE_0__.setToPattern)(set);
        }
        if (folded.length > 1) {
            multi_char.push((0,_regex_js__WEBPACK_IMPORTED_MODULE_0__.escape_regex)(folded));
        }
    }
    multi_char.sort((a, b) => b.length - a.length);
    const multi_char_patt = (0,_regex_js__WEBPACK_IMPORTED_MODULE_0__.arrayToPattern)(multi_char);
    multi_char_reg = new RegExp('^' + multi_char_patt, 'u');
    return unicode_map;
};
/**
 * Map each element of an array from its folded value to all possible unicode matches
 */
const mapSequence = (strings, min_replacement = 1) => {
    let chars_replaced = 0;
    strings = strings.map((str) => {
        if (unicode_map[str]) {
            chars_replaced += str.length;
        }
        return unicode_map[str] || str;
    });
    if (chars_replaced >= min_replacement) {
        return (0,_regex_js__WEBPACK_IMPORTED_MODULE_0__.sequencePattern)(strings);
    }
    return '';
};
/**
 * Convert a short string and split it into all possible patterns
 * Keep a pattern only if min_replacement is met
 *
 * 'abc'
 * 		=> [['abc'],['ab','c'],['a','bc'],['a','b','c']]
 *		=> ['abc-pattern','ab-c-pattern'...]
 */
const substringsToPattern = (str, min_replacement = 1) => {
    min_replacement = Math.max(min_replacement, str.length - 1);
    return (0,_regex_js__WEBPACK_IMPORTED_MODULE_0__.arrayToPattern)((0,_strings_js__WEBPACK_IMPORTED_MODULE_1__.allSubstrings)(str).map((sub_pat) => {
        return mapSequence(sub_pat, min_replacement);
    }));
};
/**
 * Convert an array of sequences into a pattern
 * [{start:0,end:3,length:3,substr:'iii'}...] => (?:iii...)
 */
const sequencesToPattern = (sequences, all = true) => {
    let min_replacement = sequences.length > 1 ? 1 : 0;
    return (0,_regex_js__WEBPACK_IMPORTED_MODULE_0__.arrayToPattern)(sequences.map((sequence) => {
        let seq = [];
        const len = all ? sequence.length() : sequence.length() - 1;
        for (let j = 0; j < len; j++) {
            seq.push(substringsToPattern(sequence.substrs[j] || '', min_replacement));
        }
        return (0,_regex_js__WEBPACK_IMPORTED_MODULE_0__.sequencePattern)(seq);
    }));
};
/**
 * Return true if the sequence is already in the sequences
 */
const inSequences = (needle_seq, sequences) => {
    for (const seq of sequences) {
        if (seq.start != needle_seq.start || seq.end != needle_seq.end) {
            continue;
        }
        if (seq.substrs.join('') !== needle_seq.substrs.join('')) {
            continue;
        }
        let needle_parts = needle_seq.parts;
        const filter = (part) => {
            for (const needle_part of needle_parts) {
                if (needle_part.start === part.start && needle_part.substr === part.substr) {
                    return false;
                }
                if (part.length == 1 || needle_part.length == 1) {
                    continue;
                }
                // check for overlapping parts
                // a = ['::=','==']
                // b = ['::','===']
                // a = ['r','sm']
                // b = ['rs','m']
                if (part.start < needle_part.start && part.end > needle_part.start) {
                    return true;
                }
                if (needle_part.start < part.start && needle_part.end > part.start) {
                    return true;
                }
            }
            return false;
        };
        let filtered = seq.parts.filter(filter);
        if (filtered.length > 0) {
            continue;
        }
        return true;
    }
    return false;
};
class Sequence {
    parts;
    substrs;
    start;
    end;
    constructor() {
        this.parts = [];
        this.substrs = [];
        this.start = 0;
        this.end = 0;
    }
    add(part) {
        if (part) {
            this.parts.push(part);
            this.substrs.push(part.substr);
            this.start = Math.min(part.start, this.start);
            this.end = Math.max(part.end, this.end);
        }
    }
    last() {
        return this.parts[this.parts.length - 1];
    }
    length() {
        return this.parts.length;
    }
    clone(position, last_piece) {
        let clone = new Sequence();
        let parts = JSON.parse(JSON.stringify(this.parts));
        let last_part = parts.pop();
        for (const part of parts) {
            clone.add(part);
        }
        let last_substr = last_piece.substr.substring(0, position - last_part.start);
        let clone_last_len = last_substr.length;
        clone.add({ start: last_part.start, end: last_part.start + clone_last_len, length: clone_last_len, substr: last_substr });
        return clone;
    }
}
/**
 * Expand a regular expression pattern to include unicode variants
 * 	eg /a/ becomes /aⓐａẚàáâầấẫẩãāăằắẵẳȧǡäǟảåǻǎȁȃạậặḁąⱥɐɑAⒶＡÀÁÂẦẤẪẨÃĀĂẰẮẴẲȦǠÄǞẢÅǺǍȀȂẠẬẶḀĄȺⱯ/
 *
 * Issue:
 *  ﺊﺋ [ 'ﺊ = \\u{fe8a}', 'ﺋ = \\u{fe8b}' ]
 *	becomes:	ئئ [ 'ي = \\u{64a}', 'ٔ = \\u{654}', 'ي = \\u{64a}', 'ٔ = \\u{654}' ]
 *
 *	İĲ = IIJ = ⅡJ
 *
 * 	1/2/4
 */
const getPattern = (str) => {
    initialize();
    str = asciifold(str);
    let pattern = '';
    let sequences = [new Sequence()];
    for (let i = 0; i < str.length; i++) {
        let substr = str.substring(i);
        let match = substr.match(multi_char_reg);
        const char = str.substring(i, i + 1);
        const match_str = match ? match[0] : null;
        // loop through sequences
        // add either the char or multi_match
        let overlapping = [];
        let added_types = new Set();
        for (const sequence of sequences) {
            const last_piece = sequence.last();
            if (!last_piece || last_piece.length == 1 || last_piece.end <= i) {
                // if we have a multi match
                if (match_str) {
                    const len = match_str.length;
                    sequence.add({ start: i, end: i + len, length: len, substr: match_str });
                    added_types.add('1');
                }
                else {
                    sequence.add({ start: i, end: i + 1, length: 1, substr: char });
                    added_types.add('2');
                }
            }
            else if (match_str) {
                let clone = sequence.clone(i, last_piece);
                const len = match_str.length;
                clone.add({ start: i, end: i + len, length: len, substr: match_str });
                overlapping.push(clone);
            }
            else {
                // don't add char
                // adding would create invalid patterns: 234 => [2,34,4]
                added_types.add('3');
            }
        }
        // if we have overlapping
        if (overlapping.length > 0) {
            // ['ii','iii'] before ['i','i','iii']
            overlapping = overlapping.sort((a, b) => {
                return a.length() - b.length();
            });
            for (let clone of overlapping) {
                // don't add if we already have an equivalent sequence
                if (inSequences(clone, sequences)) {
                    continue;
                }
                sequences.push(clone);
            }
            continue;
        }
        // if we haven't done anything unique
        // clean up the patterns
        // helps keep patterns smaller
        // if str = 'r₨㎧aarss', pattern will be 446 instead of 655
        if (i > 0 && added_types.size == 1 && !added_types.has('3')) {
            pattern += sequencesToPattern(sequences, false);
            let new_seq = new Sequence();
            const old_seq = sequences[0];
            if (old_seq) {
                new_seq.add(old_seq.last());
            }
            sequences = [new_seq];
        }
    }
    pattern += sequencesToPattern(sequences, true);
    return pattern;
};

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@orchidjs/unicode-variants/dist/esm/regex.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@orchidjs/unicode-variants/dist/esm/regex.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arrayToPattern: function() { return /* binding */ arrayToPattern; },
/* harmony export */   escape_regex: function() { return /* binding */ escape_regex; },
/* harmony export */   hasDuplicates: function() { return /* binding */ hasDuplicates; },
/* harmony export */   maxValueLength: function() { return /* binding */ maxValueLength; },
/* harmony export */   sequencePattern: function() { return /* binding */ sequencePattern; },
/* harmony export */   setToPattern: function() { return /* binding */ setToPattern; },
/* harmony export */   unicodeLength: function() { return /* binding */ unicodeLength; }
/* harmony export */ });
/**
 * Convert array of strings to a regular expression
 *	ex ['ab','a'] => (?:ab|a)
 * 	ex ['a','b'] => [ab]
 */
const arrayToPattern = (chars) => {
    chars = chars.filter(Boolean);
    if (chars.length < 2) {
        return chars[0] || '';
    }
    return (maxValueLength(chars) == 1) ? '[' + chars.join('') + ']' : '(?:' + chars.join('|') + ')';
};
const sequencePattern = (array) => {
    if (!hasDuplicates(array)) {
        return array.join('');
    }
    let pattern = '';
    let prev_char_count = 0;
    const prev_pattern = () => {
        if (prev_char_count > 1) {
            pattern += '{' + prev_char_count + '}';
        }
    };
    array.forEach((char, i) => {
        if (char === array[i - 1]) {
            prev_char_count++;
            return;
        }
        prev_pattern();
        pattern += char;
        prev_char_count = 1;
    });
    prev_pattern();
    return pattern;
};
/**
 * Convert array of strings to a regular expression
 *	ex ['ab','a'] => (?:ab|a)
 * 	ex ['a','b'] => [ab]
 */
const setToPattern = (chars) => {
    let array = Array.from(chars);
    return arrayToPattern(array);
};
/**
 * https://stackoverflow.com/questions/7376598/in-javascript-how-do-i-check-if-an-array-has-duplicate-values
 */
const hasDuplicates = (array) => {
    return (new Set(array)).size !== array.length;
};
/**
 * https://stackoverflow.com/questions/63006601/why-does-u-throw-an-invalid-escape-error
 */
const escape_regex = (str) => {
    return (str + '').replace(/([\$\(\)\*\+\.\?\[\]\^\{\|\}\\])/gu, '\\$1');
};
/**
 * Return the max length of array values
 */
const maxValueLength = (array) => {
    return array.reduce((longest, value) => Math.max(longest, unicodeLength(value)), 0);
};
const unicodeLength = (str) => {
    return Array.from(str).length;
};
//# sourceMappingURL=regex.js.map

/***/ }),

/***/ "./node_modules/@orchidjs/unicode-variants/dist/esm/strings.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@orchidjs/unicode-variants/dist/esm/strings.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   allSubstrings: function() { return /* binding */ allSubstrings; }
/* harmony export */ });
/**
 * Get all possible combinations of substrings that add up to the given string
 * https://stackoverflow.com/questions/30169587/find-all-the-combination-of-substrings-that-add-up-to-the-given-string
 */
const allSubstrings = (input) => {
    if (input.length === 1)
        return [[input]];
    let result = [];
    const start = input.substring(1);
    const suba = allSubstrings(start);
    suba.forEach(function (subresult) {
        let tmp = subresult.slice(0);
        tmp[0] = input.charAt(0) + tmp[0];
        result.push(tmp);
        tmp = subresult.slice(0);
        tmp.unshift(input.charAt(0));
        result.push(tmp);
    });
    return result;
};
//# sourceMappingURL=strings.js.map

/***/ }),

/***/ "./node_modules/core-js/internals/advance-string-index.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/advance-string-index.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var charAt = (__webpack_require__(/*! ../internals/string-multibyte */ "./node_modules/core-js/internals/string-multibyte.js").charAt);

// `AdvanceStringIndex` abstract operation
// https://tc39.es/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? charAt(S, index).length : 1);
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-buffer-non-extensible.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/array-buffer-non-extensible.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


// FF26- bug: ArrayBuffers are non-extensible, but Object.isExtensible does not report it
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = fails(function () {
  if (typeof ArrayBuffer == 'function') {
    var buffer = new ArrayBuffer(8);
    // eslint-disable-next-line es/no-object-isextensible, es/no-object-defineproperty -- safe
    if (Object.isExtensible(buffer)) Object.defineProperty(buffer, 'a', { value: 8 });
  }
});


/***/ }),

/***/ "./node_modules/core-js/internals/collection-strong.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/collection-strong.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var defineBuiltInAccessor = __webpack_require__(/*! ../internals/define-built-in-accessor */ "./node_modules/core-js/internals/define-built-in-accessor.js");
var defineBuiltIns = __webpack_require__(/*! ../internals/define-built-ins */ "./node_modules/core-js/internals/define-built-ins.js");
var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");
var iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");
var defineIterator = __webpack_require__(/*! ../internals/iterator-define */ "./node_modules/core-js/internals/iterator-define.js");
var createIterResultObject = __webpack_require__(/*! ../internals/create-iter-result-object */ "./node_modules/core-js/internals/create-iter-result-object.js");
var setSpecies = __webpack_require__(/*! ../internals/set-species */ "./node_modules/core-js/internals/set-species.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var fastKey = (__webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js").fastKey);
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");

var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;

module.exports = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor = wrapper(function (that, iterable) {
      anInstance(that, Prototype);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        index: create(null),
        first: null,
        last: null,
        size: 0
      });
      if (!DESCRIPTORS) that.size = 0;
      if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
    });

    var Prototype = Constructor.prototype;

    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var entry = getEntry(that, key);
      var previous, index;
      // change existing entry
      if (entry) {
        entry.value = value;
      // create new entry
      } else {
        state.last = entry = {
          index: index = fastKey(key, true),
          key: key,
          value: value,
          previous: previous = state.last,
          next: null,
          removed: false
        };
        if (!state.first) state.first = entry;
        if (previous) previous.next = entry;
        if (DESCRIPTORS) state.size++;
        else that.size++;
        // add to index
        if (index !== 'F') state.index[index] = entry;
      } return that;
    };

    var getEntry = function (that, key) {
      var state = getInternalState(that);
      // fast case
      var index = fastKey(key);
      var entry;
      if (index !== 'F') return state.index[index];
      // frozen object case
      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key === key) return entry;
      }
    };

    defineBuiltIns(Prototype, {
      // `{ Map, Set }.prototype.clear()` methods
      // https://tc39.es/ecma262/#sec-map.prototype.clear
      // https://tc39.es/ecma262/#sec-set.prototype.clear
      clear: function clear() {
        var that = this;
        var state = getInternalState(that);
        var entry = state.first;
        while (entry) {
          entry.removed = true;
          if (entry.previous) entry.previous = entry.previous.next = null;
          entry = entry.next;
        }
        state.first = state.last = null;
        state.index = create(null);
        if (DESCRIPTORS) state.size = 0;
        else that.size = 0;
      },
      // `{ Map, Set }.prototype.delete(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.delete
      // https://tc39.es/ecma262/#sec-set.prototype.delete
      'delete': function (key) {
        var that = this;
        var state = getInternalState(that);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.next;
          var prev = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev) prev.next = next;
          if (next) next.previous = prev;
          if (state.first === entry) state.first = next;
          if (state.last === entry) state.last = prev;
          if (DESCRIPTORS) state.size--;
          else that.size--;
        } return !!entry;
      },
      // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.foreach
      // https://tc39.es/ecma262/#sec-set.prototype.foreach
      forEach: function forEach(callbackfn /* , that = undefined */) {
        var state = getInternalState(this);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        var entry;
        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this);
          // revert to the last existing entry
          while (entry && entry.removed) entry = entry.previous;
        }
      },
      // `{ Map, Set}.prototype.has(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.has
      // https://tc39.es/ecma262/#sec-set.prototype.has
      has: function has(key) {
        return !!getEntry(this, key);
      }
    });

    defineBuiltIns(Prototype, IS_MAP ? {
      // `Map.prototype.get(key)` method
      // https://tc39.es/ecma262/#sec-map.prototype.get
      get: function get(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // `Map.prototype.set(key, value)` method
      // https://tc39.es/ecma262/#sec-map.prototype.set
      set: function set(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      // `Set.prototype.add(value)` method
      // https://tc39.es/ecma262/#sec-set.prototype.add
      add: function add(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (DESCRIPTORS) defineBuiltInAccessor(Prototype, 'size', {
      configurable: true,
      get: function () {
        return getInternalState(this).size;
      }
    });
    return Constructor;
  },
  setStrong: function (Constructor, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
    // `{ Map, Set }.prototype.{ keys, values, entries, @@iterator }()` methods
    // https://tc39.es/ecma262/#sec-map.prototype.entries
    // https://tc39.es/ecma262/#sec-map.prototype.keys
    // https://tc39.es/ecma262/#sec-map.prototype.values
    // https://tc39.es/ecma262/#sec-map.prototype-@@iterator
    // https://tc39.es/ecma262/#sec-set.prototype.entries
    // https://tc39.es/ecma262/#sec-set.prototype.keys
    // https://tc39.es/ecma262/#sec-set.prototype.values
    // https://tc39.es/ecma262/#sec-set.prototype-@@iterator
    defineIterator(Constructor, CONSTRUCTOR_NAME, function (iterated, kind) {
      setInternalState(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind: kind,
        last: null
      });
    }, function () {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var entry = state.last;
      // revert to the last existing entry
      while (entry && entry.removed) entry = entry.previous;
      // get next entry
      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        // or finish the iteration
        state.target = null;
        return createIterResultObject(undefined, true);
      }
      // return step by kind
      if (kind === 'keys') return createIterResultObject(entry.key, false);
      if (kind === 'values') return createIterResultObject(entry.value, false);
      return createIterResultObject([entry.key, entry.value], false);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // `{ Map, Set }.prototype[@@species]` accessors
    // https://tc39.es/ecma262/#sec-get-map-@@species
    // https://tc39.es/ecma262/#sec-get-set-@@species
    setSpecies(CONSTRUCTOR_NAME);
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/collection-weak.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/collection-weak.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var defineBuiltIns = __webpack_require__(/*! ../internals/define-built-ins */ "./node_modules/core-js/internals/define-built-ins.js");
var getWeakData = (__webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js").getWeakData);
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");
var ArrayIterationModule = __webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");

var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;
var find = ArrayIterationModule.find;
var findIndex = ArrayIterationModule.findIndex;
var splice = uncurryThis([].splice);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (state) {
  return state.frozen || (state.frozen = new UncaughtFrozenStore());
};

var UncaughtFrozenStore = function () {
  this.entries = [];
};

var findUncaughtFrozen = function (store, key) {
  return find(store.entries, function (it) {
    return it[0] === key;
  });
};

UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.entries.push([key, value]);
  },
  'delete': function (key) {
    var index = findIndex(this.entries, function (it) {
      return it[0] === key;
    });
    if (~index) splice(this.entries, index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor = wrapper(function (that, iterable) {
      anInstance(that, Prototype);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        id: id++,
        frozen: null
      });
      if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
    });

    var Prototype = Constructor.prototype;

    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var data = getWeakData(anObject(key), true);
      if (data === true) uncaughtFrozenStore(state).set(key, value);
      else data[state.id] = value;
      return that;
    };

    defineBuiltIns(Prototype, {
      // `{ WeakMap, WeakSet }.prototype.delete(key)` methods
      // https://tc39.es/ecma262/#sec-weakmap.prototype.delete
      // https://tc39.es/ecma262/#sec-weakset.prototype.delete
      'delete': function (key) {
        var state = getInternalState(this);
        if (!isObject(key)) return false;
        var data = getWeakData(key);
        if (data === true) return uncaughtFrozenStore(state)['delete'](key);
        return data && hasOwn(data, state.id) && delete data[state.id];
      },
      // `{ WeakMap, WeakSet }.prototype.has(key)` methods
      // https://tc39.es/ecma262/#sec-weakmap.prototype.has
      // https://tc39.es/ecma262/#sec-weakset.prototype.has
      has: function has(key) {
        var state = getInternalState(this);
        if (!isObject(key)) return false;
        var data = getWeakData(key);
        if (data === true) return uncaughtFrozenStore(state).has(key);
        return data && hasOwn(data, state.id);
      }
    });

    defineBuiltIns(Prototype, IS_MAP ? {
      // `WeakMap.prototype.get(key)` method
      // https://tc39.es/ecma262/#sec-weakmap.prototype.get
      get: function get(key) {
        var state = getInternalState(this);
        if (isObject(key)) {
          var data = getWeakData(key);
          if (data === true) return uncaughtFrozenStore(state).get(key);
          if (data) return data[state.id];
        }
      },
      // `WeakMap.prototype.set(key, value)` method
      // https://tc39.es/ecma262/#sec-weakmap.prototype.set
      set: function set(key, value) {
        return define(this, key, value);
      }
    } : {
      // `WeakSet.prototype.add(value)` method
      // https://tc39.es/ecma262/#sec-weakset.prototype.add
      add: function add(value) {
        return define(this, value, true);
      }
    });

    return Constructor;
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/collection.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/collection.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var InternalMetadataModule = __webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js");
var iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var checkCorrectnessOfIteration = __webpack_require__(/*! ../internals/check-correctness-of-iteration */ "./node_modules/core-js/internals/check-correctness-of-iteration.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var inheritIfRequired = __webpack_require__(/*! ../internals/inherit-if-required */ "./node_modules/core-js/internals/inherit-if-required.js");

module.exports = function (CONSTRUCTOR_NAME, wrapper, common) {
  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
  var ADDER = IS_MAP ? 'set' : 'add';
  var NativeConstructor = globalThis[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var Constructor = NativeConstructor;
  var exported = {};

  var fixMethod = function (KEY) {
    var uncurriedNativeMethod = uncurryThis(NativePrototype[KEY]);
    defineBuiltIn(NativePrototype, KEY,
      KEY === 'add' ? function add(value) {
        uncurriedNativeMethod(this, value === 0 ? 0 : value);
        return this;
      } : KEY === 'delete' ? function (key) {
        return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : KEY === 'get' ? function get(key) {
        return IS_WEAK && !isObject(key) ? undefined : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : KEY === 'has' ? function has(key) {
        return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : function set(key, value) {
        uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
        return this;
      }
    );
  };

  var REPLACE = isForced(
    CONSTRUCTOR_NAME,
    !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
      new NativeConstructor().entries().next();
    }))
  );

  if (REPLACE) {
    // create collection constructor
    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    InternalMetadataModule.enable();
  } else if (isForced(CONSTRUCTOR_NAME, true)) {
    var instance = new Constructor();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) !== instance;
    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    // eslint-disable-next-line no-new -- required for testing
    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new NativeConstructor();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      Constructor = wrapper(function (dummy, iterable) {
        anInstance(dummy, NativePrototype);
        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
        if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
        return that;
      });
      Constructor.prototype = NativePrototype;
      NativePrototype.constructor = Constructor;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);

    // weak collections should not contains .clear method
    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
  }

  exported[CONSTRUCTOR_NAME] = Constructor;
  $({ global: true, constructor: true, forced: Constructor !== NativeConstructor }, exported);

  setToStringTag(Constructor, CONSTRUCTOR_NAME);

  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);

  return Constructor;
};


/***/ }),

/***/ "./node_modules/core-js/internals/correct-is-regexp-logic.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/correct-is-regexp-logic.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var MATCH = wellKnownSymbol('match');

module.exports = function (METHOD_NAME) {
  var regexp = /./;
  try {
    '/./'[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (error2) { /* empty */ }
  } return false;
};


/***/ }),

/***/ "./node_modules/core-js/internals/define-built-ins.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/define-built-ins.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");

module.exports = function (target, src, options) {
  for (var key in src) defineBuiltIn(target, key, src[key], options);
  return target;
};


/***/ }),

/***/ "./node_modules/core-js/internals/does-not-exceed-safe-integer.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js/internals/does-not-exceed-safe-integer.js ***!
  \************************************************************************/
/***/ (function(module) {


var $TypeError = TypeError;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991

module.exports = function (it) {
  if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js ***!
  \******************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


// TODO: Remove from `core-js@4` since it's moved to entry points
__webpack_require__(/*! ../modules/es.regexp.exec */ "./node_modules/core-js/modules/es.regexp.exec.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var regexpExec = __webpack_require__(/*! ../internals/regexp-exec */ "./node_modules/core-js/internals/regexp-exec.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");

var SPECIES = wellKnownSymbol('species');
var RegExpPrototype = RegExp.prototype;

module.exports = function (KEY, exec, FORCED, SHAM) {
  var SYMBOL = wellKnownSymbol(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegExp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) !== 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    if (KEY === 'split') {
      // We can't use real regex here since it causes deoptimization
      // and serious performance degradation in V8
      // https://github.com/zloirock/core-js/issues/306
      re = {};
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
      re.flags = '';
      re[SYMBOL] = /./[SYMBOL];
    }

    re.exec = function () {
      execCalled = true;
      return null;
    };

    re[SYMBOL]('');
    return !execCalled;
  });

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    FORCED
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
      var $exec = regexp.exec;
      if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return { done: true, value: call(nativeRegExpMethod, regexp, str, arg2) };
        }
        return { done: true, value: call(nativeMethod, str, regexp, arg2) };
      }
      return { done: false };
    });

    defineBuiltIn(String.prototype, KEY, methods[0]);
    defineBuiltIn(RegExpPrototype, SYMBOL, methods[1]);
  }

  if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], 'sham', true);
};


/***/ }),

/***/ "./node_modules/core-js/internals/freezing.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/freezing.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-isextensible, es/no-object-preventextensions -- required for testing
  return Object.isExtensible(Object.preventExtensions({}));
});


/***/ }),

/***/ "./node_modules/core-js/internals/get-substitution.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/get-substitution.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");

var floor = Math.floor;
var charAt = uncurryThis(''.charAt);
var replace = uncurryThis(''.replace);
var stringSlice = uncurryThis(''.slice);
// eslint-disable-next-line redos/no-vulnerable -- safe
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;

// `GetSubstitution` abstract operation
// https://tc39.es/ecma262/#sec-getsubstitution
module.exports = function (matched, str, position, captures, namedCaptures, replacement) {
  var tailPos = position + matched.length;
  var m = captures.length;
  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
  if (namedCaptures !== undefined) {
    namedCaptures = toObject(namedCaptures);
    symbols = SUBSTITUTION_SYMBOLS;
  }
  return replace(replacement, symbols, function (match, ch) {
    var capture;
    switch (charAt(ch, 0)) {
      case '$': return '$';
      case '&': return matched;
      case '`': return stringSlice(str, 0, position);
      case "'": return stringSlice(str, tailPos);
      case '<':
        capture = namedCaptures[stringSlice(ch, 1, -1)];
        break;
      default: // \d\d?
        var n = +ch;
        if (n === 0) return match;
        if (n > m) {
          var f = floor(n / 10);
          if (f === 0) return match;
          if (f <= m) return captures[f - 1] === undefined ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);
          return match;
        }
        capture = captures[n - 1];
    }
    return capture === undefined ? '' : capture;
  });
};


/***/ }),

/***/ "./node_modules/core-js/internals/internal-metadata.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/internal-metadata.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);
var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");
var getOwnPropertyNamesExternalModule = __webpack_require__(/*! ../internals/object-get-own-property-names-external */ "./node_modules/core-js/internals/object-get-own-property-names-external.js");
var isExtensible = __webpack_require__(/*! ../internals/object-is-extensible */ "./node_modules/core-js/internals/object-is-extensible.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");
var FREEZING = __webpack_require__(/*! ../internals/freezing */ "./node_modules/core-js/internals/freezing.js");

var REQUIRED = false;
var METADATA = uid('meta');
var id = 0;

var setMetadata = function (it) {
  defineProperty(it, METADATA, { value: {
    objectID: 'O' + id++, // object ID
    weakData: {}          // weak collections IDs
  } });
};

var fastKey = function (it, create) {
  // return a primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!hasOwn(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMetadata(it);
  // return object ID
  } return it[METADATA].objectID;
};

var getWeakData = function (it, create) {
  if (!hasOwn(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMetadata(it);
  // return the store of weak collections IDs
  } return it[METADATA].weakData;
};

// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn(it, METADATA)) setMetadata(it);
  return it;
};

var enable = function () {
  meta.enable = function () { /* empty */ };
  REQUIRED = true;
  var getOwnPropertyNames = getOwnPropertyNamesModule.f;
  var splice = uncurryThis([].splice);
  var test = {};
  test[METADATA] = 1;

  // prevent exposing of metadata key
  if (getOwnPropertyNames(test).length) {
    getOwnPropertyNamesModule.f = function (it) {
      var result = getOwnPropertyNames(it);
      for (var i = 0, length = result.length; i < length; i++) {
        if (result[i] === METADATA) {
          splice(result, i, 1);
          break;
        }
      } return result;
    };

    $({ target: 'Object', stat: true, forced: true }, {
      getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
    });
  }
};

var meta = module.exports = {
  enable: enable,
  fastKey: fastKey,
  getWeakData: getWeakData,
  onFreeze: onFreeze
};

hiddenKeys[METADATA] = true;


/***/ }),

/***/ "./node_modules/core-js/internals/is-regexp.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-regexp.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var MATCH = wellKnownSymbol('match');

// `IsRegExp` abstract operation
// https://tc39.es/ecma262/#sec-isregexp
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) === 'RegExp');
};


/***/ }),

/***/ "./node_modules/core-js/internals/not-a-regexp.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/not-a-regexp.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isRegExp = __webpack_require__(/*! ../internals/is-regexp */ "./node_modules/core-js/internals/is-regexp.js");

var $TypeError = TypeError;

module.exports = function (it) {
  if (isRegExp(it)) {
    throw new $TypeError("The method doesn't accept regular expressions");
  } return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-is-extensible.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/object-is-extensible.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var ARRAY_BUFFER_NON_EXTENSIBLE = __webpack_require__(/*! ../internals/array-buffer-non-extensible */ "./node_modules/core-js/internals/array-buffer-non-extensible.js");

// eslint-disable-next-line es/no-object-isextensible -- safe
var $isExtensible = Object.isExtensible;
var FAILS_ON_PRIMITIVES = fails(function () { $isExtensible(1); });

// `Object.isExtensible` method
// https://tc39.es/ecma262/#sec-object.isextensible
module.exports = (FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE) ? function isExtensible(it) {
  if (!isObject(it)) return false;
  if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) === 'ArrayBuffer') return false;
  return $isExtensible ? $isExtensible(it) : true;
} : $isExtensible;


/***/ }),

/***/ "./node_modules/core-js/internals/regexp-exec-abstract.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-exec-abstract.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var regexpExec = __webpack_require__(/*! ../internals/regexp-exec */ "./node_modules/core-js/internals/regexp-exec.js");

var $TypeError = TypeError;

// `RegExpExec` abstract operation
// https://tc39.es/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (isCallable(exec)) {
    var result = call(exec, R, S);
    if (result !== null) anObject(result);
    return result;
  }
  if (classof(R) === 'RegExp') return call(regexpExec, R, S);
  throw new $TypeError('RegExp#exec called on incompatible receiver');
};


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.concat.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.concat.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");
var doesNotExceedSafeInteger = __webpack_require__(/*! ../internals/does-not-exceed-safe-integer */ "./node_modules/core-js/internals/does-not-exceed-safe-integer.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js/internals/array-species-create.js");
var arrayMethodHasSpeciesSupport = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js/internals/array-method-has-species-support.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var V8_VERSION = __webpack_require__(/*! ../internals/environment-v8-version */ "./node_modules/core-js/internals/environment-v8-version.js");

var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');

// We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679
var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});

var isConcatSpreadable = function (O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport('concat');

// `Array.prototype.concat` method
// https://tc39.es/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  concat: function concat(arg) {
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;
    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = lengthOfArrayLike(E);
        doesNotExceedSafeInteger(n + len);
        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
      } else {
        doesNotExceedSafeInteger(n + 1);
        createProperty(A, n++, E);
      }
    }
    A.length = n;
    return A;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.filter.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.filter.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $filter = (__webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").filter);
var arrayMethodHasSpeciesSupport = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js/internals/array-method-has-species-support.js");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');

// `Array.prototype.filter` method
// https://tc39.es/ecma262/#sec-array.prototype.filter
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.find.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.find.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $find = (__webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").find);
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js/internals/add-to-unscopables.js");

var FIND = 'find';
var SKIPS_HOLES = true;

// Shouldn't skip holes
// eslint-disable-next-line es/no-array-prototype-find -- testing
if (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES = false; });

// `Array.prototype.find` method
// https://tc39.es/ecma262/#sec-array.prototype.find
$({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND);


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.includes.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.includes.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $includes = (__webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js").includes);
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js/internals/add-to-unscopables.js");

// FF99+ bug
var BROKEN_ON_SPARSE = fails(function () {
  // eslint-disable-next-line es/no-array-prototype-includes -- detection
  return !Array(1).includes();
});

// `Array.prototype.includes` method
// https://tc39.es/ecma262/#sec-array.prototype.includes
$({ target: 'Array', proto: true, forced: BROKEN_ON_SPARSE }, {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('includes');


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.entries.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.entries.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $entries = (__webpack_require__(/*! ../internals/object-to-array */ "./node_modules/core-js/internals/object-to-array.js").entries);

// `Object.entries` method
// https://tc39.es/ecma262/#sec-object.entries
$({ target: 'Object', stat: true }, {
  entries: function entries(O) {
    return $entries(O);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.get-own-property-descriptor.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.get-own-property-descriptor.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var nativeGetOwnPropertyDescriptor = (__webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f);
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");

var FORCED = !DESCRIPTORS || fails(function () { nativeGetOwnPropertyDescriptor(1); });

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
$({ target: 'Object', stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
    return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.get-own-property-descriptors.js":
/*!********************************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.get-own-property-descriptors.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var ownKeys = __webpack_require__(/*! ../internals/own-keys */ "./node_modules/core-js/internals/own-keys.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");

// `Object.getOwnPropertyDescriptors` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
$({ target: 'Object', stat: true, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIndexedObject(object);
    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    var keys = ownKeys(O);
    var result = {};
    var index = 0;
    var key, descriptor;
    while (keys.length > index) {
      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
      if (descriptor !== undefined) createProperty(result, key, descriptor);
    }
    return result;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.set.constructor.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.set.constructor.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var collection = __webpack_require__(/*! ../internals/collection */ "./node_modules/core-js/internals/collection.js");
var collectionStrong = __webpack_require__(/*! ../internals/collection-strong */ "./node_modules/core-js/internals/collection-strong.js");

// `Set` constructor
// https://tc39.es/ecma262/#sec-set-objects
collection('Set', function (init) {
  return function Set() { return init(this, arguments.length ? arguments[0] : undefined); };
}, collectionStrong);


/***/ }),

/***/ "./node_modules/core-js/modules/es.set.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/es.set.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


// TODO: Remove this module from `core-js@4` since it's replaced to module below
__webpack_require__(/*! ../modules/es.set.constructor */ "./node_modules/core-js/modules/es.set.constructor.js");


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.includes.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.includes.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var notARegExp = __webpack_require__(/*! ../internals/not-a-regexp */ "./node_modules/core-js/internals/not-a-regexp.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var correctIsRegExpLogic = __webpack_require__(/*! ../internals/correct-is-regexp-logic */ "./node_modules/core-js/internals/correct-is-regexp-logic.js");

var stringIndexOf = uncurryThis(''.indexOf);

// `String.prototype.includes` method
// https://tc39.es/ecma262/#sec-string.prototype.includes
$({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~stringIndexOf(
      toString(requireObjectCoercible(this)),
      toString(notARegExp(searchString)),
      arguments.length > 1 ? arguments[1] : undefined
    );
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.replace.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.replace.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var apply = __webpack_require__(/*! ../internals/function-apply */ "./node_modules/core-js/internals/function-apply.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var fixRegExpWellKnownSymbolLogic = __webpack_require__(/*! ../internals/fix-regexp-well-known-symbol-logic */ "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js/internals/to-integer-or-infinity.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var advanceStringIndex = __webpack_require__(/*! ../internals/advance-string-index */ "./node_modules/core-js/internals/advance-string-index.js");
var getMethod = __webpack_require__(/*! ../internals/get-method */ "./node_modules/core-js/internals/get-method.js");
var getSubstitution = __webpack_require__(/*! ../internals/get-substitution */ "./node_modules/core-js/internals/get-substitution.js");
var regExpExec = __webpack_require__(/*! ../internals/regexp-exec-abstract */ "./node_modules/core-js/internals/regexp-exec-abstract.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var REPLACE = wellKnownSymbol('replace');
var max = Math.max;
var min = Math.min;
var concat = uncurryThis([].concat);
var push = uncurryThis([].push);
var stringIndexOf = uncurryThis(''.indexOf);
var stringSlice = uncurryThis(''.slice);

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// IE <= 11 replaces $0 with the whole match, as if it was $&
// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
var REPLACE_KEEPS_$0 = (function () {
  // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing
  return 'a'.replace(/./, '$0') === '$0';
})();

// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
  if (/./[REPLACE]) {
    return /./[REPLACE]('a', '$0') === '';
  }
  return false;
})();

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  // eslint-disable-next-line regexp/no-useless-dollar-replacements -- false positive
  return ''.replace(re, '$<a>') !== '7';
});

// @@replace logic
fixRegExpWellKnownSymbolLogic('replace', function (_, nativeReplace, maybeCallNative) {
  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';

  return [
    // `String.prototype.replace` method
    // https://tc39.es/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = requireObjectCoercible(this);
      var replacer = isObject(searchValue) ? getMethod(searchValue, REPLACE) : undefined;
      return replacer
        ? call(replacer, searchValue, O, replaceValue)
        : call(nativeReplace, toString(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
    function (string, replaceValue) {
      var rx = anObject(this);
      var S = toString(string);

      if (
        typeof replaceValue == 'string' &&
        stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 &&
        stringIndexOf(replaceValue, '$<') === -1
      ) {
        var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
        if (res.done) return res.value;
      }

      var functionalReplace = isCallable(replaceValue);
      if (!functionalReplace) replaceValue = toString(replaceValue);

      var global = rx.global;
      var fullUnicode;
      if (global) {
        fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }

      var results = [];
      var result;
      while (true) {
        result = regExpExec(rx, S);
        if (result === null) break;

        push(results, result);
        if (!global) break;

        var matchStr = toString(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }

      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];

        var matched = toString(result[0]);
        var position = max(min(toIntegerOrInfinity(result.index), S.length), 0);
        var captures = [];
        var replacement;
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) push(captures, maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = concat([matched], captures, position, S);
          if (namedCaptures !== undefined) push(replacerArgs, namedCaptures);
          replacement = toString(apply(replaceValue, undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += stringSlice(S, nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }

      return accumulatedResult + stringSlice(S, nextSourcePosition);
    }
  ];
}, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);


/***/ }),

/***/ "./node_modules/core-js/modules/es.weak-set.constructor.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.weak-set.constructor.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var collection = __webpack_require__(/*! ../internals/collection */ "./node_modules/core-js/internals/collection.js");
var collectionWeak = __webpack_require__(/*! ../internals/collection-weak */ "./node_modules/core-js/internals/collection-weak.js");

// `WeakSet` constructor
// https://tc39.es/ecma262/#sec-weakset-constructor
collection('WeakSet', function (init) {
  return function WeakSet() { return init(this, arguments.length ? arguments[0] : undefined); };
}, collectionWeak);


/***/ }),

/***/ "./node_modules/core-js/modules/es.weak-set.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/es.weak-set.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


// TODO: Remove this module from `core-js@4` since it's replaced to module below
__webpack_require__(/*! ../modules/es.weak-set.constructor */ "./node_modules/core-js/modules/es.weak-set.constructor.js");


/***/ }),

/***/ "./node_modules/tom-select/dist/esm/constants.js":
/*!*******************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/constants.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IS_MAC: function() { return /* binding */ IS_MAC; },
/* harmony export */   KEY_A: function() { return /* binding */ KEY_A; },
/* harmony export */   KEY_BACKSPACE: function() { return /* binding */ KEY_BACKSPACE; },
/* harmony export */   KEY_DELETE: function() { return /* binding */ KEY_DELETE; },
/* harmony export */   KEY_DOWN: function() { return /* binding */ KEY_DOWN; },
/* harmony export */   KEY_ESC: function() { return /* binding */ KEY_ESC; },
/* harmony export */   KEY_LEFT: function() { return /* binding */ KEY_LEFT; },
/* harmony export */   KEY_RETURN: function() { return /* binding */ KEY_RETURN; },
/* harmony export */   KEY_RIGHT: function() { return /* binding */ KEY_RIGHT; },
/* harmony export */   KEY_SHORTCUT: function() { return /* binding */ KEY_SHORTCUT; },
/* harmony export */   KEY_TAB: function() { return /* binding */ KEY_TAB; },
/* harmony export */   KEY_UP: function() { return /* binding */ KEY_UP; }
/* harmony export */ });
const KEY_A = 65;
const KEY_RETURN = 13;
const KEY_ESC = 27;
const KEY_LEFT = 37;
const KEY_UP = 38;
const KEY_RIGHT = 39;
const KEY_DOWN = 40;
const KEY_BACKSPACE = 8;
const KEY_DELETE = 46;
const KEY_TAB = 9;
const IS_MAC = typeof navigator === 'undefined' ? false : /Mac/.test(navigator.userAgent);
const KEY_SHORTCUT = IS_MAC ? 'metaKey' : 'ctrlKey'; // ctrl key or apple key for ma
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "./node_modules/tom-select/dist/esm/contrib/highlight.js":
/*!***************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/contrib/highlight.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   highlight: function() { return /* binding */ highlight; },
/* harmony export */   removeHighlight: function() { return /* binding */ removeHighlight; }
/* harmony export */ });
/* harmony import */ var _vanilla_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../vanilla.js */ "./node_modules/tom-select/dist/esm/vanilla.js");
/**
 * highlight v3 | MIT license | Johann Burkard <jb@eaio.com>
 * Highlights arbitrary terms in a node.
 *
 * - Modified by Marshal <beatgates@gmail.com> 2011-6-24 (added regex)
 * - Modified by Brian Reavis <brian@thirdroute.com> 2012-8-27 (cleanup)
 */

const highlight = (element, regex) => {
    if (regex === null)
        return;
    // convet string to regex
    if (typeof regex === 'string') {
        if (!regex.length)
            return;
        regex = new RegExp(regex, 'i');
    }
    // Wrap matching part of text node with highlighting <span>, e.g.
    // Soccer  ->  <span class="highlight">Soc</span>cer  for regex = /soc/i
    const highlightText = (node) => {
        var match = node.data.match(regex);
        if (match && node.data.length > 0) {
            var spannode = document.createElement('span');
            spannode.className = 'highlight';
            var middlebit = node.splitText(match.index);
            middlebit.splitText(match[0].length);
            var middleclone = middlebit.cloneNode(true);
            spannode.appendChild(middleclone);
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_0__.replaceNode)(middlebit, spannode);
            return 1;
        }
        return 0;
    };
    // Recurse element node, looking for child text nodes to highlight, unless element
    // is childless, <script>, <style>, or already highlighted: <span class="hightlight">
    const highlightChildren = (node) => {
        if (node.nodeType === 1 && node.childNodes && !/(script|style)/i.test(node.tagName) && (node.className !== 'highlight' || node.tagName !== 'SPAN')) {
            Array.from(node.childNodes).forEach(element => {
                highlightRecursive(element);
            });
        }
    };
    const highlightRecursive = (node) => {
        if (node.nodeType === 3) {
            return highlightText(node);
        }
        highlightChildren(node);
        return 0;
    };
    highlightRecursive(element);
};
/**
 * removeHighlight fn copied from highlight v5 and
 * edited to remove with(), pass js strict mode, and use without jquery
 */
const removeHighlight = (el) => {
    var elements = el.querySelectorAll("span.highlight");
    Array.prototype.forEach.call(elements, function (el) {
        var parent = el.parentNode;
        parent.replaceChild(el.firstChild, el);
        parent.normalize();
    });
};
//# sourceMappingURL=highlight.js.map

/***/ }),

/***/ "./node_modules/tom-select/dist/esm/contrib/microevent.js":
/*!****************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/contrib/microevent.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ MicroEvent; }
/* harmony export */ });
/**
 * MicroEvent - to make any js object an event emitter
 *
 * - pure javascript - server compatible, browser compatible
 * - dont rely on the browser doms
 * - super simple - you get it immediatly, no mistery, no magic involved
 *
 * @author Jerome Etienne (https://github.com/jeromeetienne)
 */
/**
 * Execute callback for each event in space separated list of event names
 *
 */
function forEvents(events, callback) {
    events.split(/\s+/).forEach((event) => {
        callback(event);
    });
}
class MicroEvent {
    constructor() {
        this._events = {};
    }
    on(events, fct) {
        forEvents(events, (event) => {
            const event_array = this._events[event] || [];
            event_array.push(fct);
            this._events[event] = event_array;
        });
    }
    off(events, fct) {
        var n = arguments.length;
        if (n === 0) {
            this._events = {};
            return;
        }
        forEvents(events, (event) => {
            if (n === 1) {
                delete this._events[event];
                return;
            }
            const event_array = this._events[event];
            if (event_array === undefined)
                return;
            event_array.splice(event_array.indexOf(fct), 1);
            this._events[event] = event_array;
        });
    }
    trigger(events, ...args) {
        var self = this;
        forEvents(events, (event) => {
            const event_array = self._events[event];
            if (event_array === undefined)
                return;
            event_array.forEach(fct => {
                fct.apply(self, args);
            });
        });
    }
}
;
//# sourceMappingURL=microevent.js.map

/***/ }),

/***/ "./node_modules/tom-select/dist/esm/contrib/microplugin.js":
/*!*****************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/contrib/microplugin.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ MicroPlugin; }
/* harmony export */ });
/**
 * microplugin.js
 * Copyright (c) 2013 Brian Reavis & contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 * @author Brian Reavis <brian@thirdroute.com>
 */
function MicroPlugin(Interface) {
    Interface.plugins = {};
    return class extends Interface {
        constructor() {
            super(...arguments);
            this.plugins = {
                names: [],
                settings: {},
                requested: {},
                loaded: {}
            };
        }
        /**
         * Registers a plugin.
         *
         * @param {function} fn
         */
        static define(name, fn) {
            Interface.plugins[name] = {
                'name': name,
                'fn': fn
            };
        }
        /**
         * Initializes the listed plugins (with options).
         * Acceptable formats:
         *
         * List (without options):
         *   ['a', 'b', 'c']
         *
         * List (with options):
         *   [{'name': 'a', options: {}}, {'name': 'b', options: {}}]
         *
         * Hash (with options):
         *   {'a': { ... }, 'b': { ... }, 'c': { ... }}
         *
         * @param {array|object} plugins
         */
        initializePlugins(plugins) {
            var key, name;
            const self = this;
            const queue = [];
            if (Array.isArray(plugins)) {
                plugins.forEach((plugin) => {
                    if (typeof plugin === 'string') {
                        queue.push(plugin);
                    }
                    else {
                        self.plugins.settings[plugin.name] = plugin.options;
                        queue.push(plugin.name);
                    }
                });
            }
            else if (plugins) {
                for (key in plugins) {
                    if (plugins.hasOwnProperty(key)) {
                        self.plugins.settings[key] = plugins[key];
                        queue.push(key);
                    }
                }
            }
            while (name = queue.shift()) {
                self.require(name);
            }
        }
        loadPlugin(name) {
            var self = this;
            var plugins = self.plugins;
            var plugin = Interface.plugins[name];
            if (!Interface.plugins.hasOwnProperty(name)) {
                throw new Error('Unable to find "' + name + '" plugin');
            }
            plugins.requested[name] = true;
            plugins.loaded[name] = plugin.fn.apply(self, [self.plugins.settings[name] || {}]);
            plugins.names.push(name);
        }
        /**
         * Initializes a plugin.
         *
         */
        require(name) {
            var self = this;
            var plugins = self.plugins;
            if (!self.plugins.loaded.hasOwnProperty(name)) {
                if (plugins.requested[name]) {
                    throw new Error('Plugin has circular dependency ("' + name + '")');
                }
                self.loadPlugin(name);
            }
            return plugins.loaded[name];
        }
    };
}
//# sourceMappingURL=microplugin.js.map

/***/ }),

/***/ "./node_modules/tom-select/dist/esm/defaults.js":
/*!******************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/defaults.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({
    options: [],
    optgroups: [],
    plugins: [],
    delimiter: ',',
    splitOn: null, // regexp or string for splitting up values from a paste command
    persist: true,
    diacritics: true,
    create: null,
    createOnBlur: false,
    createFilter: null,
    highlight: true,
    openOnFocus: true,
    shouldOpen: null,
    maxOptions: 50,
    maxItems: null,
    hideSelected: null,
    duplicates: false,
    addPrecedence: false,
    selectOnTab: false,
    preload: null,
    allowEmptyOption: false,
    //closeAfterSelect: false,
    refreshThrottle: 300,
    loadThrottle: 300,
    loadingClass: 'loading',
    dataAttr: null, //'data-data',
    optgroupField: 'optgroup',
    valueField: 'value',
    labelField: 'text',
    disabledField: 'disabled',
    optgroupLabelField: 'label',
    optgroupValueField: 'value',
    lockOptgroupOrder: false,
    sortField: '$order',
    searchField: ['text'],
    searchConjunction: 'and',
    mode: null,
    wrapperClass: 'ts-wrapper',
    controlClass: 'ts-control',
    dropdownClass: 'ts-dropdown',
    dropdownContentClass: 'ts-dropdown-content',
    itemClass: 'item',
    optionClass: 'option',
    dropdownParent: null,
    controlInput: '<input type="text" autocomplete="off" size="1" />',
    copyClassesToDropdown: false,
    placeholder: null,
    hidePlaceholder: null,
    shouldLoad: function (query) {
        return query.length > 0;
    },
    /*
    load                 : null, // function(query, callback) { ... }
    score                : null, // function(search) { ... }
    onInitialize         : null, // function() { ... }
    onChange             : null, // function(value) { ... }
    onItemAdd            : null, // function(value, $item) { ... }
    onItemRemove         : null, // function(value) { ... }
    onClear              : null, // function() { ... }
    onOptionAdd          : null, // function(value, data) { ... }
    onOptionRemove       : null, // function(value) { ... }
    onOptionClear        : null, // function() { ... }
    onOptionGroupAdd     : null, // function(id, data) { ... }
    onOptionGroupRemove  : null, // function(id) { ... }
    onOptionGroupClear   : null, // function() { ... }
    onDropdownOpen       : null, // function(dropdown) { ... }
    onDropdownClose      : null, // function(dropdown) { ... }
    onType               : null, // function(str) { ... }
    onDelete             : null, // function(values) { ... }
    */
    render: {
    /*
    item: null,
    optgroup: null,
    optgroup_header: null,
    option: null,
    option_create: null
    */
    }
});
//# sourceMappingURL=defaults.js.map

/***/ }),

/***/ "./node_modules/tom-select/dist/esm/getSettings.js":
/*!*********************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/getSettings.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getSettings; }
/* harmony export */ });
/* harmony import */ var _defaults_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaults.js */ "./node_modules/tom-select/dist/esm/defaults.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/tom-select/dist/esm/utils.js");


function getSettings(input, settings_user) {
    var settings = Object.assign({}, _defaults_js__WEBPACK_IMPORTED_MODULE_0__["default"], settings_user);
    var attr_data = settings.dataAttr;
    var field_label = settings.labelField;
    var field_value = settings.valueField;
    var field_disabled = settings.disabledField;
    var field_optgroup = settings.optgroupField;
    var field_optgroup_label = settings.optgroupLabelField;
    var field_optgroup_value = settings.optgroupValueField;
    var tag_name = input.tagName.toLowerCase();
    var placeholder = input.getAttribute('placeholder') || input.getAttribute('data-placeholder');
    if (!placeholder && !settings.allowEmptyOption) {
        let option = input.querySelector('option[value=""]');
        if (option) {
            placeholder = option.textContent;
        }
    }
    var settings_element = {
        placeholder: placeholder,
        options: [],
        optgroups: [],
        items: [],
        maxItems: null,
    };
    /**
     * Initialize from a <select> element.
     *
     */
    var init_select = () => {
        var tagName;
        var options = settings_element.options;
        var optionsMap = {};
        var group_count = 1;
        let $order = 0;
        var readData = (el) => {
            var data = Object.assign({}, el.dataset); // get plain object from DOMStringMap
            var json = attr_data && data[attr_data];
            if (typeof json === 'string' && json.length) {
                data = Object.assign(data, JSON.parse(json));
            }
            return data;
        };
        var addOption = (option, group) => {
            var value = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.hash_key)(option.value);
            if (value == null)
                return;
            if (!value && !settings.allowEmptyOption)
                return;
            // if the option already exists, it's probably been
            // duplicated in another optgroup. in this case, push
            // the current group to the "optgroup" property on the
            // existing option so that it's rendered in both places.
            if (optionsMap.hasOwnProperty(value)) {
                if (group) {
                    var arr = optionsMap[value][field_optgroup];
                    if (!arr) {
                        optionsMap[value][field_optgroup] = group;
                    }
                    else if (!Array.isArray(arr)) {
                        optionsMap[value][field_optgroup] = [arr, group];
                    }
                    else {
                        arr.push(group);
                    }
                }
            }
            else {
                var option_data = readData(option);
                option_data[field_label] = option_data[field_label] || option.textContent;
                option_data[field_value] = option_data[field_value] || value;
                option_data[field_disabled] = option_data[field_disabled] || option.disabled;
                option_data[field_optgroup] = option_data[field_optgroup] || group;
                option_data.$option = option;
                option_data.$order = option_data.$order || ++$order;
                optionsMap[value] = option_data;
                options.push(option_data);
            }
            if (option.selected) {
                settings_element.items.push(value);
            }
        };
        var addGroup = (optgroup) => {
            var id, optgroup_data;
            optgroup_data = readData(optgroup);
            optgroup_data[field_optgroup_label] = optgroup_data[field_optgroup_label] || optgroup.getAttribute('label') || '';
            optgroup_data[field_optgroup_value] = optgroup_data[field_optgroup_value] || group_count++;
            optgroup_data[field_disabled] = optgroup_data[field_disabled] || optgroup.disabled;
            optgroup_data.$order = optgroup_data.$order || ++$order;
            settings_element.optgroups.push(optgroup_data);
            id = optgroup_data[field_optgroup_value];
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.iterate)(optgroup.children, (option) => {
                addOption(option, id);
            });
        };
        settings_element.maxItems = input.hasAttribute('multiple') ? null : 1;
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.iterate)(input.children, (child) => {
            tagName = child.tagName.toLowerCase();
            if (tagName === 'optgroup') {
                addGroup(child);
            }
            else if (tagName === 'option') {
                addOption(child);
            }
        });
    };
    /**
     * Initialize from a <input type="text"> element.
     *
     */
    var init_textbox = () => {
        const data_raw = input.getAttribute(attr_data);
        if (!data_raw) {
            var value = input.value.trim() || '';
            if (!settings.allowEmptyOption && !value.length)
                return;
            const values = value.split(settings.delimiter);
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.iterate)(values, (value) => {
                const option = {};
                option[field_label] = value;
                option[field_value] = value;
                settings_element.options.push(option);
            });
            settings_element.items = values;
        }
        else {
            settings_element.options = JSON.parse(data_raw);
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.iterate)(settings_element.options, (opt) => {
                settings_element.items.push(opt[field_value]);
            });
        }
    };
    if (tag_name === 'select') {
        init_select();
    }
    else {
        init_textbox();
    }
    return Object.assign({}, _defaults_js__WEBPACK_IMPORTED_MODULE_0__["default"], settings_element, settings_user);
}
;
//# sourceMappingURL=getSettings.js.map

/***/ }),

/***/ "./node_modules/tom-select/dist/esm/plugins/caret_position/plugin.js":
/*!***************************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/plugins/caret_position/plugin.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ plugin; }
/* harmony export */ });
/**
* Tom Select v2.4.3
* Licensed under the Apache License, Version 2.0 (the "License");
*/

/**
 * Converts a scalar to its best string representation
 * for hash keys and HTML attribute values.
 *
 * Transformations:
 *   'str'     -> 'str'
 *   null      -> ''
 *   undefined -> ''
 *   true      -> '1'
 *   false     -> '0'
 *   0         -> '0'
 *   1         -> '1'
 *
 */

/**
 * Iterates over arrays and hashes.
 *
 * ```
 * iterate(this.items, function(item, id) {
 *    // invoked for each item
 * });
 * ```
 *
 */
const iterate = (object, callback) => {
  if (Array.isArray(object)) {
    object.forEach(callback);
  } else {
    for (var key in object) {
      if (object.hasOwnProperty(key)) {
        callback(object[key], key);
      }
    }
  }
};

/**
 * Remove css classes
 *
 */
const removeClasses = (elmts, ...classes) => {
  var norm_classes = classesArray(classes);
  elmts = castAsArray(elmts);
  elmts.map(el => {
    norm_classes.map(cls => {
      el.classList.remove(cls);
    });
  });
};

/**
 * Return arguments
 *
 */
const classesArray = args => {
  var classes = [];
  iterate(args, _classes => {
    if (typeof _classes === 'string') {
      _classes = _classes.trim().split(/[\t\n\f\r\s]/);
    }
    if (Array.isArray(_classes)) {
      classes = classes.concat(_classes);
    }
  });
  return classes.filter(Boolean);
};

/**
 * Create an array from arg if it's not already an array
 *
 */
const castAsArray = arg => {
  if (!Array.isArray(arg)) {
    arg = [arg];
  }
  return arg;
};

/**
 * Get the index of an element amongst sibling nodes of the same type
 *
 */
const nodeIndex = (el, amongst) => {
  if (!el) return -1;
  amongst = amongst || el.nodeName;
  var i = 0;
  while (el = el.previousElementSibling) {
    if (el.matches(amongst)) {
      i++;
    }
  }
  return i;
};

/**
 * Plugin: "dropdown_input" (Tom Select)
 * Copyright (c) contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 */

function plugin () {
  var self = this;

  /**
   * Moves the caret to the specified index.
   *
   * The input must be moved by leaving it in place and moving the
   * siblings, due to the fact that focus cannot be restored once lost
   * on mobile webkit devices
   *
   */
  self.hook('instead', 'setCaret', new_pos => {
    if (self.settings.mode === 'single' || !self.control.contains(self.control_input)) {
      new_pos = self.items.length;
    } else {
      new_pos = Math.max(0, Math.min(self.items.length, new_pos));
      if (new_pos != self.caretPos && !self.isPending) {
        self.controlChildren().forEach((child, j) => {
          if (j < new_pos) {
            self.control_input.insertAdjacentElement('beforebegin', child);
          } else {
            self.control.appendChild(child);
          }
        });
      }
    }
    self.caretPos = new_pos;
  });
  self.hook('instead', 'moveCaret', direction => {
    if (!self.isFocused) return;

    // move caret before or after selected items
    const last_active = self.getLastActive(direction);
    if (last_active) {
      const idx = nodeIndex(last_active);
      self.setCaret(direction > 0 ? idx + 1 : idx);
      self.setActiveItem();
      removeClasses(last_active, 'last-active');

      // move caret left or right of current position
    } else {
      self.setCaret(self.caretPos + direction);
    }
  });
}


//# sourceMappingURL=plugin.js.map


/***/ }),

/***/ "./node_modules/tom-select/dist/esm/plugins/change_listener/plugin.js":
/*!****************************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/plugins/change_listener/plugin.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ plugin; }
/* harmony export */ });
/**
* Tom Select v2.4.3
* Licensed under the Apache License, Version 2.0 (the "License");
*/

/**
 * Converts a scalar to its best string representation
 * for hash keys and HTML attribute values.
 *
 * Transformations:
 *   'str'     -> 'str'
 *   null      -> ''
 *   undefined -> ''
 *   true      -> '1'
 *   false     -> '0'
 *   0         -> '0'
 *   1         -> '1'
 *
 */

/**
 * Add event helper
 *
 */
const addEvent = (target, type, callback, options) => {
  target.addEventListener(type, callback, options);
};

/**
 * Plugin: "change_listener" (Tom Select)
 * Copyright (c) contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 */

function plugin () {
  addEvent(this.input, 'change', () => {
    this.sync();
  });
}


//# sourceMappingURL=plugin.js.map


/***/ }),

/***/ "./node_modules/tom-select/dist/esm/plugins/checkbox_options/plugin.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/plugins/checkbox_options/plugin.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ plugin; }
/* harmony export */ });
/**
* Tom Select v2.4.3
* Licensed under the Apache License, Version 2.0 (the "License");
*/

/**
 * Converts a scalar to its best string representation
 * for hash keys and HTML attribute values.
 *
 * Transformations:
 *   'str'     -> 'str'
 *   null      -> ''
 *   undefined -> ''
 *   true      -> '1'
 *   false     -> '0'
 *   0         -> '0'
 *   1         -> '1'
 *
 */
const hash_key = value => {
  if (typeof value === 'undefined' || value === null) return null;
  return get_hash(value);
};
const get_hash = value => {
  if (typeof value === 'boolean') return value ? '1' : '0';
  return value + '';
};

/**
 * Prevent default
 *
 */
const preventDefault = (evt, stop = false) => {
  if (evt) {
    evt.preventDefault();
    if (stop) {
      evt.stopPropagation();
    }
  }
};

/**
 * Return a dom element from either a dom query string, jQuery object, a dom element or html string
 * https://stackoverflow.com/questions/494143/creating-a-new-dom-element-from-an-html-string-using-built-in-dom-methods-or-pro/35385518#35385518
 *
 * param query should be {}
 */
const getDom = query => {
  if (query.jquery) {
    return query[0];
  }
  if (query instanceof HTMLElement) {
    return query;
  }
  if (isHtmlString(query)) {
    var tpl = document.createElement('template');
    tpl.innerHTML = query.trim(); // Never return a text node of whitespace as the result
    return tpl.content.firstChild;
  }
  return document.querySelector(query);
};
const isHtmlString = arg => {
  if (typeof arg === 'string' && arg.indexOf('<') > -1) {
    return true;
  }
  return false;
};

/**
 * Plugin: "checkbox_options" (Tom Select)
 * Copyright (c) contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 */

function plugin (userOptions) {
  var self = this;
  var orig_onOptionSelect = self.onOptionSelect;
  self.settings.hideSelected = false;
  const cbOptions = Object.assign({
    // so that the user may add different ones as well
    className: "tomselect-checkbox",
    // the following default to the historic plugin's values
    checkedClassNames: undefined,
    uncheckedClassNames: undefined
  }, userOptions);
  var UpdateChecked = function UpdateChecked(checkbox, toCheck) {
    if (toCheck) {
      checkbox.checked = true;
      if (cbOptions.uncheckedClassNames) {
        checkbox.classList.remove(...cbOptions.uncheckedClassNames);
      }
      if (cbOptions.checkedClassNames) {
        checkbox.classList.add(...cbOptions.checkedClassNames);
      }
    } else {
      checkbox.checked = false;
      if (cbOptions.checkedClassNames) {
        checkbox.classList.remove(...cbOptions.checkedClassNames);
      }
      if (cbOptions.uncheckedClassNames) {
        checkbox.classList.add(...cbOptions.uncheckedClassNames);
      }
    }
  };

  // update the checkbox for an option
  var UpdateCheckbox = function UpdateCheckbox(option) {
    setTimeout(() => {
      var checkbox = option.querySelector('input.' + cbOptions.className);
      if (checkbox instanceof HTMLInputElement) {
        UpdateChecked(checkbox, option.classList.contains('selected'));
      }
    }, 1);
  };

  // add checkbox to option template
  self.hook('after', 'setupTemplates', () => {
    var orig_render_option = self.settings.render.option;
    self.settings.render.option = (data, escape_html) => {
      var rendered = getDom(orig_render_option.call(self, data, escape_html));
      var checkbox = document.createElement('input');
      if (cbOptions.className) {
        checkbox.classList.add(cbOptions.className);
      }
      checkbox.addEventListener('click', function (evt) {
        preventDefault(evt);
      });
      checkbox.type = 'checkbox';
      const hashed = hash_key(data[self.settings.valueField]);
      UpdateChecked(checkbox, !!(hashed && self.items.indexOf(hashed) > -1));
      rendered.prepend(checkbox);
      return rendered;
    };
  });

  // uncheck when item removed
  self.on('item_remove', value => {
    var option = self.getOption(value);
    if (option) {
      // if dropdown hasn't been opened yet, the option won't exist
      option.classList.remove('selected'); // selected class won't be removed yet
      UpdateCheckbox(option);
    }
  });

  // check when item added
  self.on('item_add', value => {
    var option = self.getOption(value);
    if (option) {
      // if dropdown hasn't been opened yet, the option won't exist
      UpdateCheckbox(option);
    }
  });

  // remove items when selected option is clicked
  self.hook('instead', 'onOptionSelect', (evt, option) => {
    if (option.classList.contains('selected')) {
      option.classList.remove('selected');
      self.removeItem(option.dataset.value);
      self.refreshOptions();
      preventDefault(evt, true);
      return;
    }
    orig_onOptionSelect.call(self, evt, option);
    UpdateCheckbox(option);
  });
}


//# sourceMappingURL=plugin.js.map


/***/ }),

/***/ "./node_modules/tom-select/dist/esm/plugins/clear_button/plugin.js":
/*!*************************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/plugins/clear_button/plugin.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ plugin; }
/* harmony export */ });
/**
* Tom Select v2.4.3
* Licensed under the Apache License, Version 2.0 (the "License");
*/

/**
 * Return a dom element from either a dom query string, jQuery object, a dom element or html string
 * https://stackoverflow.com/questions/494143/creating-a-new-dom-element-from-an-html-string-using-built-in-dom-methods-or-pro/35385518#35385518
 *
 * param query should be {}
 */
const getDom = query => {
  if (query.jquery) {
    return query[0];
  }
  if (query instanceof HTMLElement) {
    return query;
  }
  if (isHtmlString(query)) {
    var tpl = document.createElement('template');
    tpl.innerHTML = query.trim(); // Never return a text node of whitespace as the result
    return tpl.content.firstChild;
  }
  return document.querySelector(query);
};
const isHtmlString = arg => {
  if (typeof arg === 'string' && arg.indexOf('<') > -1) {
    return true;
  }
  return false;
};

/**
 * Plugin: "dropdown_header" (Tom Select)
 * Copyright (c) contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 */

function plugin (userOptions) {
  const self = this;
  const options = Object.assign({
    className: 'clear-button',
    title: 'Clear All',
    html: data => {
      return `<div class="${data.className}" title="${data.title}">&#10799;</div>`;
    }
  }, userOptions);
  self.on('initialize', () => {
    var button = getDom(options.html(options));
    button.addEventListener('click', evt => {
      if (self.isLocked) return;
      self.clear();
      if (self.settings.mode === 'single' && self.settings.allowEmptyOption) {
        self.addItem('');
      }
      evt.preventDefault();
      evt.stopPropagation();
    });
    self.control.appendChild(button);
  });
}


//# sourceMappingURL=plugin.js.map


/***/ }),

/***/ "./node_modules/tom-select/dist/esm/plugins/drag_drop/plugin.js":
/*!**********************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/plugins/drag_drop/plugin.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ plugin; }
/* harmony export */ });
/**
* Tom Select v2.4.3
* Licensed under the Apache License, Version 2.0 (the "License");
*/

/**
 * Converts a scalar to its best string representation
 * for hash keys and HTML attribute values.
 *
 * Transformations:
 *   'str'     -> 'str'
 *   null      -> ''
 *   undefined -> ''
 *   true      -> '1'
 *   false     -> '0'
 *   0         -> '0'
 *   1         -> '1'
 *
 */

/**
 * Prevent default
 *
 */
const preventDefault = (evt, stop = false) => {
  if (evt) {
    evt.preventDefault();
    if (stop) {
      evt.stopPropagation();
    }
  }
};

/**
 * Add event helper
 *
 */
const addEvent = (target, type, callback, options) => {
  target.addEventListener(type, callback, options);
};

/**
 * Iterates over arrays and hashes.
 *
 * ```
 * iterate(this.items, function(item, id) {
 *    // invoked for each item
 * });
 * ```
 *
 */
const iterate = (object, callback) => {
  if (Array.isArray(object)) {
    object.forEach(callback);
  } else {
    for (var key in object) {
      if (object.hasOwnProperty(key)) {
        callback(object[key], key);
      }
    }
  }
};

/**
 * Return a dom element from either a dom query string, jQuery object, a dom element or html string
 * https://stackoverflow.com/questions/494143/creating-a-new-dom-element-from-an-html-string-using-built-in-dom-methods-or-pro/35385518#35385518
 *
 * param query should be {}
 */
const getDom = query => {
  if (query.jquery) {
    return query[0];
  }
  if (query instanceof HTMLElement) {
    return query;
  }
  if (isHtmlString(query)) {
    var tpl = document.createElement('template');
    tpl.innerHTML = query.trim(); // Never return a text node of whitespace as the result
    return tpl.content.firstChild;
  }
  return document.querySelector(query);
};
const isHtmlString = arg => {
  if (typeof arg === 'string' && arg.indexOf('<') > -1) {
    return true;
  }
  return false;
};

/**
 * Set attributes of an element
 *
 */
const setAttr = (el, attrs) => {
  iterate(attrs, (val, attr) => {
    if (val == null) {
      el.removeAttribute(attr);
    } else {
      el.setAttribute(attr, '' + val);
    }
  });
};

/**
 * Plugin: "drag_drop" (Tom Select)
 * Copyright (c) contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 */

const insertAfter = (referenceNode, newNode) => {
  var _referenceNode$parent;
  (_referenceNode$parent = referenceNode.parentNode) == null || _referenceNode$parent.insertBefore(newNode, referenceNode.nextSibling);
};
const insertBefore = (referenceNode, newNode) => {
  var _referenceNode$parent2;
  (_referenceNode$parent2 = referenceNode.parentNode) == null || _referenceNode$parent2.insertBefore(newNode, referenceNode);
};
const isBefore = (referenceNode, newNode) => {
  do {
    var _newNode;
    newNode = (_newNode = newNode) == null ? void 0 : _newNode.previousElementSibling;
    if (referenceNode == newNode) {
      return true;
    }
  } while (newNode && newNode.previousElementSibling);
  return false;
};
function plugin () {
  var self = this;
  if (self.settings.mode !== 'multi') return;
  var orig_lock = self.lock;
  var orig_unlock = self.unlock;
  let sortable = true;
  let drag_item;

  /**
   * Add draggable attribute to item
   */
  self.hook('after', 'setupTemplates', () => {
    var orig_render_item = self.settings.render.item;
    self.settings.render.item = (data, escape) => {
      const item = getDom(orig_render_item.call(self, data, escape));
      setAttr(item, {
        'draggable': 'true'
      });

      // prevent doc_mousedown (see tom-select.ts)
      const mousedown = evt => {
        if (!sortable) preventDefault(evt);
        evt.stopPropagation();
      };
      const dragStart = evt => {
        drag_item = item;
        setTimeout(() => {
          item.classList.add('ts-dragging');
        }, 0);
      };
      const dragOver = evt => {
        evt.preventDefault();
        item.classList.add('ts-drag-over');
        moveitem(item, drag_item);
      };
      const dragLeave = () => {
        item.classList.remove('ts-drag-over');
      };
      const moveitem = (targetitem, dragitem) => {
        if (dragitem === undefined) return;
        if (isBefore(dragitem, item)) {
          insertAfter(targetitem, dragitem);
        } else {
          insertBefore(targetitem, dragitem);
        }
      };
      const dragend = () => {
        var _drag_item;
        document.querySelectorAll('.ts-drag-over').forEach(el => el.classList.remove('ts-drag-over'));
        (_drag_item = drag_item) == null || _drag_item.classList.remove('ts-dragging');
        drag_item = undefined;
        var values = [];
        self.control.querySelectorAll(`[data-value]`).forEach(el => {
          if (el.dataset.value) {
            let value = el.dataset.value;
            if (value) {
              values.push(value);
            }
          }
        });
        self.setValue(values);
      };
      addEvent(item, 'mousedown', mousedown);
      addEvent(item, 'dragstart', dragStart);
      addEvent(item, 'dragenter', dragOver);
      addEvent(item, 'dragover', dragOver);
      addEvent(item, 'dragleave', dragLeave);
      addEvent(item, 'dragend', dragend);
      return item;
    };
  });
  self.hook('instead', 'lock', () => {
    sortable = false;
    return orig_lock.call(self);
  });
  self.hook('instead', 'unlock', () => {
    sortable = true;
    return orig_unlock.call(self);
  });
}


//# sourceMappingURL=plugin.js.map


/***/ }),

/***/ "./node_modules/tom-select/dist/esm/plugins/dropdown_header/plugin.js":
/*!****************************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/plugins/dropdown_header/plugin.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ plugin; }
/* harmony export */ });
/**
* Tom Select v2.4.3
* Licensed under the Apache License, Version 2.0 (the "License");
*/

/**
 * Converts a scalar to its best string representation
 * for hash keys and HTML attribute values.
 *
 * Transformations:
 *   'str'     -> 'str'
 *   null      -> ''
 *   undefined -> ''
 *   true      -> '1'
 *   false     -> '0'
 *   0         -> '0'
 *   1         -> '1'
 *
 */

/**
 * Prevent default
 *
 */
const preventDefault = (evt, stop = false) => {
  if (evt) {
    evt.preventDefault();
    if (stop) {
      evt.stopPropagation();
    }
  }
};

/**
 * Return a dom element from either a dom query string, jQuery object, a dom element or html string
 * https://stackoverflow.com/questions/494143/creating-a-new-dom-element-from-an-html-string-using-built-in-dom-methods-or-pro/35385518#35385518
 *
 * param query should be {}
 */
const getDom = query => {
  if (query.jquery) {
    return query[0];
  }
  if (query instanceof HTMLElement) {
    return query;
  }
  if (isHtmlString(query)) {
    var tpl = document.createElement('template');
    tpl.innerHTML = query.trim(); // Never return a text node of whitespace as the result
    return tpl.content.firstChild;
  }
  return document.querySelector(query);
};
const isHtmlString = arg => {
  if (typeof arg === 'string' && arg.indexOf('<') > -1) {
    return true;
  }
  return false;
};

/**
 * Plugin: "dropdown_header" (Tom Select)
 * Copyright (c) contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 */

function plugin (userOptions) {
  const self = this;
  const options = Object.assign({
    title: 'Untitled',
    headerClass: 'dropdown-header',
    titleRowClass: 'dropdown-header-title',
    labelClass: 'dropdown-header-label',
    closeClass: 'dropdown-header-close',
    html: data => {
      return '<div class="' + data.headerClass + '">' + '<div class="' + data.titleRowClass + '">' + '<span class="' + data.labelClass + '">' + data.title + '</span>' + '<a class="' + data.closeClass + '">&times;</a>' + '</div>' + '</div>';
    }
  }, userOptions);
  self.on('initialize', () => {
    var header = getDom(options.html(options));
    var close_link = header.querySelector('.' + options.closeClass);
    if (close_link) {
      close_link.addEventListener('click', evt => {
        preventDefault(evt, true);
        self.close();
      });
    }
    self.dropdown.insertBefore(header, self.dropdown.firstChild);
  });
}


//# sourceMappingURL=plugin.js.map


/***/ }),

/***/ "./node_modules/tom-select/dist/esm/plugins/dropdown_input/plugin.js":
/*!***************************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/plugins/dropdown_input/plugin.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ plugin; }
/* harmony export */ });
/**
* Tom Select v2.4.3
* Licensed under the Apache License, Version 2.0 (the "License");
*/

const KEY_ESC = 27;
const KEY_TAB = 9;
 // ctrl key or apple key for ma

/**
 * Converts a scalar to its best string representation
 * for hash keys and HTML attribute values.
 *
 * Transformations:
 *   'str'     -> 'str'
 *   null      -> ''
 *   undefined -> ''
 *   true      -> '1'
 *   false     -> '0'
 *   0         -> '0'
 *   1         -> '1'
 *
 */

/**
 * Prevent default
 *
 */
const preventDefault = (evt, stop = false) => {
  if (evt) {
    evt.preventDefault();
    if (stop) {
      evt.stopPropagation();
    }
  }
};

/**
 * Add event helper
 *
 */
const addEvent = (target, type, callback, options) => {
  target.addEventListener(type, callback, options);
};

/**
 * Iterates over arrays and hashes.
 *
 * ```
 * iterate(this.items, function(item, id) {
 *    // invoked for each item
 * });
 * ```
 *
 */
const iterate = (object, callback) => {
  if (Array.isArray(object)) {
    object.forEach(callback);
  } else {
    for (var key in object) {
      if (object.hasOwnProperty(key)) {
        callback(object[key], key);
      }
    }
  }
};

/**
 * Return a dom element from either a dom query string, jQuery object, a dom element or html string
 * https://stackoverflow.com/questions/494143/creating-a-new-dom-element-from-an-html-string-using-built-in-dom-methods-or-pro/35385518#35385518
 *
 * param query should be {}
 */
const getDom = query => {
  if (query.jquery) {
    return query[0];
  }
  if (query instanceof HTMLElement) {
    return query;
  }
  if (isHtmlString(query)) {
    var tpl = document.createElement('template');
    tpl.innerHTML = query.trim(); // Never return a text node of whitespace as the result
    return tpl.content.firstChild;
  }
  return document.querySelector(query);
};
const isHtmlString = arg => {
  if (typeof arg === 'string' && arg.indexOf('<') > -1) {
    return true;
  }
  return false;
};

/**
 * Add css classes
 *
 */
const addClasses = (elmts, ...classes) => {
  var norm_classes = classesArray(classes);
  elmts = castAsArray(elmts);
  elmts.map(el => {
    norm_classes.map(cls => {
      el.classList.add(cls);
    });
  });
};

/**
 * Return arguments
 *
 */
const classesArray = args => {
  var classes = [];
  iterate(args, _classes => {
    if (typeof _classes === 'string') {
      _classes = _classes.trim().split(/[\t\n\f\r\s]/);
    }
    if (Array.isArray(_classes)) {
      classes = classes.concat(_classes);
    }
  });
  return classes.filter(Boolean);
};

/**
 * Create an array from arg if it's not already an array
 *
 */
const castAsArray = arg => {
  if (!Array.isArray(arg)) {
    arg = [arg];
  }
  return arg;
};

/**
 * Plugin: "dropdown_input" (Tom Select)
 * Copyright (c) contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 */

function plugin () {
  const self = this;
  self.settings.shouldOpen = true; // make sure the input is shown even if there are no options to display in the dropdown

  self.hook('before', 'setup', () => {
    self.focus_node = self.control;
    addClasses(self.control_input, 'dropdown-input');
    const div = getDom('<div class="dropdown-input-wrap">');
    div.append(self.control_input);
    self.dropdown.insertBefore(div, self.dropdown.firstChild);

    // set a placeholder in the select control
    const placeholder = getDom('<input class="items-placeholder" tabindex="-1" />');
    placeholder.placeholder = self.settings.placeholder || '';
    self.control.append(placeholder);
  });
  self.on('initialize', () => {
    // set tabIndex on control to -1, otherwise [shift+tab] will put focus right back on control_input
    self.control_input.addEventListener('keydown', evt => {
      //addEvent(self.control_input,'keydown' as const,(evt:KeyboardEvent) =>{
      switch (evt.keyCode) {
        case KEY_ESC:
          if (self.isOpen) {
            preventDefault(evt, true);
            self.close();
          }
          self.clearActiveItems();
          return;
        case KEY_TAB:
          self.focus_node.tabIndex = -1;
          break;
      }
      return self.onKeyDown.call(self, evt);
    });
    self.on('blur', () => {
      self.focus_node.tabIndex = self.isDisabled ? -1 : self.tabIndex;
    });

    // give the control_input focus when the dropdown is open
    self.on('dropdown_open', () => {
      self.control_input.focus();
    });

    // prevent onBlur from closing when focus is on the control_input
    const orig_onBlur = self.onBlur;
    self.hook('instead', 'onBlur', evt => {
      if (evt && evt.relatedTarget == self.control_input) return;
      return orig_onBlur.call(self);
    });
    addEvent(self.control_input, 'blur', () => self.onBlur());

    // return focus to control to allow further keyboard input
    self.hook('before', 'close', () => {
      if (!self.isOpen) return;
      self.focus_node.focus({
        preventScroll: true
      });
    });
  });
}


//# sourceMappingURL=plugin.js.map


/***/ }),

/***/ "./node_modules/tom-select/dist/esm/plugins/input_autogrow/plugin.js":
/*!***************************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/plugins/input_autogrow/plugin.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ plugin; }
/* harmony export */ });
/**
* Tom Select v2.4.3
* Licensed under the Apache License, Version 2.0 (the "License");
*/

/**
 * Converts a scalar to its best string representation
 * for hash keys and HTML attribute values.
 *
 * Transformations:
 *   'str'     -> 'str'
 *   null      -> ''
 *   undefined -> ''
 *   true      -> '1'
 *   false     -> '0'
 *   0         -> '0'
 *   1         -> '1'
 *
 */

/**
 * Add event helper
 *
 */
const addEvent = (target, type, callback, options) => {
  target.addEventListener(type, callback, options);
};

/**
 * Plugin: "input_autogrow" (Tom Select)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 */

function plugin () {
  var self = this;
  self.on('initialize', () => {
    var test_input = document.createElement('span');
    var control = self.control_input;
    test_input.style.cssText = 'position:absolute; top:-99999px; left:-99999px; width:auto; padding:0; white-space:pre; ';
    self.wrapper.appendChild(test_input);
    var transfer_styles = ['letterSpacing', 'fontSize', 'fontFamily', 'fontWeight', 'textTransform'];
    for (const style_name of transfer_styles) {
      // @ts-ignore TS7015 https://stackoverflow.com/a/50506154/697576
      test_input.style[style_name] = control.style[style_name];
    }

    /**
     * Set the control width
     *
     */
    var resize = () => {
      test_input.textContent = control.value;
      control.style.width = test_input.clientWidth + 'px';
    };
    resize();
    self.on('update item_add item_remove', resize);
    addEvent(control, 'input', resize);
    addEvent(control, 'keyup', resize);
    addEvent(control, 'blur', resize);
    addEvent(control, 'update', resize);
  });
}


//# sourceMappingURL=plugin.js.map


/***/ }),

/***/ "./node_modules/tom-select/dist/esm/plugins/no_active_items/plugin.js":
/*!****************************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/plugins/no_active_items/plugin.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ plugin; }
/* harmony export */ });
/**
* Tom Select v2.4.3
* Licensed under the Apache License, Version 2.0 (the "License");
*/

/**
 * Plugin: "no_active_items" (Tom Select)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 */

function plugin () {
  this.hook('instead', 'setActiveItem', () => {});
  this.hook('instead', 'selectAll', () => {});
}


//# sourceMappingURL=plugin.js.map


/***/ }),

/***/ "./node_modules/tom-select/dist/esm/plugins/no_backspace_delete/plugin.js":
/*!********************************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/plugins/no_backspace_delete/plugin.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ plugin; }
/* harmony export */ });
/**
* Tom Select v2.4.3
* Licensed under the Apache License, Version 2.0 (the "License");
*/

/**
 * Plugin: "input_autogrow" (Tom Select)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 */

function plugin () {
  var self = this;
  var orig_deleteSelection = self.deleteSelection;
  this.hook('instead', 'deleteSelection', evt => {
    if (self.activeItems.length) {
      return orig_deleteSelection.call(self, evt);
    }
    return false;
  });
}


//# sourceMappingURL=plugin.js.map


/***/ }),

/***/ "./node_modules/tom-select/dist/esm/plugins/optgroup_columns/plugin.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/plugins/optgroup_columns/plugin.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ plugin; }
/* harmony export */ });
/**
* Tom Select v2.4.3
* Licensed under the Apache License, Version 2.0 (the "License");
*/

const KEY_LEFT = 37;
const KEY_RIGHT = 39;
 // ctrl key or apple key for ma

/**
 * Get the closest node to the evt.target matching the selector
 * Stops at wrapper
 *
 */
const parentMatch = (target, selector, wrapper) => {
  while (target && target.matches) {
    if (target.matches(selector)) {
      return target;
    }
    target = target.parentNode;
  }
};

/**
 * Get the index of an element amongst sibling nodes of the same type
 *
 */
const nodeIndex = (el, amongst) => {
  if (!el) return -1;
  amongst = amongst || el.nodeName;
  var i = 0;
  while (el = el.previousElementSibling) {
    if (el.matches(amongst)) {
      i++;
    }
  }
  return i;
};

/**
 * Plugin: "optgroup_columns" (Tom Select.js)
 * Copyright (c) contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 */

function plugin () {
  var self = this;
  var orig_keydown = self.onKeyDown;
  self.hook('instead', 'onKeyDown', evt => {
    var index, option, options, optgroup;
    if (!self.isOpen || !(evt.keyCode === KEY_LEFT || evt.keyCode === KEY_RIGHT)) {
      return orig_keydown.call(self, evt);
    }
    self.ignoreHover = true;
    optgroup = parentMatch(self.activeOption, '[data-group]');
    index = nodeIndex(self.activeOption, '[data-selectable]');
    if (!optgroup) {
      return;
    }
    if (evt.keyCode === KEY_LEFT) {
      optgroup = optgroup.previousSibling;
    } else {
      optgroup = optgroup.nextSibling;
    }
    if (!optgroup) {
      return;
    }
    options = optgroup.querySelectorAll('[data-selectable]');
    option = options[Math.min(options.length - 1, index)];
    if (option) {
      self.setActiveOption(option);
    }
  });
}


//# sourceMappingURL=plugin.js.map


/***/ }),

/***/ "./node_modules/tom-select/dist/esm/plugins/remove_button/plugin.js":
/*!**************************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/plugins/remove_button/plugin.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ plugin; }
/* harmony export */ });
/**
* Tom Select v2.4.3
* Licensed under the Apache License, Version 2.0 (the "License");
*/

/**
 * Converts a scalar to its best string representation
 * for hash keys and HTML attribute values.
 *
 * Transformations:
 *   'str'     -> 'str'
 *   null      -> ''
 *   undefined -> ''
 *   true      -> '1'
 *   false     -> '0'
 *   0         -> '0'
 *   1         -> '1'
 *
 */

/**
 * Escapes a string for use within HTML.
 *
 */
const escape_html = str => {
  return (str + '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
};

/**
 * Prevent default
 *
 */
const preventDefault = (evt, stop = false) => {
  if (evt) {
    evt.preventDefault();
    if (stop) {
      evt.stopPropagation();
    }
  }
};

/**
 * Add event helper
 *
 */
const addEvent = (target, type, callback, options) => {
  target.addEventListener(type, callback, options);
};

/**
 * Return a dom element from either a dom query string, jQuery object, a dom element or html string
 * https://stackoverflow.com/questions/494143/creating-a-new-dom-element-from-an-html-string-using-built-in-dom-methods-or-pro/35385518#35385518
 *
 * param query should be {}
 */
const getDom = query => {
  if (query.jquery) {
    return query[0];
  }
  if (query instanceof HTMLElement) {
    return query;
  }
  if (isHtmlString(query)) {
    var tpl = document.createElement('template');
    tpl.innerHTML = query.trim(); // Never return a text node of whitespace as the result
    return tpl.content.firstChild;
  }
  return document.querySelector(query);
};
const isHtmlString = arg => {
  if (typeof arg === 'string' && arg.indexOf('<') > -1) {
    return true;
  }
  return false;
};

/**
 * Plugin: "remove_button" (Tom Select)
 * Copyright (c) contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 */

function plugin (userOptions) {
  const options = Object.assign({
    label: '&times;',
    title: 'Remove',
    className: 'remove',
    append: true
  }, userOptions);

  //options.className = 'remove-single';
  var self = this;

  // override the render method to add remove button to each item
  if (!options.append) {
    return;
  }
  var html = '<a href="javascript:void(0)" class="' + options.className + '" tabindex="-1" title="' + escape_html(options.title) + '">' + options.label + '</a>';
  self.hook('after', 'setupTemplates', () => {
    var orig_render_item = self.settings.render.item;
    self.settings.render.item = (data, escape) => {
      var item = getDom(orig_render_item.call(self, data, escape));
      var close_button = getDom(html);
      item.appendChild(close_button);
      addEvent(close_button, 'mousedown', evt => {
        preventDefault(evt, true);
      });
      addEvent(close_button, 'click', evt => {
        if (self.isLocked) return;

        // propagating will trigger the dropdown to show for single mode
        preventDefault(evt, true);
        if (self.isLocked) return;
        if (!self.shouldDelete([item], evt)) return;
        self.removeItem(item);
        self.refreshOptions(false);
        self.inputState();
      });
      return item;
    };
  });
}


//# sourceMappingURL=plugin.js.map


/***/ }),

/***/ "./node_modules/tom-select/dist/esm/plugins/restore_on_backspace/plugin.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/plugins/restore_on_backspace/plugin.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ plugin; }
/* harmony export */ });
/**
* Tom Select v2.4.3
* Licensed under the Apache License, Version 2.0 (the "License");
*/

/**
 * Plugin: "restore_on_backspace" (Tom Select)
 * Copyright (c) contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 */

function plugin (userOptions) {
  const self = this;
  const options = Object.assign({
    text: option => {
      return option[self.settings.labelField];
    }
  }, userOptions);
  self.on('item_remove', function (value) {
    if (!self.isFocused) {
      return;
    }
    if (self.control_input.value.trim() === '') {
      var option = self.options[value];
      if (option) {
        self.setTextboxValue(options.text.call(self, option));
      }
    }
  });
}


//# sourceMappingURL=plugin.js.map


/***/ }),

/***/ "./node_modules/tom-select/dist/esm/plugins/virtual_scroll/plugin.js":
/*!***************************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/plugins/virtual_scroll/plugin.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ plugin; }
/* harmony export */ });
/**
* Tom Select v2.4.3
* Licensed under the Apache License, Version 2.0 (the "License");
*/

/**
 * Converts a scalar to its best string representation
 * for hash keys and HTML attribute values.
 *
 * Transformations:
 *   'str'     -> 'str'
 *   null      -> ''
 *   undefined -> ''
 *   true      -> '1'
 *   false     -> '0'
 *   0         -> '0'
 *   1         -> '1'
 *
 */

/**
 * Iterates over arrays and hashes.
 *
 * ```
 * iterate(this.items, function(item, id) {
 *    // invoked for each item
 * });
 * ```
 *
 */
const iterate = (object, callback) => {
  if (Array.isArray(object)) {
    object.forEach(callback);
  } else {
    for (var key in object) {
      if (object.hasOwnProperty(key)) {
        callback(object[key], key);
      }
    }
  }
};

/**
 * Add css classes
 *
 */
const addClasses = (elmts, ...classes) => {
  var norm_classes = classesArray(classes);
  elmts = castAsArray(elmts);
  elmts.map(el => {
    norm_classes.map(cls => {
      el.classList.add(cls);
    });
  });
};

/**
 * Return arguments
 *
 */
const classesArray = args => {
  var classes = [];
  iterate(args, _classes => {
    if (typeof _classes === 'string') {
      _classes = _classes.trim().split(/[\t\n\f\r\s]/);
    }
    if (Array.isArray(_classes)) {
      classes = classes.concat(_classes);
    }
  });
  return classes.filter(Boolean);
};

/**
 * Create an array from arg if it's not already an array
 *
 */
const castAsArray = arg => {
  if (!Array.isArray(arg)) {
    arg = [arg];
  }
  return arg;
};

/**
 * Plugin: "restore_on_backspace" (Tom Select)
 * Copyright (c) contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 */

function plugin () {
  const self = this;
  const orig_canLoad = self.canLoad;
  const orig_clearActiveOption = self.clearActiveOption;
  const orig_loadCallback = self.loadCallback;
  var pagination = {};
  var dropdown_content;
  var loading_more = false;
  var load_more_opt;
  var default_values = [];
  if (!self.settings.shouldLoadMore) {
    // return true if additional results should be loaded
    self.settings.shouldLoadMore = () => {
      const scroll_percent = dropdown_content.clientHeight / (dropdown_content.scrollHeight - dropdown_content.scrollTop);
      if (scroll_percent > 0.9) {
        return true;
      }
      if (self.activeOption) {
        var selectable = self.selectable();
        var index = Array.from(selectable).indexOf(self.activeOption);
        if (index >= selectable.length - 2) {
          return true;
        }
      }
      return false;
    };
  }
  if (!self.settings.firstUrl) {
    throw 'virtual_scroll plugin requires a firstUrl() method';
  }

  // in order for virtual scrolling to work,
  // options need to be ordered the same way they're returned from the remote data source
  self.settings.sortField = [{
    field: '$order'
  }, {
    field: '$score'
  }];

  // can we load more results for given query?
  const canLoadMore = query => {
    if (typeof self.settings.maxOptions === 'number' && dropdown_content.children.length >= self.settings.maxOptions) {
      return false;
    }
    if (query in pagination && pagination[query]) {
      return true;
    }
    return false;
  };
  const clearFilter = (option, value) => {
    if (self.items.indexOf(value) >= 0 || default_values.indexOf(value) >= 0) {
      return true;
    }
    return false;
  };

  // set the next url that will be
  self.setNextUrl = (value, next_url) => {
    pagination[value] = next_url;
  };

  // getUrl() to be used in settings.load()
  self.getUrl = query => {
    if (query in pagination) {
      const next_url = pagination[query];
      pagination[query] = false;
      return next_url;
    }

    // if the user goes back to a previous query
    // we need to load the first page again
    self.clearPagination();
    return self.settings.firstUrl.call(self, query);
  };

  // clear pagination
  self.clearPagination = () => {
    pagination = {};
  };

  // don't clear the active option (and cause unwanted dropdown scroll)
  // while loading more results
  self.hook('instead', 'clearActiveOption', () => {
    if (loading_more) {
      return;
    }
    return orig_clearActiveOption.call(self);
  });

  // override the canLoad method
  self.hook('instead', 'canLoad', query => {
    // first time the query has been seen
    if (!(query in pagination)) {
      return orig_canLoad.call(self, query);
    }
    return canLoadMore(query);
  });

  // wrap the load
  self.hook('instead', 'loadCallback', (options, optgroups) => {
    if (!loading_more) {
      self.clearOptions(clearFilter);
    } else if (load_more_opt) {
      const first_option = options[0];
      if (first_option !== undefined) {
        load_more_opt.dataset.value = first_option[self.settings.valueField];
      }
    }
    orig_loadCallback.call(self, options, optgroups);
    loading_more = false;
  });

  // add templates to dropdown
  //	loading_more if we have another url in the queue
  //	no_more_results if we don't have another url in the queue
  self.hook('after', 'refreshOptions', () => {
    const query = self.lastValue;
    var option;
    if (canLoadMore(query)) {
      option = self.render('loading_more', {
        query: query
      });
      if (option) {
        option.setAttribute('data-selectable', ''); // so that navigating dropdown with [down] keypresses can navigate to this node
        load_more_opt = option;
      }
    } else if (query in pagination && !dropdown_content.querySelector('.no-results')) {
      option = self.render('no_more_results', {
        query: query
      });
    }
    if (option) {
      addClasses(option, self.settings.optionClass);
      dropdown_content.append(option);
    }
  });

  // add scroll listener and default templates
  self.on('initialize', () => {
    default_values = Object.keys(self.options);
    dropdown_content = self.dropdown_content;

    // default templates
    self.settings.render = Object.assign({}, {
      loading_more: () => {
        return `<div class="loading-more-results">Loading more results ... </div>`;
      },
      no_more_results: () => {
        return `<div class="no-more-results">No more results</div>`;
      }
    }, self.settings.render);

    // watch dropdown content scroll position
    dropdown_content.addEventListener('scroll', () => {
      if (!self.settings.shouldLoadMore.call(self)) {
        return;
      }

      // !important: this will get checked again in load() but we still need to check here otherwise loading_more will be set to true
      if (!canLoadMore(self.lastValue)) {
        return;
      }

      // don't call load() too much
      if (loading_more) return;
      loading_more = true;
      self.load.call(self, self.lastValue);
    });
  });
}


//# sourceMappingURL=plugin.js.map


/***/ }),

/***/ "./node_modules/tom-select/dist/esm/tom-select.complete.js":
/*!*****************************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/tom-select.complete.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tom_select_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tom-select.js */ "./node_modules/tom-select/dist/esm/tom-select.js");
/* harmony import */ var _plugins_change_listener_plugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugins/change_listener/plugin.js */ "./node_modules/tom-select/dist/esm/plugins/change_listener/plugin.js");
/* harmony import */ var _plugins_checkbox_options_plugin_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plugins/checkbox_options/plugin.js */ "./node_modules/tom-select/dist/esm/plugins/checkbox_options/plugin.js");
/* harmony import */ var _plugins_clear_button_plugin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plugins/clear_button/plugin.js */ "./node_modules/tom-select/dist/esm/plugins/clear_button/plugin.js");
/* harmony import */ var _plugins_drag_drop_plugin_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./plugins/drag_drop/plugin.js */ "./node_modules/tom-select/dist/esm/plugins/drag_drop/plugin.js");
/* harmony import */ var _plugins_dropdown_header_plugin_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./plugins/dropdown_header/plugin.js */ "./node_modules/tom-select/dist/esm/plugins/dropdown_header/plugin.js");
/* harmony import */ var _plugins_caret_position_plugin_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./plugins/caret_position/plugin.js */ "./node_modules/tom-select/dist/esm/plugins/caret_position/plugin.js");
/* harmony import */ var _plugins_dropdown_input_plugin_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./plugins/dropdown_input/plugin.js */ "./node_modules/tom-select/dist/esm/plugins/dropdown_input/plugin.js");
/* harmony import */ var _plugins_input_autogrow_plugin_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./plugins/input_autogrow/plugin.js */ "./node_modules/tom-select/dist/esm/plugins/input_autogrow/plugin.js");
/* harmony import */ var _plugins_no_backspace_delete_plugin_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./plugins/no_backspace_delete/plugin.js */ "./node_modules/tom-select/dist/esm/plugins/no_backspace_delete/plugin.js");
/* harmony import */ var _plugins_no_active_items_plugin_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./plugins/no_active_items/plugin.js */ "./node_modules/tom-select/dist/esm/plugins/no_active_items/plugin.js");
/* harmony import */ var _plugins_optgroup_columns_plugin_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./plugins/optgroup_columns/plugin.js */ "./node_modules/tom-select/dist/esm/plugins/optgroup_columns/plugin.js");
/* harmony import */ var _plugins_remove_button_plugin_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./plugins/remove_button/plugin.js */ "./node_modules/tom-select/dist/esm/plugins/remove_button/plugin.js");
/* harmony import */ var _plugins_restore_on_backspace_plugin_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./plugins/restore_on_backspace/plugin.js */ "./node_modules/tom-select/dist/esm/plugins/restore_on_backspace/plugin.js");
/* harmony import */ var _plugins_virtual_scroll_plugin_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./plugins/virtual_scroll/plugin.js */ "./node_modules/tom-select/dist/esm/plugins/virtual_scroll/plugin.js");















_tom_select_js__WEBPACK_IMPORTED_MODULE_0__["default"].define('change_listener', _plugins_change_listener_plugin_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
_tom_select_js__WEBPACK_IMPORTED_MODULE_0__["default"].define('checkbox_options', _plugins_checkbox_options_plugin_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
_tom_select_js__WEBPACK_IMPORTED_MODULE_0__["default"].define('clear_button', _plugins_clear_button_plugin_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
_tom_select_js__WEBPACK_IMPORTED_MODULE_0__["default"].define('drag_drop', _plugins_drag_drop_plugin_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
_tom_select_js__WEBPACK_IMPORTED_MODULE_0__["default"].define('dropdown_header', _plugins_dropdown_header_plugin_js__WEBPACK_IMPORTED_MODULE_5__["default"]);
_tom_select_js__WEBPACK_IMPORTED_MODULE_0__["default"].define('caret_position', _plugins_caret_position_plugin_js__WEBPACK_IMPORTED_MODULE_6__["default"]);
_tom_select_js__WEBPACK_IMPORTED_MODULE_0__["default"].define('dropdown_input', _plugins_dropdown_input_plugin_js__WEBPACK_IMPORTED_MODULE_7__["default"]);
_tom_select_js__WEBPACK_IMPORTED_MODULE_0__["default"].define('input_autogrow', _plugins_input_autogrow_plugin_js__WEBPACK_IMPORTED_MODULE_8__["default"]);
_tom_select_js__WEBPACK_IMPORTED_MODULE_0__["default"].define('no_backspace_delete', _plugins_no_backspace_delete_plugin_js__WEBPACK_IMPORTED_MODULE_9__["default"]);
_tom_select_js__WEBPACK_IMPORTED_MODULE_0__["default"].define('no_active_items', _plugins_no_active_items_plugin_js__WEBPACK_IMPORTED_MODULE_10__["default"]);
_tom_select_js__WEBPACK_IMPORTED_MODULE_0__["default"].define('optgroup_columns', _plugins_optgroup_columns_plugin_js__WEBPACK_IMPORTED_MODULE_11__["default"]);
_tom_select_js__WEBPACK_IMPORTED_MODULE_0__["default"].define('remove_button', _plugins_remove_button_plugin_js__WEBPACK_IMPORTED_MODULE_12__["default"]);
_tom_select_js__WEBPACK_IMPORTED_MODULE_0__["default"].define('restore_on_backspace', _plugins_restore_on_backspace_plugin_js__WEBPACK_IMPORTED_MODULE_13__["default"]);
_tom_select_js__WEBPACK_IMPORTED_MODULE_0__["default"].define('virtual_scroll', _plugins_virtual_scroll_plugin_js__WEBPACK_IMPORTED_MODULE_14__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (_tom_select_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
//# sourceMappingURL=tom-select.complete.js.map

/***/ }),

/***/ "./node_modules/tom-select/dist/esm/tom-select.js":
/*!********************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/tom-select.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ TomSelect; }
/* harmony export */ });
/* harmony import */ var _contrib_microevent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./contrib/microevent.js */ "./node_modules/tom-select/dist/esm/contrib/microevent.js");
/* harmony import */ var _contrib_microplugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./contrib/microplugin.js */ "./node_modules/tom-select/dist/esm/contrib/microplugin.js");
/* harmony import */ var _orchidjs_sifter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @orchidjs/sifter */ "./node_modules/@orchidjs/sifter/dist/esm/sifter.js");
/* harmony import */ var _orchidjs_unicode_variants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @orchidjs/unicode-variants */ "./node_modules/@orchidjs/unicode-variants/dist/esm/index.js");
/* harmony import */ var _contrib_highlight_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./contrib/highlight.js */ "./node_modules/tom-select/dist/esm/contrib/highlight.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants.js */ "./node_modules/tom-select/dist/esm/constants.js");
/* harmony import */ var _getSettings_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getSettings.js */ "./node_modules/tom-select/dist/esm/getSettings.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils.js */ "./node_modules/tom-select/dist/esm/utils.js");
/* harmony import */ var _vanilla_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./vanilla.js */ "./node_modules/tom-select/dist/esm/vanilla.js");









var instance_i = 0;
class TomSelect extends (0,_contrib_microplugin_js__WEBPACK_IMPORTED_MODULE_1__["default"])(_contrib_microevent_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
    constructor(input_arg, user_settings) {
        super();
        this.order = 0;
        this.isOpen = false;
        this.isDisabled = false;
        this.isReadOnly = false;
        this.isInvalid = false; // @deprecated 1.8
        this.isValid = true;
        this.isLocked = false;
        this.isFocused = false;
        this.isInputHidden = false;
        this.isSetup = false;
        this.ignoreFocus = false;
        this.ignoreHover = false;
        this.hasOptions = false;
        this.lastValue = '';
        this.caretPos = 0;
        this.loading = 0;
        this.loadedSearches = {};
        this.activeOption = null;
        this.activeItems = [];
        this.optgroups = {};
        this.options = {};
        this.userOptions = {};
        this.items = [];
        this.refreshTimeout = null;
        instance_i++;
        var dir;
        var input = (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.getDom)(input_arg);
        if (input.tomselect) {
            throw new Error('Tom Select already initialized on this element');
        }
        input.tomselect = this;
        // detect rtl environment
        var computedStyle = window.getComputedStyle && window.getComputedStyle(input, null);
        dir = computedStyle.getPropertyValue('direction');
        // setup default state
        const settings = (0,_getSettings_js__WEBPACK_IMPORTED_MODULE_6__["default"])(input, user_settings);
        this.settings = settings;
        this.input = input;
        this.tabIndex = input.tabIndex || 0;
        this.is_select_tag = input.tagName.toLowerCase() === 'select';
        this.rtl = /rtl/i.test(dir);
        this.inputId = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.getId)(input, 'tomselect-' + instance_i);
        this.isRequired = input.required;
        // search system
        this.sifter = new _orchidjs_sifter__WEBPACK_IMPORTED_MODULE_2__.Sifter(this.options, { diacritics: settings.diacritics });
        // option-dependent defaults
        settings.mode = settings.mode || (settings.maxItems === 1 ? 'single' : 'multi');
        if (typeof settings.hideSelected !== 'boolean') {
            settings.hideSelected = settings.mode === 'multi';
        }
        if (typeof settings.hidePlaceholder !== 'boolean') {
            settings.hidePlaceholder = settings.mode !== 'multi';
        }
        // set up createFilter callback
        var filter = settings.createFilter;
        if (typeof filter !== 'function') {
            if (typeof filter === 'string') {
                filter = new RegExp(filter);
            }
            if (filter instanceof RegExp) {
                settings.createFilter = (input) => filter.test(input);
            }
            else {
                settings.createFilter = (value) => {
                    return this.settings.duplicates || !this.options[value];
                };
            }
        }
        this.initializePlugins(settings.plugins);
        this.setupCallbacks();
        this.setupTemplates();
        // Create all elements
        const wrapper = (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.getDom)('<div>');
        const control = (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.getDom)('<div>');
        const dropdown = this._render('dropdown');
        const dropdown_content = (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.getDom)(`<div role="listbox" tabindex="-1">`);
        const classes = this.input.getAttribute('class') || '';
        const inputMode = settings.mode;
        var control_input;
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.addClasses)(wrapper, settings.wrapperClass, classes, inputMode);
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.addClasses)(control, settings.controlClass);
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.append)(wrapper, control);
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.addClasses)(dropdown, settings.dropdownClass, inputMode);
        if (settings.copyClassesToDropdown) {
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.addClasses)(dropdown, classes);
        }
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.addClasses)(dropdown_content, settings.dropdownContentClass);
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.append)(dropdown, dropdown_content);
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.getDom)(settings.dropdownParent || wrapper).appendChild(dropdown);
        // default controlInput
        if ((0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.isHtmlString)(settings.controlInput)) {
            control_input = (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.getDom)(settings.controlInput);
            // set attributes
            var attrs = ['autocorrect', 'autocapitalize', 'autocomplete', 'spellcheck'];
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.iterate)(attrs, (attr) => {
                if (input.getAttribute(attr)) {
                    (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(control_input, { [attr]: input.getAttribute(attr) });
                }
            });
            control_input.tabIndex = -1;
            control.appendChild(control_input);
            this.focus_node = control_input;
            // dom element
        }
        else if (settings.controlInput) {
            control_input = (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.getDom)(settings.controlInput);
            this.focus_node = control_input;
        }
        else {
            control_input = (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.getDom)('<input/>');
            this.focus_node = control;
        }
        this.wrapper = wrapper;
        this.dropdown = dropdown;
        this.dropdown_content = dropdown_content;
        this.control = control;
        this.control_input = control_input;
        this.setup();
    }
    /**
     * set up event bindings.
     *
     */
    setup() {
        const self = this;
        const settings = self.settings;
        const control_input = self.control_input;
        const dropdown = self.dropdown;
        const dropdown_content = self.dropdown_content;
        const wrapper = self.wrapper;
        const control = self.control;
        const input = self.input;
        const focus_node = self.focus_node;
        const passive_event = { passive: true };
        const listboxId = self.inputId + '-ts-dropdown';
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(dropdown_content, {
            id: listboxId
        });
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(focus_node, {
            role: 'combobox',
            'aria-haspopup': 'listbox',
            'aria-expanded': 'false',
            'aria-controls': listboxId
        });
        const control_id = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.getId)(focus_node, self.inputId + '-ts-control');
        const query = "label[for='" + (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.escapeQuery)(self.inputId) + "']";
        const label = document.querySelector(query);
        const label_click = self.focus.bind(self);
        if (label) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addEvent)(label, 'click', label_click);
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(label, { for: control_id });
            const label_id = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.getId)(label, self.inputId + '-ts-label');
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(focus_node, { 'aria-labelledby': label_id });
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(dropdown_content, { 'aria-labelledby': label_id });
        }
        wrapper.style.width = input.style.width;
        if (self.plugins.names.length) {
            const classes_plugins = 'plugin-' + self.plugins.names.join(' plugin-');
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.addClasses)([wrapper, dropdown], classes_plugins);
        }
        if ((settings.maxItems === null || settings.maxItems > 1) && self.is_select_tag) {
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(input, { multiple: 'multiple' });
        }
        if (settings.placeholder) {
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(control_input, { placeholder: settings.placeholder });
        }
        // if splitOn was not passed in, construct it from the delimiter to allow pasting universally
        if (!settings.splitOn && settings.delimiter) {
            settings.splitOn = new RegExp('\\s*' + (0,_orchidjs_unicode_variants__WEBPACK_IMPORTED_MODULE_3__.escape_regex)(settings.delimiter) + '+\\s*');
        }
        // debounce user defined load() if loadThrottle > 0
        // after initializePlugins() so plugins can create/modify user defined loaders
        if (settings.load && settings.loadThrottle) {
            settings.load = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.loadDebounce)(settings.load, settings.loadThrottle);
        }
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addEvent)(dropdown, 'mousemove', () => {
            self.ignoreHover = false;
        });
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addEvent)(dropdown, 'mouseenter', (e) => {
            var target_match = (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.parentMatch)(e.target, '[data-selectable]', dropdown);
            if (target_match)
                self.onOptionHover(e, target_match);
        }, { capture: true });
        // clicking on an option should select it
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addEvent)(dropdown, 'click', (evt) => {
            const option = (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.parentMatch)(evt.target, '[data-selectable]');
            if (option) {
                self.onOptionSelect(evt, option);
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(evt, true);
            }
        });
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addEvent)(control, 'click', (evt) => {
            var target_match = (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.parentMatch)(evt.target, '[data-ts-item]', control);
            if (target_match && self.onItemSelect(evt, target_match)) {
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(evt, true);
                return;
            }
            // retain focus (see control_input mousedown)
            if (control_input.value != '') {
                return;
            }
            self.onClick();
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(evt, true);
        });
        // keydown on focus_node for arrow_down/arrow_up
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addEvent)(focus_node, 'keydown', (e) => self.onKeyDown(e));
        // keypress and input/keyup
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addEvent)(control_input, 'keypress', (e) => self.onKeyPress(e));
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addEvent)(control_input, 'input', (e) => self.onInput(e));
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addEvent)(focus_node, 'blur', (e) => self.onBlur(e));
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addEvent)(focus_node, 'focus', (e) => self.onFocus(e));
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addEvent)(control_input, 'paste', (e) => self.onPaste(e));
        const doc_mousedown = (evt) => {
            // blur if target is outside of this instance
            // dropdown is not always inside wrapper
            const target = evt.composedPath()[0];
            if (!wrapper.contains(target) && !dropdown.contains(target)) {
                if (self.isFocused) {
                    self.blur();
                }
                self.inputState();
                return;
            }
            // retain focus by preventing native handling. if the
            // event target is the input it should not be modified.
            // otherwise, text selection within the input won't work.
            // Fixes bug #212 which is no covered by tests
            if (target == control_input && self.isOpen) {
                evt.stopPropagation();
                // clicking anywhere in the control should not blur the control_input (which would close the dropdown)
            }
            else {
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(evt, true);
            }
        };
        const win_scroll = () => {
            if (self.isOpen) {
                self.positionDropdown();
            }
        };
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addEvent)(document, 'mousedown', doc_mousedown);
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addEvent)(window, 'scroll', win_scroll, passive_event);
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addEvent)(window, 'resize', win_scroll, passive_event);
        this._destroy = () => {
            document.removeEventListener('mousedown', doc_mousedown);
            window.removeEventListener('scroll', win_scroll);
            window.removeEventListener('resize', win_scroll);
            if (label)
                label.removeEventListener('click', label_click);
        };
        // store original html and tab index so that they can be
        // restored when the destroy() method is called.
        this.revertSettings = {
            innerHTML: input.innerHTML,
            tabIndex: input.tabIndex
        };
        input.tabIndex = -1;
        input.insertAdjacentElement('afterend', self.wrapper);
        self.sync(false);
        settings.items = [];
        delete settings.optgroups;
        delete settings.options;
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addEvent)(input, 'invalid', () => {
            if (self.isValid) {
                self.isValid = false;
                self.isInvalid = true;
                self.refreshState();
            }
        });
        self.updateOriginalInput();
        self.refreshItems();
        self.close(false);
        self.inputState();
        self.isSetup = true;
        if (input.disabled) {
            self.disable();
        }
        else if (input.readOnly) {
            self.setReadOnly(true);
        }
        else {
            self.enable(); //sets tabIndex
        }
        self.on('change', this.onChange);
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.addClasses)(input, 'tomselected', 'ts-hidden-accessible');
        self.trigger('initialize');
        // preload options
        if (settings.preload === true) {
            self.preload();
        }
    }
    /**
     * Register options and optgroups
     *
     */
    setupOptions(options = [], optgroups = []) {
        // build options table
        this.addOptions(options);
        // build optgroup table
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.iterate)(optgroups, (optgroup) => {
            this.registerOptionGroup(optgroup);
        });
    }
    /**
     * Sets up default rendering functions.
     */
    setupTemplates() {
        var self = this;
        var field_label = self.settings.labelField;
        var field_optgroup = self.settings.optgroupLabelField;
        var templates = {
            'optgroup': (data) => {
                let optgroup = document.createElement('div');
                optgroup.className = 'optgroup';
                optgroup.appendChild(data.options);
                return optgroup;
            },
            'optgroup_header': (data, escape) => {
                return '<div class="optgroup-header">' + escape(data[field_optgroup]) + '</div>';
            },
            'option': (data, escape) => {
                return '<div>' + escape(data[field_label]) + '</div>';
            },
            'item': (data, escape) => {
                return '<div>' + escape(data[field_label]) + '</div>';
            },
            'option_create': (data, escape) => {
                return '<div class="create">Add <strong>' + escape(data.input) + '</strong>&hellip;</div>';
            },
            'no_results': () => {
                return '<div class="no-results">No results found</div>';
            },
            'loading': () => {
                return '<div class="spinner"></div>';
            },
            'not_loading': () => { },
            'dropdown': () => {
                return '<div></div>';
            }
        };
        self.settings.render = Object.assign({}, templates, self.settings.render);
    }
    /**
     * Maps fired events to callbacks provided
     * in the settings used when creating the control.
     */
    setupCallbacks() {
        var key, fn;
        var callbacks = {
            'initialize': 'onInitialize',
            'change': 'onChange',
            'item_add': 'onItemAdd',
            'item_remove': 'onItemRemove',
            'item_select': 'onItemSelect',
            'clear': 'onClear',
            'option_add': 'onOptionAdd',
            'option_remove': 'onOptionRemove',
            'option_clear': 'onOptionClear',
            'optgroup_add': 'onOptionGroupAdd',
            'optgroup_remove': 'onOptionGroupRemove',
            'optgroup_clear': 'onOptionGroupClear',
            'dropdown_open': 'onDropdownOpen',
            'dropdown_close': 'onDropdownClose',
            'type': 'onType',
            'load': 'onLoad',
            'focus': 'onFocus',
            'blur': 'onBlur'
        };
        for (key in callbacks) {
            fn = this.settings[callbacks[key]];
            if (fn)
                this.on(key, fn);
        }
    }
    /**
     * Sync the Tom Select instance with the original input or select
     *
     */
    sync(get_settings = true) {
        const self = this;
        const settings = get_settings ? (0,_getSettings_js__WEBPACK_IMPORTED_MODULE_6__["default"])(self.input, { delimiter: self.settings.delimiter }) : self.settings;
        self.setupOptions(settings.options, settings.optgroups);
        self.setValue(settings.items || [], true); // silent prevents recursion
        self.lastQuery = null; // so updated options will be displayed in dropdown
    }
    /**
     * Triggered when the main control element
     * has a click event.
     *
     */
    onClick() {
        var self = this;
        if (self.activeItems.length > 0) {
            self.clearActiveItems();
            self.focus();
            return;
        }
        if (self.isFocused && self.isOpen) {
            self.blur();
        }
        else {
            self.focus();
        }
    }
    /**
     * @deprecated v1.7
     *
     */
    onMouseDown() { }
    /**
     * Triggered when the value of the control has been changed.
     * This should propagate the event to the original DOM
     * input / select element.
     */
    onChange() {
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.triggerEvent)(this.input, 'input');
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.triggerEvent)(this.input, 'change');
    }
    /**
     * Triggered on <input> paste.
     *
     */
    onPaste(e) {
        var self = this;
        if (self.isInputHidden || self.isLocked) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e);
            return;
        }
        // If a regex or string is included, this will split the pasted
        // input and create Items for each separate value
        if (!self.settings.splitOn) {
            return;
        }
        // Wait for pasted text to be recognized in value
        setTimeout(() => {
            var pastedText = self.inputValue();
            if (!pastedText.match(self.settings.splitOn)) {
                return;
            }
            var splitInput = pastedText.trim().split(self.settings.splitOn);
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.iterate)(splitInput, (piece) => {
                const hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.hash_key)(piece);
                if (hash) {
                    if (this.options[piece]) {
                        self.addItem(piece);
                    }
                    else {
                        self.createItem(piece);
                    }
                }
            });
        }, 0);
    }
    /**
     * Triggered on <input> keypress.
     *
     */
    onKeyPress(e) {
        var self = this;
        if (self.isLocked) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e);
            return;
        }
        var character = String.fromCharCode(e.keyCode || e.which);
        if (self.settings.create && self.settings.mode === 'multi' && character === self.settings.delimiter) {
            self.createItem();
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e);
            return;
        }
    }
    /**
     * Triggered on <input> keydown.
     *
     */
    onKeyDown(e) {
        var self = this;
        self.ignoreHover = true;
        if (self.isLocked) {
            if (e.keyCode !== _constants_js__WEBPACK_IMPORTED_MODULE_5__.KEY_TAB) {
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e);
            }
            return;
        }
        switch (e.keyCode) {
            // ctrl+A: select all
            case _constants_js__WEBPACK_IMPORTED_MODULE_5__.KEY_A:
                if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.isKeyDown)(_constants_js__WEBPACK_IMPORTED_MODULE_5__.KEY_SHORTCUT, e)) {
                    if (self.control_input.value == '') {
                        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e);
                        self.selectAll();
                        return;
                    }
                }
                break;
            // esc: close dropdown
            case _constants_js__WEBPACK_IMPORTED_MODULE_5__.KEY_ESC:
                if (self.isOpen) {
                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e, true);
                    self.close();
                }
                self.clearActiveItems();
                return;
            // down: open dropdown or move selection down
            case _constants_js__WEBPACK_IMPORTED_MODULE_5__.KEY_DOWN:
                if (!self.isOpen && self.hasOptions) {
                    self.open();
                }
                else if (self.activeOption) {
                    let next = self.getAdjacent(self.activeOption, 1);
                    if (next)
                        self.setActiveOption(next);
                }
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e);
                return;
            // up: move selection up
            case _constants_js__WEBPACK_IMPORTED_MODULE_5__.KEY_UP:
                if (self.activeOption) {
                    let prev = self.getAdjacent(self.activeOption, -1);
                    if (prev)
                        self.setActiveOption(prev);
                }
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e);
                return;
            // return: select active option
            case _constants_js__WEBPACK_IMPORTED_MODULE_5__.KEY_RETURN:
                if (self.canSelect(self.activeOption)) {
                    self.onOptionSelect(e, self.activeOption);
                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e);
                    // if the option_create=null, the dropdown might be closed
                }
                else if (self.settings.create && self.createItem()) {
                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e);
                    // don't submit form when searching for a value
                }
                else if (document.activeElement == self.control_input && self.isOpen) {
                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e);
                }
                return;
            // left: modifiy item selection to the left
            case _constants_js__WEBPACK_IMPORTED_MODULE_5__.KEY_LEFT:
                self.advanceSelection(-1, e);
                return;
            // right: modifiy item selection to the right
            case _constants_js__WEBPACK_IMPORTED_MODULE_5__.KEY_RIGHT:
                self.advanceSelection(1, e);
                return;
            // tab: select active option and/or create item
            case _constants_js__WEBPACK_IMPORTED_MODULE_5__.KEY_TAB:
                if (self.settings.selectOnTab) {
                    if (self.canSelect(self.activeOption)) {
                        self.onOptionSelect(e, self.activeOption);
                        // prevent default [tab] behaviour of jump to the next field
                        // if select isFull, then the dropdown won't be open and [tab] will work normally
                        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e);
                    }
                    if (self.settings.create && self.createItem()) {
                        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e);
                    }
                }
                return;
            // delete|backspace: delete items
            case _constants_js__WEBPACK_IMPORTED_MODULE_5__.KEY_BACKSPACE:
            case _constants_js__WEBPACK_IMPORTED_MODULE_5__.KEY_DELETE:
                self.deleteSelection(e);
                return;
        }
        // don't enter text in the control_input when active items are selected
        if (self.isInputHidden && !(0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.isKeyDown)(_constants_js__WEBPACK_IMPORTED_MODULE_5__.KEY_SHORTCUT, e)) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e);
        }
    }
    /**
     * Triggered on <input> keyup.
     *
     */
    onInput(e) {
        if (this.isLocked) {
            return;
        }
        const value = this.inputValue();
        if (this.lastValue === value)
            return;
        this.lastValue = value;
        if (value == '') {
            this._onInput();
            return;
        }
        if (this.refreshTimeout) {
            window.clearTimeout(this.refreshTimeout);
        }
        this.refreshTimeout = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.timeout)(() => {
            this.refreshTimeout = null;
            this._onInput();
        }, this.settings.refreshThrottle);
    }
    _onInput() {
        const value = this.lastValue;
        if (this.settings.shouldLoad.call(this, value)) {
            this.load(value);
        }
        this.refreshOptions();
        this.trigger('type', value);
    }
    /**
     * Triggered when the user rolls over
     * an option in the autocomplete dropdown menu.
     *
     */
    onOptionHover(evt, option) {
        if (this.ignoreHover)
            return;
        this.setActiveOption(option, false);
    }
    /**
     * Triggered on <input> focus.
     *
     */
    onFocus(e) {
        var self = this;
        var wasFocused = self.isFocused;
        if (self.isDisabled || self.isReadOnly) {
            self.blur();
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e);
            return;
        }
        if (self.ignoreFocus)
            return;
        self.isFocused = true;
        if (self.settings.preload === 'focus')
            self.preload();
        if (!wasFocused)
            self.trigger('focus');
        if (!self.activeItems.length) {
            self.inputState();
            self.refreshOptions(!!self.settings.openOnFocus);
        }
        self.refreshState();
    }
    /**
     * Triggered on <input> blur.
     *
     */
    onBlur(e) {
        if (document.hasFocus() === false)
            return;
        var self = this;
        if (!self.isFocused)
            return;
        self.isFocused = false;
        self.ignoreFocus = false;
        var deactivate = () => {
            self.close();
            self.setActiveItem();
            self.setCaret(self.items.length);
            self.trigger('blur');
        };
        if (self.settings.create && self.settings.createOnBlur) {
            self.createItem(null, deactivate);
        }
        else {
            deactivate();
        }
    }
    /**
     * Triggered when the user clicks on an option
     * in the autocomplete dropdown menu.
     *
     */
    onOptionSelect(evt, option) {
        var value, self = this;
        // should not be possible to trigger a option under a disabled optgroup
        if (option.parentElement && option.parentElement.matches('[data-disabled]')) {
            return;
        }
        if (option.classList.contains('create')) {
            self.createItem(null, () => {
                if (self.settings.closeAfterSelect) {
                    self.close();
                }
            });
        }
        else {
            value = option.dataset.value;
            if (typeof value !== 'undefined') {
                self.lastQuery = null;
                self.addItem(value);
                if (self.settings.closeAfterSelect) {
                    self.close();
                }
                if (!self.settings.hideSelected && evt.type && /click/.test(evt.type)) {
                    self.setActiveOption(option);
                }
            }
        }
    }
    /**
     * Return true if the given option can be selected
     *
     */
    canSelect(option) {
        if (this.isOpen && option && this.dropdown_content.contains(option)) {
            return true;
        }
        return false;
    }
    /**
     * Triggered when the user clicks on an item
     * that has been selected.
     *
     */
    onItemSelect(evt, item) {
        var self = this;
        if (!self.isLocked && self.settings.mode === 'multi') {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(evt);
            self.setActiveItem(item, evt);
            return true;
        }
        return false;
    }
    /**
     * Determines whether or not to invoke
     * the user-provided option provider / loader
     *
     * Note, there is a subtle difference between
     * this.canLoad() and this.settings.shouldLoad();
     *
     *	- settings.shouldLoad() is a user-input validator.
     *	When false is returned, the not_loading template
     *	will be added to the dropdown
     *
     *	- canLoad() is lower level validator that checks
     * 	the Tom Select instance. There is no inherent user
     *	feedback when canLoad returns false
     *
     */
    canLoad(value) {
        if (!this.settings.load)
            return false;
        if (this.loadedSearches.hasOwnProperty(value))
            return false;
        return true;
    }
    /**
     * Invokes the user-provided option provider / loader.
     *
     */
    load(value) {
        const self = this;
        if (!self.canLoad(value))
            return;
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.addClasses)(self.wrapper, self.settings.loadingClass);
        self.loading++;
        const callback = self.loadCallback.bind(self);
        self.settings.load.call(self, value, callback);
    }
    /**
     * Invoked by the user-provided option provider
     *
     */
    loadCallback(options, optgroups) {
        const self = this;
        self.loading = Math.max(self.loading - 1, 0);
        self.lastQuery = null;
        self.clearActiveOption(); // when new results load, focus should be on first option
        self.setupOptions(options, optgroups);
        self.refreshOptions(self.isFocused && !self.isInputHidden);
        if (!self.loading) {
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.removeClasses)(self.wrapper, self.settings.loadingClass);
        }
        self.trigger('load', options, optgroups);
    }
    preload() {
        var classList = this.wrapper.classList;
        if (classList.contains('preloaded'))
            return;
        classList.add('preloaded');
        this.load('');
    }
    /**
     * Sets the input field of the control to the specified value.
     *
     */
    setTextboxValue(value = '') {
        var input = this.control_input;
        var changed = input.value !== value;
        if (changed) {
            input.value = value;
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.triggerEvent)(input, 'update');
            this.lastValue = value;
        }
    }
    /**
     * Returns the value of the control. If multiple items
     * can be selected (e.g. <select multiple>), this returns
     * an array. If only one item can be selected, this
     * returns a string.
     *
     */
    getValue() {
        if (this.is_select_tag && this.input.hasAttribute('multiple')) {
            return this.items;
        }
        return this.items.join(this.settings.delimiter);
    }
    /**
     * Resets the selected items to the given value.
     *
     */
    setValue(value, silent) {
        var events = silent ? [] : ['change'];
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.debounce_events)(this, events, () => {
            this.clear(silent);
            this.addItems(value, silent);
        });
    }
    /**
     * Resets the number of max items to the given value
     *
     */
    setMaxItems(value) {
        if (value === 0)
            value = null; //reset to unlimited items.
        this.settings.maxItems = value;
        this.refreshState();
    }
    /**
     * Sets the selected item.
     *
     */
    setActiveItem(item, e) {
        var self = this;
        var eventName;
        var i, begin, end, swap;
        var last;
        if (self.settings.mode === 'single')
            return;
        // clear the active selection
        if (!item) {
            self.clearActiveItems();
            if (self.isFocused) {
                self.inputState();
            }
            return;
        }
        // modify selection
        eventName = e && e.type.toLowerCase();
        if (eventName === 'click' && (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.isKeyDown)('shiftKey', e) && self.activeItems.length) {
            last = self.getLastActive();
            begin = Array.prototype.indexOf.call(self.control.children, last);
            end = Array.prototype.indexOf.call(self.control.children, item);
            if (begin > end) {
                swap = begin;
                begin = end;
                end = swap;
            }
            for (i = begin; i <= end; i++) {
                item = self.control.children[i];
                if (self.activeItems.indexOf(item) === -1) {
                    self.setActiveItemClass(item);
                }
            }
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e);
        }
        else if ((eventName === 'click' && (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.isKeyDown)(_constants_js__WEBPACK_IMPORTED_MODULE_5__.KEY_SHORTCUT, e)) || (eventName === 'keydown' && (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.isKeyDown)('shiftKey', e))) {
            if (item.classList.contains('active')) {
                self.removeActiveItem(item);
            }
            else {
                self.setActiveItemClass(item);
            }
        }
        else {
            self.clearActiveItems();
            self.setActiveItemClass(item);
        }
        // ensure control has focus
        self.inputState();
        if (!self.isFocused) {
            self.focus();
        }
    }
    /**
     * Set the active and last-active classes
     *
     */
    setActiveItemClass(item) {
        const self = this;
        const last_active = self.control.querySelector('.last-active');
        if (last_active)
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.removeClasses)(last_active, 'last-active');
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.addClasses)(item, 'active last-active');
        self.trigger('item_select', item);
        if (self.activeItems.indexOf(item) == -1) {
            self.activeItems.push(item);
        }
    }
    /**
     * Remove active item
     *
     */
    removeActiveItem(item) {
        var idx = this.activeItems.indexOf(item);
        this.activeItems.splice(idx, 1);
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.removeClasses)(item, 'active');
    }
    /**
     * Clears all the active items
     *
     */
    clearActiveItems() {
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.removeClasses)(this.activeItems, 'active');
        this.activeItems = [];
    }
    /**
     * Sets the selected item in the dropdown menu
     * of available options.
     *
     */
    setActiveOption(option, scroll = true) {
        if (option === this.activeOption) {
            return;
        }
        this.clearActiveOption();
        if (!option)
            return;
        this.activeOption = option;
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(this.focus_node, { 'aria-activedescendant': option.getAttribute('id') });
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(option, { 'aria-selected': 'true' });
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.addClasses)(option, 'active');
        if (scroll)
            this.scrollToOption(option);
    }
    /**
     * Sets the dropdown_content scrollTop to display the option
     *
     */
    scrollToOption(option, behavior) {
        if (!option)
            return;
        const content = this.dropdown_content;
        const height_menu = content.clientHeight;
        const scrollTop = content.scrollTop || 0;
        const height_item = option.offsetHeight;
        const y = option.getBoundingClientRect().top - content.getBoundingClientRect().top + scrollTop;
        if (y + height_item > height_menu + scrollTop) {
            this.scroll(y - height_menu + height_item, behavior);
        }
        else if (y < scrollTop) {
            this.scroll(y, behavior);
        }
    }
    /**
     * Scroll the dropdown to the given position
     *
     */
    scroll(scrollTop, behavior) {
        const content = this.dropdown_content;
        if (behavior) {
            content.style.scrollBehavior = behavior;
        }
        content.scrollTop = scrollTop;
        content.style.scrollBehavior = '';
    }
    /**
     * Clears the active option
     *
     */
    clearActiveOption() {
        if (this.activeOption) {
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.removeClasses)(this.activeOption, 'active');
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(this.activeOption, { 'aria-selected': null });
        }
        this.activeOption = null;
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(this.focus_node, { 'aria-activedescendant': null });
    }
    /**
     * Selects all items (CTRL + A).
     */
    selectAll() {
        const self = this;
        if (self.settings.mode === 'single')
            return;
        const activeItems = self.controlChildren();
        if (!activeItems.length)
            return;
        self.inputState();
        self.close();
        self.activeItems = activeItems;
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.iterate)(activeItems, (item) => {
            self.setActiveItemClass(item);
        });
    }
    /**
     * Determines if the control_input should be in a hidden or visible state
     *
     */
    inputState() {
        var self = this;
        if (!self.control.contains(self.control_input))
            return;
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(self.control_input, { placeholder: self.settings.placeholder });
        if (self.activeItems.length > 0 || (!self.isFocused && self.settings.hidePlaceholder && self.items.length > 0)) {
            self.setTextboxValue();
            self.isInputHidden = true;
        }
        else {
            if (self.settings.hidePlaceholder && self.items.length > 0) {
                (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(self.control_input, { placeholder: '' });
            }
            self.isInputHidden = false;
        }
        self.wrapper.classList.toggle('input-hidden', self.isInputHidden);
    }
    /**
     * Get the input value
     */
    inputValue() {
        return this.control_input.value.trim();
    }
    /**
     * Gives the control focus.
     */
    focus() {
        var self = this;
        if (self.isDisabled || self.isReadOnly)
            return;
        self.ignoreFocus = true;
        if (self.control_input.offsetWidth) {
            self.control_input.focus();
        }
        else {
            self.focus_node.focus();
        }
        setTimeout(() => {
            self.ignoreFocus = false;
            self.onFocus();
        }, 0);
    }
    /**
     * Forces the control out of focus.
     *
     */
    blur() {
        this.focus_node.blur();
        this.onBlur();
    }
    /**
     * Returns a function that scores an object
     * to show how good of a match it is to the
     * provided query.
     *
     * @return {function}
     */
    getScoreFunction(query) {
        return this.sifter.getScoreFunction(query, this.getSearchOptions());
    }
    /**
     * Returns search options for sifter (the system
     * for scoring and sorting results).
     *
     * @see https://github.com/orchidjs/sifter.js
     * @return {object}
     */
    getSearchOptions() {
        var settings = this.settings;
        var sort = settings.sortField;
        if (typeof settings.sortField === 'string') {
            sort = [{ field: settings.sortField }];
        }
        return {
            fields: settings.searchField,
            conjunction: settings.searchConjunction,
            sort: sort,
            nesting: settings.nesting
        };
    }
    /**
     * Searches through available options and returns
     * a sorted array of matches.
     *
     */
    search(query) {
        var result, calculateScore;
        var self = this;
        var options = this.getSearchOptions();
        // validate user-provided result scoring function
        if (self.settings.score) {
            calculateScore = self.settings.score.call(self, query);
            if (typeof calculateScore !== 'function') {
                throw new Error('Tom Select "score" setting must be a function that returns a function');
            }
        }
        // perform search
        if (query !== self.lastQuery) {
            self.lastQuery = query;
            result = self.sifter.search(query, Object.assign(options, { score: calculateScore }));
            self.currentResults = result;
        }
        else {
            result = Object.assign({}, self.currentResults);
        }
        // filter out selected items
        if (self.settings.hideSelected) {
            result.items = result.items.filter((item) => {
                let hashed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.hash_key)(item.id);
                return !(hashed && self.items.indexOf(hashed) !== -1);
            });
        }
        return result;
    }
    /**
     * Refreshes the list of available options shown
     * in the autocomplete dropdown menu.
     *
     */
    refreshOptions(triggerDropdown = true) {
        var i, j, k, n, optgroup, optgroups, html, has_create_option, active_group;
        var create;
        const groups = {};
        const groups_order = [];
        var self = this;
        var query = self.inputValue();
        const same_query = query === self.lastQuery || (query == '' && self.lastQuery == null);
        var results = self.search(query);
        var active_option = null;
        var show_dropdown = self.settings.shouldOpen || false;
        var dropdown_content = self.dropdown_content;
        if (same_query) {
            active_option = self.activeOption;
            if (active_option) {
                active_group = active_option.closest('[data-group]');
            }
        }
        // build markup
        n = results.items.length;
        if (typeof self.settings.maxOptions === 'number') {
            n = Math.min(n, self.settings.maxOptions);
        }
        if (n > 0) {
            show_dropdown = true;
        }
        // get fragment for group and the position of the group in group_order
        const getGroupFragment = (optgroup, order) => {
            let group_order_i = groups[optgroup];
            if (group_order_i !== undefined) {
                let order_group = groups_order[group_order_i];
                if (order_group !== undefined) {
                    return [group_order_i, order_group.fragment];
                }
            }
            let group_fragment = document.createDocumentFragment();
            group_order_i = groups_order.length;
            groups_order.push({ fragment: group_fragment, order, optgroup });
            return [group_order_i, group_fragment];
        };
        // render and group available options individually
        for (i = 0; i < n; i++) {
            // get option dom element
            let item = results.items[i];
            if (!item)
                continue;
            let opt_value = item.id;
            let option = self.options[opt_value];
            if (option === undefined)
                continue;
            let opt_hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.get_hash)(opt_value);
            let option_el = self.getOption(opt_hash, true);
            // toggle 'selected' class
            if (!self.settings.hideSelected) {
                option_el.classList.toggle('selected', self.items.includes(opt_hash));
            }
            optgroup = option[self.settings.optgroupField] || '';
            optgroups = Array.isArray(optgroup) ? optgroup : [optgroup];
            for (j = 0, k = optgroups && optgroups.length; j < k; j++) {
                optgroup = optgroups[j];
                let order = option.$order;
                let self_optgroup = self.optgroups[optgroup];
                if (self_optgroup === undefined) {
                    optgroup = '';
                }
                else {
                    order = self_optgroup.$order;
                }
                const [group_order_i, group_fragment] = getGroupFragment(optgroup, order);
                // nodes can only have one parent, so if the option is in mutple groups, we need a clone
                if (j > 0) {
                    option_el = option_el.cloneNode(true);
                    (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(option_el, { id: option.$id + '-clone-' + j, 'aria-selected': null });
                    option_el.classList.add('ts-cloned');
                    (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.removeClasses)(option_el, 'active');
                    // make sure we keep the activeOption in the same group
                    if (self.activeOption && self.activeOption.dataset.value == opt_value) {
                        if (active_group && active_group.dataset.group === optgroup.toString()) {
                            active_option = option_el;
                        }
                    }
                }
                group_fragment.appendChild(option_el);
                if (optgroup != '') {
                    groups[optgroup] = group_order_i;
                }
            }
        }
        // sort optgroups
        if (self.settings.lockOptgroupOrder) {
            groups_order.sort((a, b) => {
                return a.order - b.order;
            });
        }
        // render optgroup headers & join groups
        html = document.createDocumentFragment();
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.iterate)(groups_order, (group_order) => {
            let group_fragment = group_order.fragment;
            let optgroup = group_order.optgroup;
            if (!group_fragment || !group_fragment.children.length)
                return;
            let group_heading = self.optgroups[optgroup];
            if (group_heading !== undefined) {
                let group_options = document.createDocumentFragment();
                let header = self.render('optgroup_header', group_heading);
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.append)(group_options, header);
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.append)(group_options, group_fragment);
                let group_html = self.render('optgroup', { group: group_heading, options: group_options });
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.append)(html, group_html);
            }
            else {
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.append)(html, group_fragment);
            }
        });
        dropdown_content.innerHTML = '';
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.append)(dropdown_content, html);
        // highlight matching terms inline
        if (self.settings.highlight) {
            (0,_contrib_highlight_js__WEBPACK_IMPORTED_MODULE_4__.removeHighlight)(dropdown_content);
            if (results.query.length && results.tokens.length) {
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.iterate)(results.tokens, (tok) => {
                    (0,_contrib_highlight_js__WEBPACK_IMPORTED_MODULE_4__.highlight)(dropdown_content, tok.regex);
                });
            }
        }
        // helper method for adding templates to dropdown
        var add_template = (template) => {
            let content = self.render(template, { input: query });
            if (content) {
                show_dropdown = true;
                dropdown_content.insertBefore(content, dropdown_content.firstChild);
            }
            return content;
        };
        // add loading message
        if (self.loading) {
            add_template('loading');
            // invalid query
        }
        else if (!self.settings.shouldLoad.call(self, query)) {
            add_template('not_loading');
            // add no_results message
        }
        else if (results.items.length === 0) {
            add_template('no_results');
        }
        // add create option
        has_create_option = self.canCreate(query);
        if (has_create_option) {
            create = add_template('option_create');
        }
        // activate
        self.hasOptions = results.items.length > 0 || has_create_option;
        if (show_dropdown) {
            if (results.items.length > 0) {
                if (!active_option && self.settings.mode === 'single' && self.items[0] != undefined) {
                    active_option = self.getOption(self.items[0]);
                }
                if (!dropdown_content.contains(active_option)) {
                    let active_index = 0;
                    if (create && !self.settings.addPrecedence) {
                        active_index = 1;
                    }
                    active_option = self.selectable()[active_index];
                }
            }
            else if (create) {
                active_option = create;
            }
            if (triggerDropdown && !self.isOpen) {
                self.open();
                self.scrollToOption(active_option, 'auto');
            }
            self.setActiveOption(active_option);
        }
        else {
            self.clearActiveOption();
            if (triggerDropdown && self.isOpen) {
                self.close(false); // if create_option=null, we want the dropdown to close but not reset the textbox value
            }
        }
    }
    /**
     * Return list of selectable options
     *
     */
    selectable() {
        return this.dropdown_content.querySelectorAll('[data-selectable]');
    }
    /**
     * Adds an available option. If it already exists,
     * nothing will happen. Note: this does not refresh
     * the options list dropdown (use `refreshOptions`
     * for that).
     *
     * Usage:
     *
     *   this.addOption(data)
     *
     */
    addOption(data, user_created = false) {
        const self = this;
        // @deprecated 1.7.7
        // use addOptions( array, user_created ) for adding multiple options
        if (Array.isArray(data)) {
            self.addOptions(data, user_created);
            return false;
        }
        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.hash_key)(data[self.settings.valueField]);
        if (key === null || self.options.hasOwnProperty(key)) {
            return false;
        }
        data.$order = data.$order || ++self.order;
        data.$id = self.inputId + '-opt-' + data.$order;
        self.options[key] = data;
        self.lastQuery = null;
        if (user_created) {
            self.userOptions[key] = user_created;
            self.trigger('option_add', key, data);
        }
        return key;
    }
    /**
     * Add multiple options
     *
     */
    addOptions(data, user_created = false) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.iterate)(data, (dat) => {
            this.addOption(dat, user_created);
        });
    }
    /**
     * @deprecated 1.7.7
     */
    registerOption(data) {
        return this.addOption(data);
    }
    /**
     * Registers an option group to the pool of option groups.
     *
     * @return {boolean|string}
     */
    registerOptionGroup(data) {
        var key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.hash_key)(data[this.settings.optgroupValueField]);
        if (key === null)
            return false;
        data.$order = data.$order || ++this.order;
        this.optgroups[key] = data;
        return key;
    }
    /**
     * Registers a new optgroup for options
     * to be bucketed into.
     *
     */
    addOptionGroup(id, data) {
        var hashed_id;
        data[this.settings.optgroupValueField] = id;
        if (hashed_id = this.registerOptionGroup(data)) {
            this.trigger('optgroup_add', hashed_id, data);
        }
    }
    /**
     * Removes an existing option group.
     *
     */
    removeOptionGroup(id) {
        if (this.optgroups.hasOwnProperty(id)) {
            delete this.optgroups[id];
            this.clearCache();
            this.trigger('optgroup_remove', id);
        }
    }
    /**
     * Clears all existing option groups.
     */
    clearOptionGroups() {
        this.optgroups = {};
        this.clearCache();
        this.trigger('optgroup_clear');
    }
    /**
     * Updates an option available for selection. If
     * it is visible in the selected items or options
     * dropdown, it will be re-rendered automatically.
     *
     */
    updateOption(value, data) {
        const self = this;
        var item_new;
        var index_item;
        const value_old = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.hash_key)(value);
        const value_new = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.hash_key)(data[self.settings.valueField]);
        // sanity checks
        if (value_old === null)
            return;
        const data_old = self.options[value_old];
        if (data_old == undefined)
            return;
        if (typeof value_new !== 'string')
            throw new Error('Value must be set in option data');
        const option = self.getOption(value_old);
        const item = self.getItem(value_old);
        data.$order = data.$order || data_old.$order;
        delete self.options[value_old];
        // invalidate render cache
        // don't remove existing node yet, we'll remove it after replacing it
        self.uncacheValue(value_new);
        self.options[value_new] = data;
        // update the option if it's in the dropdown
        if (option) {
            if (self.dropdown_content.contains(option)) {
                const option_new = self._render('option', data);
                (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.replaceNode)(option, option_new);
                if (self.activeOption === option) {
                    self.setActiveOption(option_new);
                }
            }
            option.remove();
        }
        // update the item if we have one
        if (item) {
            index_item = self.items.indexOf(value_old);
            if (index_item !== -1) {
                self.items.splice(index_item, 1, value_new);
            }
            item_new = self._render('item', data);
            if (item.classList.contains('active'))
                (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.addClasses)(item_new, 'active');
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.replaceNode)(item, item_new);
        }
        // invalidate last query because we might have updated the sortField
        self.lastQuery = null;
    }
    /**
     * Removes a single option.
     *
     */
    removeOption(value, silent) {
        const self = this;
        value = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.get_hash)(value);
        self.uncacheValue(value);
        delete self.userOptions[value];
        delete self.options[value];
        self.lastQuery = null;
        self.trigger('option_remove', value);
        self.removeItem(value, silent);
    }
    /**
     * Clears all options.
     */
    clearOptions(filter) {
        const boundFilter = (filter || this.clearFilter).bind(this);
        this.loadedSearches = {};
        this.userOptions = {};
        this.clearCache();
        const selected = {};
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.iterate)(this.options, (option, key) => {
            if (boundFilter(option, key)) {
                selected[key] = option;
            }
        });
        this.options = this.sifter.items = selected;
        this.lastQuery = null;
        this.trigger('option_clear');
    }
    /**
     * Used by clearOptions() to decide whether or not an option should be removed
     * Return true to keep an option, false to remove
     *
     */
    clearFilter(option, value) {
        if (this.items.indexOf(value) >= 0) {
            return true;
        }
        return false;
    }
    /**
     * Returns the dom element of the option
     * matching the given value.
     *
     */
    getOption(value, create = false) {
        const hashed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.hash_key)(value);
        if (hashed === null)
            return null;
        const option = this.options[hashed];
        if (option != undefined) {
            if (option.$div) {
                return option.$div;
            }
            if (create) {
                return this._render('option', option);
            }
        }
        return null;
    }
    /**
     * Returns the dom element of the next or previous dom element of the same type
     * Note: adjacent options may not be adjacent DOM elements (optgroups)
     *
     */
    getAdjacent(option, direction, type = 'option') {
        var self = this, all;
        if (!option) {
            return null;
        }
        if (type == 'item') {
            all = self.controlChildren();
        }
        else {
            all = self.dropdown_content.querySelectorAll('[data-selectable]');
        }
        for (let i = 0; i < all.length; i++) {
            if (all[i] != option) {
                continue;
            }
            if (direction > 0) {
                return all[i + 1];
            }
            return all[i - 1];
        }
        return null;
    }
    /**
     * Returns the dom element of the item
     * matching the given value.
     *
     */
    getItem(item) {
        if (typeof item == 'object') {
            return item;
        }
        var value = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.hash_key)(item);
        return value !== null
            ? this.control.querySelector(`[data-value="${(0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addSlashes)(value)}"]`)
            : null;
    }
    /**
     * "Selects" multiple items at once. Adds them to the list
     * at the current caret position.
     *
     */
    addItems(values, silent) {
        var self = this;
        var items = Array.isArray(values) ? values : [values];
        items = items.filter(x => self.items.indexOf(x) === -1);
        const last_item = items[items.length - 1];
        items.forEach(item => {
            self.isPending = (item !== last_item);
            self.addItem(item, silent);
        });
    }
    /**
     * "Selects" an item. Adds it to the list
     * at the current caret position.
     *
     */
    addItem(value, silent) {
        var events = silent ? [] : ['change', 'dropdown_close'];
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.debounce_events)(this, events, () => {
            var item, wasFull;
            const self = this;
            const inputMode = self.settings.mode;
            const hashed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.hash_key)(value);
            if (hashed && self.items.indexOf(hashed) !== -1) {
                if (inputMode === 'single') {
                    self.close();
                }
                if (inputMode === 'single' || !self.settings.duplicates) {
                    return;
                }
            }
            if (hashed === null || !self.options.hasOwnProperty(hashed))
                return;
            if (inputMode === 'single')
                self.clear(silent);
            if (inputMode === 'multi' && self.isFull())
                return;
            item = self._render('item', self.options[hashed]);
            if (self.control.contains(item)) { // duplicates
                item = item.cloneNode(true);
            }
            wasFull = self.isFull();
            self.items.splice(self.caretPos, 0, hashed);
            self.insertAtCaret(item);
            if (self.isSetup) {
                // update menu / remove the option (if this is not one item being added as part of series)
                if (!self.isPending && self.settings.hideSelected) {
                    let option = self.getOption(hashed);
                    let next = self.getAdjacent(option, 1);
                    if (next) {
                        self.setActiveOption(next);
                    }
                }
                // refreshOptions after setActiveOption(),
                // otherwise setActiveOption() will be called by refreshOptions() with the wrong value
                if (!self.isPending && !self.settings.closeAfterSelect) {
                    self.refreshOptions(self.isFocused && inputMode !== 'single');
                }
                // hide the menu if the maximum number of items have been selected or no options are left
                if (self.settings.closeAfterSelect != false && self.isFull()) {
                    self.close();
                }
                else if (!self.isPending) {
                    self.positionDropdown();
                }
                self.trigger('item_add', hashed, item);
                if (!self.isPending) {
                    self.updateOriginalInput({ silent: silent });
                }
            }
            if (!self.isPending || (!wasFull && self.isFull())) {
                self.inputState();
                self.refreshState();
            }
        });
    }
    /**
     * Removes the selected item matching
     * the provided value.
     *
     */
    removeItem(item = null, silent) {
        const self = this;
        item = self.getItem(item);
        if (!item)
            return;
        var i, idx;
        const value = item.dataset.value;
        i = (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.nodeIndex)(item);
        item.remove();
        if (item.classList.contains('active')) {
            idx = self.activeItems.indexOf(item);
            self.activeItems.splice(idx, 1);
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.removeClasses)(item, 'active');
        }
        self.items.splice(i, 1);
        self.lastQuery = null;
        if (!self.settings.persist && self.userOptions.hasOwnProperty(value)) {
            self.removeOption(value, silent);
        }
        if (i < self.caretPos) {
            self.setCaret(self.caretPos - 1);
        }
        self.updateOriginalInput({ silent: silent });
        self.refreshState();
        self.positionDropdown();
        self.trigger('item_remove', value, item);
    }
    /**
     * Invokes the `create` method provided in the
     * TomSelect options that should provide the data
     * for the new item, given the user input.
     *
     * Once this completes, it will be added
     * to the item list.
     *
     */
    createItem(input = null, callback = () => { }) {
        // triggerDropdown parameter @deprecated 2.1.1
        if (arguments.length === 3) {
            callback = arguments[2];
        }
        if (typeof callback != 'function') {
            callback = () => { };
        }
        var self = this;
        var caret = self.caretPos;
        var output;
        input = input || self.inputValue();
        if (!self.canCreate(input)) {
            callback();
            return false;
        }
        self.lock();
        var created = false;
        var create = (data) => {
            self.unlock();
            if (!data || typeof data !== 'object')
                return callback();
            var value = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.hash_key)(data[self.settings.valueField]);
            if (typeof value !== 'string') {
                return callback();
            }
            self.setTextboxValue();
            self.addOption(data, true);
            self.setCaret(caret);
            self.addItem(value);
            callback(data);
            created = true;
        };
        if (typeof self.settings.create === 'function') {
            output = self.settings.create.call(this, input, create);
        }
        else {
            output = {
                [self.settings.labelField]: input,
                [self.settings.valueField]: input,
            };
        }
        if (!created) {
            create(output);
        }
        return true;
    }
    /**
     * Re-renders the selected item lists.
     */
    refreshItems() {
        var self = this;
        self.lastQuery = null;
        if (self.isSetup) {
            self.addItems(self.items);
        }
        self.updateOriginalInput();
        self.refreshState();
    }
    /**
     * Updates all state-dependent attributes
     * and CSS classes.
     */
    refreshState() {
        const self = this;
        self.refreshValidityState();
        const isFull = self.isFull();
        const isLocked = self.isLocked;
        self.wrapper.classList.toggle('rtl', self.rtl);
        const wrap_classList = self.wrapper.classList;
        wrap_classList.toggle('focus', self.isFocused);
        wrap_classList.toggle('disabled', self.isDisabled);
        wrap_classList.toggle('readonly', self.isReadOnly);
        wrap_classList.toggle('required', self.isRequired);
        wrap_classList.toggle('invalid', !self.isValid);
        wrap_classList.toggle('locked', isLocked);
        wrap_classList.toggle('full', isFull);
        wrap_classList.toggle('input-active', self.isFocused && !self.isInputHidden);
        wrap_classList.toggle('dropdown-active', self.isOpen);
        wrap_classList.toggle('has-options', (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.isEmptyObject)(self.options));
        wrap_classList.toggle('has-items', self.items.length > 0);
    }
    /**
     * Update the `required` attribute of both input and control input.
     *
     * The `required` property needs to be activated on the control input
     * for the error to be displayed at the right place. `required` also
     * needs to be temporarily deactivated on the input since the input is
     * hidden and can't show errors.
     */
    refreshValidityState() {
        var self = this;
        if (!self.input.validity) {
            return;
        }
        self.isValid = self.input.validity.valid;
        self.isInvalid = !self.isValid;
    }
    /**
     * Determines whether or not more items can be added
     * to the control without exceeding the user-defined maximum.
     *
     * @returns {boolean}
     */
    isFull() {
        return this.settings.maxItems !== null && this.items.length >= this.settings.maxItems;
    }
    /**
     * Refreshes the original <select> or <input>
     * element to reflect the current state.
     *
     */
    updateOriginalInput(opts = {}) {
        const self = this;
        var option, label;
        const empty_option = self.input.querySelector('option[value=""]');
        if (self.is_select_tag) {
            const selected = [];
            const has_selected = self.input.querySelectorAll('option:checked').length;
            function AddSelected(option_el, value, label) {
                if (!option_el) {
                    option_el = (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.getDom)('<option value="' + (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.escape_html)(value) + '">' + (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.escape_html)(label) + '</option>');
                }
                // don't move empty option from top of list
                // fixes bug in firefox https://bugzilla.mozilla.org/show_bug.cgi?id=1725293
                if (option_el != empty_option) {
                    self.input.append(option_el);
                }
                selected.push(option_el);
                // marking empty option as selected can break validation
                // fixes https://github.com/orchidjs/tom-select/issues/303
                if (option_el != empty_option || has_selected > 0) {
                    option_el.selected = true;
                }
                return option_el;
            }
            // unselect all selected options
            self.input.querySelectorAll('option:checked').forEach((option_el) => {
                option_el.selected = false;
            });
            // nothing selected?
            if (self.items.length == 0 && self.settings.mode == 'single') {
                AddSelected(empty_option, "", "");
                // order selected <option> tags for values in self.items
            }
            else {
                self.items.forEach((value) => {
                    option = self.options[value];
                    label = option[self.settings.labelField] || '';
                    if (selected.includes(option.$option)) {
                        const reuse_opt = self.input.querySelector(`option[value="${(0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.addSlashes)(value)}"]:not(:checked)`);
                        AddSelected(reuse_opt, value, label);
                    }
                    else {
                        option.$option = AddSelected(option.$option, value, label);
                    }
                });
            }
        }
        else {
            self.input.value = self.getValue();
        }
        if (self.isSetup) {
            if (!opts.silent) {
                self.trigger('change', self.getValue());
            }
        }
    }
    /**
     * Shows the autocomplete dropdown containing
     * the available options.
     */
    open() {
        var self = this;
        if (self.isLocked || self.isOpen || (self.settings.mode === 'multi' && self.isFull()))
            return;
        self.isOpen = true;
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(self.focus_node, { 'aria-expanded': 'true' });
        self.refreshState();
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.applyCSS)(self.dropdown, { visibility: 'hidden', display: 'block' });
        self.positionDropdown();
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.applyCSS)(self.dropdown, { visibility: 'visible', display: 'block' });
        self.focus();
        self.trigger('dropdown_open', self.dropdown);
    }
    /**
     * Closes the autocomplete dropdown menu.
     */
    close(setTextboxValue = true) {
        var self = this;
        var trigger = self.isOpen;
        if (setTextboxValue) {
            // before blur() to prevent form onchange event
            self.setTextboxValue();
            if (self.settings.mode === 'single' && self.items.length) {
                self.inputState();
            }
        }
        self.isOpen = false;
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(self.focus_node, { 'aria-expanded': 'false' });
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.applyCSS)(self.dropdown, { display: 'none' });
        if (self.settings.hideSelected) {
            self.clearActiveOption();
        }
        self.refreshState();
        if (trigger)
            self.trigger('dropdown_close', self.dropdown);
    }
    /**
     * Calculates and applies the appropriate
     * position of the dropdown if dropdownParent = 'body'.
     * Otherwise, position is determined by css
     */
    positionDropdown() {
        if (this.settings.dropdownParent !== 'body') {
            return;
        }
        var context = this.control;
        var rect = context.getBoundingClientRect();
        var top = context.offsetHeight + rect.top + window.scrollY;
        var left = rect.left + window.scrollX;
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.applyCSS)(this.dropdown, {
            width: rect.width + 'px',
            top: top + 'px',
            left: left + 'px'
        });
    }
    /**
     * Resets / clears all selected items
     * from the control.
     *
     */
    clear(silent) {
        var self = this;
        if (!self.items.length)
            return;
        var items = self.controlChildren();
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.iterate)(items, (item) => {
            self.removeItem(item, true);
        });
        self.inputState();
        if (!silent)
            self.updateOriginalInput();
        self.trigger('clear');
    }
    /**
     * A helper method for inserting an element
     * at the current caret position.
     *
     */
    insertAtCaret(el) {
        const self = this;
        const caret = self.caretPos;
        const target = self.control;
        target.insertBefore(el, target.children[caret] || null);
        self.setCaret(caret + 1);
    }
    /**
     * Removes the current selected item(s).
     *
     */
    deleteSelection(e) {
        var direction, selection, caret, tail;
        var self = this;
        direction = (e && e.keyCode === _constants_js__WEBPACK_IMPORTED_MODULE_5__.KEY_BACKSPACE) ? -1 : 1;
        selection = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.getSelection)(self.control_input);
        // determine items that will be removed
        const rm_items = [];
        if (self.activeItems.length) {
            tail = (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.getTail)(self.activeItems, direction);
            caret = (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.nodeIndex)(tail);
            if (direction > 0) {
                caret++;
            }
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.iterate)(self.activeItems, (item) => rm_items.push(item));
        }
        else if ((self.isFocused || self.settings.mode === 'single') && self.items.length) {
            const items = self.controlChildren();
            let rm_item;
            if (direction < 0 && selection.start === 0 && selection.length === 0) {
                rm_item = items[self.caretPos - 1];
            }
            else if (direction > 0 && selection.start === self.inputValue().length) {
                rm_item = items[self.caretPos];
            }
            if (rm_item !== undefined) {
                rm_items.push(rm_item);
            }
        }
        if (!self.shouldDelete(rm_items, e)) {
            return false;
        }
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.preventDefault)(e, true);
        // perform removal
        if (typeof caret !== 'undefined') {
            self.setCaret(caret);
        }
        while (rm_items.length) {
            self.removeItem(rm_items.pop());
        }
        self.inputState();
        self.positionDropdown();
        self.refreshOptions(false);
        return true;
    }
    /**
     * Return true if the items should be deleted
     */
    shouldDelete(items, evt) {
        const values = items.map(item => item.dataset.value);
        // allow the callback to abort
        if (!values.length || (typeof this.settings.onDelete === 'function' && this.settings.onDelete(values, evt) === false)) {
            return false;
        }
        return true;
    }
    /**
     * Selects the previous / next item (depending on the `direction` argument).
     *
     * > 0 - right
     * < 0 - left
     *
     */
    advanceSelection(direction, e) {
        var last_active, adjacent, self = this;
        if (self.rtl)
            direction *= -1;
        if (self.inputValue().length)
            return;
        // add or remove to active items
        if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.isKeyDown)(_constants_js__WEBPACK_IMPORTED_MODULE_5__.KEY_SHORTCUT, e) || (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.isKeyDown)('shiftKey', e)) {
            last_active = self.getLastActive(direction);
            if (last_active) {
                if (!last_active.classList.contains('active')) {
                    adjacent = last_active;
                }
                else {
                    adjacent = self.getAdjacent(last_active, direction, 'item');
                }
                // if no active item, get items adjacent to the control input
            }
            else if (direction > 0) {
                adjacent = self.control_input.nextElementSibling;
            }
            else {
                adjacent = self.control_input.previousElementSibling;
            }
            if (adjacent) {
                if (adjacent.classList.contains('active')) {
                    self.removeActiveItem(last_active);
                }
                self.setActiveItemClass(adjacent); // mark as last_active !! after removeActiveItem() on last_active
            }
            // move caret to the left or right
        }
        else {
            self.moveCaret(direction);
        }
    }
    moveCaret(direction) { }
    /**
     * Get the last active item
     *
     */
    getLastActive(direction) {
        let last_active = this.control.querySelector('.last-active');
        if (last_active) {
            return last_active;
        }
        var result = this.control.querySelectorAll('.active');
        if (result) {
            return (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.getTail)(result, direction);
        }
    }
    /**
     * Moves the caret to the specified index.
     *
     * The input must be moved by leaving it in place and moving the
     * siblings, due to the fact that focus cannot be restored once lost
     * on mobile webkit devices
     *
     */
    setCaret(new_pos) {
        this.caretPos = this.items.length;
    }
    /**
     * Return list of item dom elements
     *
     */
    controlChildren() {
        return Array.from(this.control.querySelectorAll('[data-ts-item]'));
    }
    /**
     * Disables user input on the control. Used while
     * items are being asynchronously created.
     */
    lock() {
        this.setLocked(true);
    }
    /**
     * Re-enables user input on the control.
     */
    unlock() {
        this.setLocked(false);
    }
    /**
     * Disable or enable user input on the control
     */
    setLocked(lock = this.isReadOnly || this.isDisabled) {
        this.isLocked = lock;
        this.refreshState();
    }
    /**
     * Disables user input on the control completely.
     * While disabled, it cannot receive focus.
     */
    disable() {
        this.setDisabled(true);
        this.close();
    }
    /**
     * Enables the control so that it can respond
     * to focus and user input.
     */
    enable() {
        this.setDisabled(false);
    }
    setDisabled(disabled) {
        this.focus_node.tabIndex = disabled ? -1 : this.tabIndex;
        this.isDisabled = disabled;
        this.input.disabled = disabled;
        this.control_input.disabled = disabled;
        this.setLocked();
    }
    setReadOnly(isReadOnly) {
        this.isReadOnly = isReadOnly;
        this.input.readOnly = isReadOnly;
        this.control_input.readOnly = isReadOnly;
        this.setLocked();
    }
    /**
     * Completely destroys the control and
     * unbinds all event listeners so that it can
     * be garbage collected.
     */
    destroy() {
        var self = this;
        var revertSettings = self.revertSettings;
        self.trigger('destroy');
        self.off();
        self.wrapper.remove();
        self.dropdown.remove();
        self.input.innerHTML = revertSettings.innerHTML;
        self.input.tabIndex = revertSettings.tabIndex;
        (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.removeClasses)(self.input, 'tomselected', 'ts-hidden-accessible');
        self._destroy();
        delete self.input.tomselect;
    }
    /**
     * A helper method for rendering "item" and
     * "option" templates, given the data.
     *
     */
    render(templateName, data) {
        var id, html;
        const self = this;
        if (typeof this.settings.render[templateName] !== 'function') {
            return null;
        }
        // render markup
        html = self.settings.render[templateName].call(this, data, _utils_js__WEBPACK_IMPORTED_MODULE_7__.escape_html);
        if (!html) {
            return null;
        }
        html = (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.getDom)(html);
        // add mandatory attributes
        if (templateName === 'option' || templateName === 'option_create') {
            if (data[self.settings.disabledField]) {
                (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(html, { 'aria-disabled': 'true' });
            }
            else {
                (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(html, { 'data-selectable': '' });
            }
        }
        else if (templateName === 'optgroup') {
            id = data.group[self.settings.optgroupValueField];
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(html, { 'data-group': id });
            if (data.group[self.settings.disabledField]) {
                (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(html, { 'data-disabled': '' });
            }
        }
        if (templateName === 'option' || templateName === 'item') {
            const value = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.get_hash)(data[self.settings.valueField]);
            (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(html, { 'data-value': value });
            // make sure we have some classes if a template is overwritten
            if (templateName === 'item') {
                (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.addClasses)(html, self.settings.itemClass);
                (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(html, { 'data-ts-item': '' });
            }
            else {
                (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.addClasses)(html, self.settings.optionClass);
                (0,_vanilla_js__WEBPACK_IMPORTED_MODULE_8__.setAttr)(html, {
                    role: 'option',
                    id: data.$id
                });
                // update cache
                data.$div = html;
                self.options[value] = data;
            }
        }
        return html;
    }
    /**
     * Type guarded rendering
     *
     */
    _render(templateName, data) {
        const html = this.render(templateName, data);
        if (html == null) {
            throw 'HTMLElement expected';
        }
        return html;
    }
    /**
     * Clears the render cache for a template. If
     * no template is given, clears all render
     * caches.
     *
     */
    clearCache() {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.iterate)(this.options, (option) => {
            if (option.$div) {
                option.$div.remove();
                delete option.$div;
            }
        });
    }
    /**
     * Removes a value from item and option caches
     *
     */
    uncacheValue(value) {
        const option_el = this.getOption(value);
        if (option_el)
            option_el.remove();
    }
    /**
     * Determines whether or not to display the
     * create item prompt, given a user input.
     *
     */
    canCreate(input) {
        return this.settings.create && (input.length > 0) && this.settings.createFilter.call(this, input);
    }
    /**
     * Wraps this.`method` so that `new_fn` can be invoked 'before', 'after', or 'instead' of the original method
     *
     * this.hook('instead','onKeyDown',function( arg1, arg2 ...){
     *
     * });
     */
    hook(when, method, new_fn) {
        var self = this;
        var orig_method = self[method];
        self[method] = function () {
            var result, result_new;
            if (when === 'after') {
                result = orig_method.apply(self, arguments);
            }
            result_new = new_fn.apply(self, arguments);
            if (when === 'instead') {
                return result_new;
            }
            if (when === 'before') {
                result = orig_method.apply(self, arguments);
            }
            return result;
        };
    }
}
;
//# sourceMappingURL=tom-select.js.map

/***/ }),

/***/ "./node_modules/tom-select/dist/esm/utils.js":
/*!***************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/utils.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addEvent: function() { return /* binding */ addEvent; },
/* harmony export */   addSlashes: function() { return /* binding */ addSlashes; },
/* harmony export */   append: function() { return /* binding */ append; },
/* harmony export */   debounce_events: function() { return /* binding */ debounce_events; },
/* harmony export */   escape_html: function() { return /* binding */ escape_html; },
/* harmony export */   getId: function() { return /* binding */ getId; },
/* harmony export */   getSelection: function() { return /* binding */ getSelection; },
/* harmony export */   get_hash: function() { return /* binding */ get_hash; },
/* harmony export */   hash_key: function() { return /* binding */ hash_key; },
/* harmony export */   isKeyDown: function() { return /* binding */ isKeyDown; },
/* harmony export */   iterate: function() { return /* binding */ iterate; },
/* harmony export */   loadDebounce: function() { return /* binding */ loadDebounce; },
/* harmony export */   preventDefault: function() { return /* binding */ preventDefault; },
/* harmony export */   timeout: function() { return /* binding */ timeout; }
/* harmony export */ });
/**
 * Converts a scalar to its best string representation
 * for hash keys and HTML attribute values.
 *
 * Transformations:
 *   'str'     -> 'str'
 *   null      -> ''
 *   undefined -> ''
 *   true      -> '1'
 *   false     -> '0'
 *   0         -> '0'
 *   1         -> '1'
 *
 */
const hash_key = (value) => {
    if (typeof value === 'undefined' || value === null)
        return null;
    return get_hash(value);
};
const get_hash = (value) => {
    if (typeof value === 'boolean')
        return value ? '1' : '0';
    return value + '';
};
/**
 * Escapes a string for use within HTML.
 *
 */
const escape_html = (str) => {
    return (str + '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;');
};
/**
 * use setTimeout if timeout > 0
 */
const timeout = (fn, timeout) => {
    if (timeout > 0) {
        return window.setTimeout(fn, timeout);
    }
    fn.call(null);
    return null;
};
/**
 * Debounce the user provided load function
 *
 */
const loadDebounce = (fn, delay) => {
    var timeout;
    return function (value, callback) {
        var self = this;
        if (timeout) {
            self.loading = Math.max(self.loading - 1, 0);
            clearTimeout(timeout);
        }
        timeout = setTimeout(function () {
            timeout = null;
            self.loadedSearches[value] = true;
            fn.call(self, value, callback);
        }, delay);
    };
};
/**
 * Debounce all fired events types listed in `types`
 * while executing the provided `fn`.
 *
 */
const debounce_events = (self, types, fn) => {
    var type;
    var trigger = self.trigger;
    var event_args = {};
    // override trigger method
    self.trigger = function () {
        var type = arguments[0];
        if (types.indexOf(type) !== -1) {
            event_args[type] = arguments;
        }
        else {
            return trigger.apply(self, arguments);
        }
    };
    // invoke provided function
    fn.apply(self, []);
    self.trigger = trigger;
    // trigger queued events
    for (type of types) {
        if (type in event_args) {
            trigger.apply(self, event_args[type]);
        }
    }
};
/**
 * Determines the current selection within a text input control.
 * Returns an object containing:
 *   - start
 *   - length
 *
 * Note: "selectionStart, selectionEnd ... apply only to inputs of types text, search, URL, tel and password"
 * 	- https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/setSelectionRange
 */
const getSelection = (input) => {
    return {
        start: input.selectionStart || 0,
        length: (input.selectionEnd || 0) - (input.selectionStart || 0),
    };
};
/**
 * Prevent default
 *
 */
const preventDefault = (evt, stop = false) => {
    if (evt) {
        evt.preventDefault();
        if (stop) {
            evt.stopPropagation();
        }
    }
};
/**
 * Add event helper
 *
 */
const addEvent = (target, type, callback, options) => {
    target.addEventListener(type, callback, options);
};
/**
 * Return true if the requested key is down
 * Will return false if more than one control character is pressed ( when [ctrl+shift+a] != [ctrl+a] )
 * The current evt may not always set ( eg calling advanceSelection() )
 *
 */
const isKeyDown = (key_name, evt) => {
    if (!evt) {
        return false;
    }
    if (!evt[key_name]) {
        return false;
    }
    var count = (evt.altKey ? 1 : 0) + (evt.ctrlKey ? 1 : 0) + (evt.shiftKey ? 1 : 0) + (evt.metaKey ? 1 : 0);
    if (count === 1) {
        return true;
    }
    return false;
};
/**
 * Get the id of an element
 * If the id attribute is not set, set the attribute with the given id
 *
 */
const getId = (el, id) => {
    const existing_id = el.getAttribute('id');
    if (existing_id) {
        return existing_id;
    }
    el.setAttribute('id', id);
    return id;
};
/**
 * Returns a string with backslashes added before characters that need to be escaped.
 */
const addSlashes = (str) => {
    return str.replace(/[\\"']/g, '\\$&');
};
/**
 *
 */
const append = (parent, node) => {
    if (node)
        parent.append(node);
};
/**
 * Iterates over arrays and hashes.
 *
 * ```
 * iterate(this.items, function(item, id) {
 *    // invoked for each item
 * });
 * ```
 *
 */
const iterate = (object, callback) => {
    if (Array.isArray(object)) {
        object.forEach(callback);
    }
    else {
        for (var key in object) {
            if (object.hasOwnProperty(key)) {
                callback(object[key], key);
            }
        }
    }
};
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/tom-select/dist/esm/vanilla.js":
/*!*****************************************************!*\
  !*** ./node_modules/tom-select/dist/esm/vanilla.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addClasses: function() { return /* binding */ addClasses; },
/* harmony export */   applyCSS: function() { return /* binding */ applyCSS; },
/* harmony export */   castAsArray: function() { return /* binding */ castAsArray; },
/* harmony export */   classesArray: function() { return /* binding */ classesArray; },
/* harmony export */   escapeQuery: function() { return /* binding */ escapeQuery; },
/* harmony export */   getDom: function() { return /* binding */ getDom; },
/* harmony export */   getTail: function() { return /* binding */ getTail; },
/* harmony export */   isEmptyObject: function() { return /* binding */ isEmptyObject; },
/* harmony export */   isHtmlString: function() { return /* binding */ isHtmlString; },
/* harmony export */   nodeIndex: function() { return /* binding */ nodeIndex; },
/* harmony export */   parentMatch: function() { return /* binding */ parentMatch; },
/* harmony export */   removeClasses: function() { return /* binding */ removeClasses; },
/* harmony export */   replaceNode: function() { return /* binding */ replaceNode; },
/* harmony export */   setAttr: function() { return /* binding */ setAttr; },
/* harmony export */   triggerEvent: function() { return /* binding */ triggerEvent; }
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/tom-select/dist/esm/utils.js");

/**
 * Return a dom element from either a dom query string, jQuery object, a dom element or html string
 * https://stackoverflow.com/questions/494143/creating-a-new-dom-element-from-an-html-string-using-built-in-dom-methods-or-pro/35385518#35385518
 *
 * param query should be {}
 */
const getDom = (query) => {
    if (query.jquery) {
        return query[0];
    }
    if (query instanceof HTMLElement) {
        return query;
    }
    if (isHtmlString(query)) {
        var tpl = document.createElement('template');
        tpl.innerHTML = query.trim(); // Never return a text node of whitespace as the result
        return tpl.content.firstChild;
    }
    return document.querySelector(query);
};
const isHtmlString = (arg) => {
    if (typeof arg === 'string' && arg.indexOf('<') > -1) {
        return true;
    }
    return false;
};
const escapeQuery = (query) => {
    return query.replace(/['"\\]/g, '\\$&');
};
/**
 * Dispatch an event
 *
 */
const triggerEvent = (dom_el, event_name) => {
    var event = document.createEvent('HTMLEvents');
    event.initEvent(event_name, true, false);
    dom_el.dispatchEvent(event);
};
/**
 * Apply CSS rules to a dom element
 *
 */
const applyCSS = (dom_el, css) => {
    Object.assign(dom_el.style, css);
};
/**
 * Add css classes
 *
 */
const addClasses = (elmts, ...classes) => {
    var norm_classes = classesArray(classes);
    elmts = castAsArray(elmts);
    elmts.map(el => {
        norm_classes.map(cls => {
            el.classList.add(cls);
        });
    });
};
/**
 * Remove css classes
 *
 */
const removeClasses = (elmts, ...classes) => {
    var norm_classes = classesArray(classes);
    elmts = castAsArray(elmts);
    elmts.map(el => {
        norm_classes.map(cls => {
            el.classList.remove(cls);
        });
    });
};
/**
 * Return arguments
 *
 */
const classesArray = (args) => {
    var classes = [];
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.iterate)(args, (_classes) => {
        if (typeof _classes === 'string') {
            _classes = _classes.trim().split(/[\t\n\f\r\s]/);
        }
        if (Array.isArray(_classes)) {
            classes = classes.concat(_classes);
        }
    });
    return classes.filter(Boolean);
};
/**
 * Create an array from arg if it's not already an array
 *
 */
const castAsArray = (arg) => {
    if (!Array.isArray(arg)) {
        arg = [arg];
    }
    return arg;
};
/**
 * Get the closest node to the evt.target matching the selector
 * Stops at wrapper
 *
 */
const parentMatch = (target, selector, wrapper) => {
    if (wrapper && !wrapper.contains(target)) {
        return;
    }
    while (target && target.matches) {
        if (target.matches(selector)) {
            return target;
        }
        target = target.parentNode;
    }
};
/**
 * Get the first or last item from an array
 *
 * > 0 - right (last)
 * <= 0 - left (first)
 *
 */
const getTail = (list, direction = 0) => {
    if (direction > 0) {
        return list[list.length - 1];
    }
    return list[0];
};
/**
 * Return true if an object is empty
 *
 */
const isEmptyObject = (obj) => {
    return (Object.keys(obj).length === 0);
};
/**
 * Get the index of an element amongst sibling nodes of the same type
 *
 */
const nodeIndex = (el, amongst) => {
    if (!el)
        return -1;
    amongst = amongst || el.nodeName;
    var i = 0;
    while (el = el.previousElementSibling) {
        if (el.matches(amongst)) {
            i++;
        }
    }
    return i;
};
/**
 * Set attributes of an element
 *
 */
const setAttr = (el, attrs) => {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.iterate)(attrs, (val, attr) => {
        if (val == null) {
            el.removeAttribute(attr);
        }
        else {
            el.setAttribute(attr, '' + val);
        }
    });
};
/**
 * Replace a node
 */
const replaceNode = (existing, replacement) => {
    if (existing.parentNode)
        existing.parentNode.replaceChild(replacement, existing);
};
//# sourceMappingURL=vanilla.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfY29yZS1qc19tb2R1bGVzX2VzX2FycmF5X2NvbmNhdF9qcy1ub2RlX21vZHVsZXNfY29yZS1qc19tb2R1bGVzX2VzX2FycmF5LWUzZDQzNy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzRGO0FBQ3RCO0FBQ3RFO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLG9FQUFZO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzRUFBVTtBQUN0QztBQUNBO0FBQ0EsNEJBQTRCLHdFQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscURBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxREFBVTtBQUN6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Q0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixPQUFPO0FBQ1AsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsVUFBVSxhQUFhLG1DQUFtQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRTZCO0FBQzdCOzs7Ozs7Ozs7Ozs7Ozs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUU2QjtBQUM3Qjs7Ozs7Ozs7Ozs7Ozs7O0FDbERBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRTZCO0FBQzdCOzs7Ozs7Ozs7Ozs7Ozs7QUNsTEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZSxXQUFXLFdBQVcsVUFBVTtBQUMzRTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDs7QUFFNkI7QUFDN0I7Ozs7Ozs7Ozs7Ozs7OztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFNkI7QUFDN0I7Ozs7Ozs7Ozs7Ozs7OztBQzNOQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9OQUFvTjtBQUNwTjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7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QSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRTZCO0FBQzdCOzs7Ozs7Ozs7Ozs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRTZCO0FBQzdCOzs7Ozs7Ozs7Ozs7Ozs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHNCQUFzQixzQkFBc0Isd0JBQXdCO0FBQzVHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFNkI7QUFDN0I7Ozs7Ozs7Ozs7Ozs7OztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUU2QjtBQUM3Qjs7Ozs7Ozs7Ozs7Ozs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseURBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlEQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQVU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseURBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9EQUFTLENBQUMsdURBQXNCLFFBQVEsb0RBQVM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvREFBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMERBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGtEQUFXO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbURBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9EQUFPLFNBQVMseUJBQXlCO0FBQ3pEO0FBQ0E7QUFDQSxnQkFBZ0Isb0RBQU8sU0FBUyx1QkFBdUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9EQUFPLFNBQVMsa0JBQWtCO0FBQzlDO0FBQ0EsZ0JBQWdCLG9EQUFPLFNBQVMscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtREFBUTtBQUNsQyxZQUFZLG9EQUFPLFNBQVMscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQSxnQkFBZ0IsdURBQVU7QUFDMUIsZ0JBQWdCLG9EQUFPLFNBQVMsb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQSxnQkFBZ0IsdURBQVU7QUFDMUIsZ0JBQWdCLG9EQUFPO0FBQ3ZCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNXRFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSw2QkFBNkI7QUFDN0IsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1Qiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbE1xQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLElBQUksa0RBQU87QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSxrREFBTztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qamEtZGV2Ly4vbm9kZV9tb2R1bGVzL0BvcmNoaWRqcy9zaWZ0ZXIvZGlzdC9lc20vc2lmdGVyLmpzIiwid2VicGFjazovL2pqYS1kZXYvLi9ub2RlX21vZHVsZXMvQG9yY2hpZGpzL3NpZnRlci9kaXN0L2VzbS90eXBlcy5qcyIsIndlYnBhY2s6Ly9qamEtZGV2Ly4vbm9kZV9tb2R1bGVzL0BvcmNoaWRqcy9zaWZ0ZXIvZGlzdC9lc20vdXRpbHMuanMiLCJ3ZWJwYWNrOi8vamphLWRldi8uL25vZGVfbW9kdWxlcy9Ab3JjaGlkanMvdW5pY29kZS12YXJpYW50cy9kaXN0L2VzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9qamEtZGV2Ly4vbm9kZV9tb2R1bGVzL0BvcmNoaWRqcy91bmljb2RlLXZhcmlhbnRzL2Rpc3QvZXNtL3JlZ2V4LmpzIiwid2VicGFjazovL2pqYS1kZXYvLi9ub2RlX21vZHVsZXMvQG9yY2hpZGpzL3VuaWNvZGUtdmFyaWFudHMvZGlzdC9lc20vc3RyaW5ncy5qcyIsIndlYnBhY2s6Ly9qamEtZGV2Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FkdmFuY2Utc3RyaW5nLWluZGV4LmpzIiwid2VicGFjazovL2pqYS1kZXYvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLW5vbi1leHRlbnNpYmxlLmpzIiwid2VicGFjazovL2pqYS1kZXYvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29sbGVjdGlvbi1zdHJvbmcuanMiLCJ3ZWJwYWNrOi8vamphLWRldi8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb2xsZWN0aW9uLXdlYWsuanMiLCJ3ZWJwYWNrOi8vamphLWRldi8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb2xsZWN0aW9uLmpzIiwid2VicGFjazovL2pqYS1kZXYvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29ycmVjdC1pcy1yZWdleHAtbG9naWMuanMiLCJ3ZWJwYWNrOi8vamphLWRldi8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW5zLmpzIiwid2VicGFjazovL2pqYS1kZXYvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9lcy1ub3QtZXhjZWVkLXNhZmUtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly9qamEtZGV2Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZpeC1yZWdleHAtd2VsbC1rbm93bi1zeW1ib2wtbG9naWMuanMiLCJ3ZWJwYWNrOi8vamphLWRldi8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mcmVlemluZy5qcyIsIndlYnBhY2s6Ly9qamEtZGV2Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1zdWJzdGl0dXRpb24uanMiLCJ3ZWJwYWNrOi8vamphLWRldi8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly9qamEtZGV2Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXJlZ2V4cC5qcyIsIndlYnBhY2s6Ly9qamEtZGV2Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25vdC1hLXJlZ2V4cC5qcyIsIndlYnBhY2s6Ly9qamEtZGV2Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1pcy1leHRlbnNpYmxlLmpzIiwid2VicGFjazovL2pqYS1kZXYvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMtYWJzdHJhY3QuanMiLCJ3ZWJwYWNrOi8vamphLWRldi8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0LmpzIiwid2VicGFjazovL2pqYS1kZXYvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZpbHRlci5qcyIsIndlYnBhY2s6Ly9qamEtZGV2Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maW5kLmpzIiwid2VicGFjazovL2pqYS1kZXYvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluY2x1ZGVzLmpzIiwid2VicGFjazovL2pqYS1kZXYvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5lbnRyaWVzLmpzIiwid2VicGFjazovL2pqYS1kZXYvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vamphLWRldi8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vamphLWRldi8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc2V0LmNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL2pqYS1kZXYvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnNldC5qcyIsIndlYnBhY2s6Ly9qamEtZGV2Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vamphLWRldi8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnJlcGxhY2UuanMiLCJ3ZWJwYWNrOi8vamphLWRldi8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMud2Vhay1zZXQuY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vamphLWRldi8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMud2Vhay1zZXQuanMiLCJ3ZWJwYWNrOi8vamphLWRldi8uL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L2Rpc3QvZXNtL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly9qamEtZGV2Ly4vbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3QvZGlzdC9lc20vY29udHJpYi9oaWdobGlnaHQuanMiLCJ3ZWJwYWNrOi8vamphLWRldi8uL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L2Rpc3QvZXNtL2NvbnRyaWIvbWljcm9ldmVudC5qcyIsIndlYnBhY2s6Ly9qamEtZGV2Ly4vbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3QvZGlzdC9lc20vY29udHJpYi9taWNyb3BsdWdpbi5qcyIsIndlYnBhY2s6Ly9qamEtZGV2Ly4vbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3QvZGlzdC9lc20vZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vamphLWRldi8uL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L2Rpc3QvZXNtL2dldFNldHRpbmdzLmpzIiwid2VicGFjazovL2pqYS1kZXYvLi9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9kaXN0L2VzbS9wbHVnaW5zL2NhcmV0X3Bvc2l0aW9uL3BsdWdpbi5qcyIsIndlYnBhY2s6Ly9qamEtZGV2Ly4vbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3QvZGlzdC9lc20vcGx1Z2lucy9jaGFuZ2VfbGlzdGVuZXIvcGx1Z2luLmpzIiwid2VicGFjazovL2pqYS1kZXYvLi9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9kaXN0L2VzbS9wbHVnaW5zL2NoZWNrYm94X29wdGlvbnMvcGx1Z2luLmpzIiwid2VicGFjazovL2pqYS1kZXYvLi9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9kaXN0L2VzbS9wbHVnaW5zL2NsZWFyX2J1dHRvbi9wbHVnaW4uanMiLCJ3ZWJwYWNrOi8vamphLWRldi8uL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L2Rpc3QvZXNtL3BsdWdpbnMvZHJhZ19kcm9wL3BsdWdpbi5qcyIsIndlYnBhY2s6Ly9qamEtZGV2Ly4vbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3QvZGlzdC9lc20vcGx1Z2lucy9kcm9wZG93bl9oZWFkZXIvcGx1Z2luLmpzIiwid2VicGFjazovL2pqYS1kZXYvLi9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9kaXN0L2VzbS9wbHVnaW5zL2Ryb3Bkb3duX2lucHV0L3BsdWdpbi5qcyIsIndlYnBhY2s6Ly9qamEtZGV2Ly4vbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3QvZGlzdC9lc20vcGx1Z2lucy9pbnB1dF9hdXRvZ3Jvdy9wbHVnaW4uanMiLCJ3ZWJwYWNrOi8vamphLWRldi8uL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L2Rpc3QvZXNtL3BsdWdpbnMvbm9fYWN0aXZlX2l0ZW1zL3BsdWdpbi5qcyIsIndlYnBhY2s6Ly9qamEtZGV2Ly4vbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3QvZGlzdC9lc20vcGx1Z2lucy9ub19iYWNrc3BhY2VfZGVsZXRlL3BsdWdpbi5qcyIsIndlYnBhY2s6Ly9qamEtZGV2Ly4vbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3QvZGlzdC9lc20vcGx1Z2lucy9vcHRncm91cF9jb2x1bW5zL3BsdWdpbi5qcyIsIndlYnBhY2s6Ly9qamEtZGV2Ly4vbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3QvZGlzdC9lc20vcGx1Z2lucy9yZW1vdmVfYnV0dG9uL3BsdWdpbi5qcyIsIndlYnBhY2s6Ly9qamEtZGV2Ly4vbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3QvZGlzdC9lc20vcGx1Z2lucy9yZXN0b3JlX29uX2JhY2tzcGFjZS9wbHVnaW4uanMiLCJ3ZWJwYWNrOi8vamphLWRldi8uL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L2Rpc3QvZXNtL3BsdWdpbnMvdmlydHVhbF9zY3JvbGwvcGx1Z2luLmpzIiwid2VicGFjazovL2pqYS1kZXYvLi9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9kaXN0L2VzbS90b20tc2VsZWN0LmNvbXBsZXRlLmpzIiwid2VicGFjazovL2pqYS1kZXYvLi9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9kaXN0L2VzbS90b20tc2VsZWN0LmpzIiwid2VicGFjazovL2pqYS1kZXYvLi9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9kaXN0L2VzbS91dGlscy5qcyIsIndlYnBhY2s6Ly9qamEtZGV2Ly4vbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3QvZGlzdC9lc20vdmFuaWxsYS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHNpZnRlci5qc1xuICogQ29weXJpZ2h0IChjKSAyMDEz4oCTMjAyMCBCcmlhbiBSZWF2aXMgJiBjb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuICogZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GXG4gKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQGF1dGhvciBCcmlhbiBSZWF2aXMgPGJyaWFuQHRoaXJkcm91dGUuY29tPlxuICovXG5pbXBvcnQgeyBzY29yZVZhbHVlLCBnZXRBdHRyLCBnZXRBdHRyTmVzdGluZywgcHJvcFRvQXJyYXksIGl0ZXJhdGUsIGNtcCB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBnZXRQYXR0ZXJuLCBlc2NhcGVfcmVnZXggfSBmcm9tICdAb3JjaGlkanMvdW5pY29kZS12YXJpYW50cyc7XG5jbGFzcyBTaWZ0ZXIge1xuICAgIGl0ZW1zOyAvLyBbXXx7fTtcbiAgICBzZXR0aW5ncztcbiAgICAvKipcbiAgICAgKiBUZXh0dWFsbHkgc2VhcmNoZXMgYXJyYXlzIGFuZCBoYXNoZXMgb2Ygb2JqZWN0c1xuICAgICAqIGJ5IHByb3BlcnR5IChvciBtdWx0aXBsZSBwcm9wZXJ0aWVzKS4gRGVzaWduZWRcbiAgICAgKiBzcGVjaWZpY2FsbHkgZm9yIGF1dG9jb21wbGV0ZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGl0ZW1zLCBzZXR0aW5ncykge1xuICAgICAgICB0aGlzLml0ZW1zID0gaXRlbXM7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7IGRpYWNyaXRpY3M6IHRydWUgfTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNwbGl0cyBhIHNlYXJjaCBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBpbmRpdmlkdWFsXG4gICAgICogcmVnZXhwcyB0byBiZSB1c2VkIHRvIG1hdGNoIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKi9cbiAgICB0b2tlbml6ZShxdWVyeSwgcmVzcGVjdF93b3JkX2JvdW5kYXJpZXMsIHdlaWdodHMpIHtcbiAgICAgICAgaWYgKCFxdWVyeSB8fCAhcXVlcnkubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICAgICAgY29uc3Qgd29yZHMgPSBxdWVyeS5zcGxpdCgvXFxzKy8pO1xuICAgICAgICB2YXIgZmllbGRfcmVnZXg7XG4gICAgICAgIGlmICh3ZWlnaHRzKSB7XG4gICAgICAgICAgICBmaWVsZF9yZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIE9iamVjdC5rZXlzKHdlaWdodHMpLm1hcChlc2NhcGVfcmVnZXgpLmpvaW4oJ3wnKSArICcpXFw6KC4qKSQnKTtcbiAgICAgICAgfVxuICAgICAgICB3b3Jkcy5mb3JFYWNoKCh3b3JkKSA9PiB7XG4gICAgICAgICAgICBsZXQgZmllbGRfbWF0Y2g7XG4gICAgICAgICAgICBsZXQgZmllbGQgPSBudWxsO1xuICAgICAgICAgICAgbGV0IHJlZ2V4ID0gbnVsbDtcbiAgICAgICAgICAgIC8vIGxvb2sgZm9yIFwiZmllbGQ6cXVlcnlcIiB0b2tlbnNcbiAgICAgICAgICAgIGlmIChmaWVsZF9yZWdleCAmJiAoZmllbGRfbWF0Y2ggPSB3b3JkLm1hdGNoKGZpZWxkX3JlZ2V4KSkpIHtcbiAgICAgICAgICAgICAgICBmaWVsZCA9IGZpZWxkX21hdGNoWzFdO1xuICAgICAgICAgICAgICAgIHdvcmQgPSBmaWVsZF9tYXRjaFsyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3b3JkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5kaWFjcml0aWNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2V4ID0gZ2V0UGF0dGVybih3b3JkKSB8fCBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVnZXggPSBlc2NhcGVfcmVnZXgod29yZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZWdleCAmJiByZXNwZWN0X3dvcmRfYm91bmRhcmllcylcbiAgICAgICAgICAgICAgICAgICAgcmVnZXggPSBcIlxcXFxiXCIgKyByZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzdHJpbmc6IHdvcmQsXG4gICAgICAgICAgICAgICAgcmVnZXg6IHJlZ2V4ID8gbmV3IFJlZ0V4cChyZWdleCwgJ2l1JykgOiBudWxsLFxuICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0byBiZSB1c2VkIHRvIHNjb3JlIGluZGl2aWR1YWwgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEdvb2QgbWF0Y2hlcyB3aWxsIGhhdmUgYSBoaWdoZXIgc2NvcmUgdGhhbiBwb29yIG1hdGNoZXMuXG4gICAgICogSWYgYW4gaXRlbSBpcyBub3QgYSBtYXRjaCwgMCB3aWxsIGJlIHJldHVybmVkIGJ5IHRoZSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtULlNjb3JlRm59XG4gICAgICovXG4gICAgZ2V0U2NvcmVGdW5jdGlvbihxdWVyeSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgc2VhcmNoID0gdGhpcy5wcmVwYXJlU2VhcmNoKHF1ZXJ5LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFNjb3JlRnVuY3Rpb24oc2VhcmNoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1QuU2NvcmVGbn1cbiAgICAgKlxuICAgICAqL1xuICAgIF9nZXRTY29yZUZ1bmN0aW9uKHNlYXJjaCkge1xuICAgICAgICBjb25zdCB0b2tlbnMgPSBzZWFyY2gudG9rZW5zLCB0b2tlbl9jb3VudCA9IHRva2Vucy5sZW5ndGg7XG4gICAgICAgIGlmICghdG9rZW5fY291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiAwOyB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHNlYXJjaC5vcHRpb25zLmZpZWxkcywgd2VpZ2h0cyA9IHNlYXJjaC53ZWlnaHRzLCBmaWVsZF9jb3VudCA9IGZpZWxkcy5sZW5ndGgsIGdldEF0dHJGbiA9IHNlYXJjaC5nZXRBdHRyRm47XG4gICAgICAgIGlmICghZmllbGRfY291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiAxOyB9O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBzY29yZSBvZiBhbiBvYmplY3RcbiAgICAgICAgICogYWdhaW5zdCB0aGUgc2VhcmNoIHF1ZXJ5LlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3Qgc2NvcmVPYmplY3QgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGZpZWxkX2NvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0b2tlbiwgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IGZpZWxkc1swXS5maWVsZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjb3JlVmFsdWUoZ2V0QXR0ckZuKGRhdGEsIGZpZWxkKSwgdG9rZW4sIHdlaWdodHNbZmllbGRdIHx8IDEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRva2VuLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgLy8gaXMgdGhlIHRva2VuIHNwZWNpZmljIHRvIGEgZmllbGQ/XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLmZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0QXR0ckZuKGRhdGEsIHRva2VuLmZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0b2tlbi5yZWdleCAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VtICs9ICgxIC8gZmllbGRfY291bnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VtICs9IHNjb3JlVmFsdWUodmFsdWUsIHRva2VuLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZSh3ZWlnaHRzLCAod2VpZ2h0LCBmaWVsZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VtICs9IHNjb3JlVmFsdWUoZ2V0QXR0ckZuKGRhdGEsIGZpZWxkKSwgdG9rZW4sIHdlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3VtIC8gZmllbGRfY291bnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSgpO1xuICAgICAgICBpZiAodG9rZW5fY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY29yZU9iamVjdCh0b2tlbnNbMF0sIGRhdGEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VhcmNoLm9wdGlvbnMuY29uanVuY3Rpb24gPT09ICdhbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2NvcmUsIHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3JlID0gc2NvcmVPYmplY3QodG9rZW4sIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NvcmUgPD0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gc2NvcmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzdW0gLyB0b2tlbl9jb3VudDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICAgICAgICBpdGVyYXRlKHRva2VucywgKHRva2VuKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBzY29yZU9iamVjdCh0b2tlbiwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1bSAvIHRva2VuX2NvdW50O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gY29tcGFyZSB0d29cbiAgICAgKiByZXN1bHRzLCBmb3Igc29ydGluZyBwdXJwb3Nlcy4gSWYgbm8gc29ydGluZyBzaG91bGRcbiAgICAgKiBiZSBwZXJmb3JtZWQsIGBudWxsYCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHJldHVybiBmdW5jdGlvbihhLGIpXG4gICAgICovXG4gICAgZ2V0U29ydEZ1bmN0aW9uKHF1ZXJ5LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBzZWFyY2ggPSB0aGlzLnByZXBhcmVTZWFyY2gocXVlcnksIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U29ydEZ1bmN0aW9uKHNlYXJjaCk7XG4gICAgfVxuICAgIF9nZXRTb3J0RnVuY3Rpb24oc2VhcmNoKSB7XG4gICAgICAgIHZhciBpbXBsaWNpdF9zY29yZSwgc29ydF9mbGRzID0gW107XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzLCBvcHRpb25zID0gc2VhcmNoLm9wdGlvbnMsIHNvcnQgPSAoIXNlYXJjaC5xdWVyeSAmJiBvcHRpb25zLnNvcnRfZW1wdHkpID8gb3B0aW9ucy5zb3J0X2VtcHR5IDogb3B0aW9ucy5zb3J0O1xuICAgICAgICBpZiAodHlwZW9mIHNvcnQgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHNvcnQuYmluZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2hlcyB0aGUgc3BlY2lmaWVkIHNvcnQgZmllbGQgdmFsdWVcbiAgICAgICAgICogZnJvbSBhIHNlYXJjaCByZXN1bHQgaXRlbS5cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGdldF9maWVsZCA9IGZ1bmN0aW9uIChuYW1lLCByZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnJHNjb3JlJylcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnNjb3JlO1xuICAgICAgICAgICAgcmV0dXJuIHNlYXJjaC5nZXRBdHRyRm4oc2VsZi5pdGVtc1tyZXN1bHQuaWRdLCBuYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gcGFyc2Ugb3B0aW9uc1xuICAgICAgICBpZiAoc29ydCkge1xuICAgICAgICAgICAgZm9yIChsZXQgcyBvZiBzb3J0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlYXJjaC5xdWVyeSB8fCBzLmZpZWxkICE9PSAnJHNjb3JlJykge1xuICAgICAgICAgICAgICAgICAgICBzb3J0X2ZsZHMucHVzaChzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIFwiJHNjb3JlXCIgZmllbGQgaXMgaW1wbGllZCB0byBiZSB0aGUgcHJpbWFyeVxuICAgICAgICAvLyBzb3J0IGZpZWxkLCB1bmxlc3MgaXQncyBtYW51YWxseSBzcGVjaWZpZWRcbiAgICAgICAgaWYgKHNlYXJjaC5xdWVyeSkge1xuICAgICAgICAgICAgaW1wbGljaXRfc2NvcmUgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgZmxkIG9mIHNvcnRfZmxkcykge1xuICAgICAgICAgICAgICAgIGlmIChmbGQuZmllbGQgPT09ICckc2NvcmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGltcGxpY2l0X3Njb3JlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbXBsaWNpdF9zY29yZSkge1xuICAgICAgICAgICAgICAgIHNvcnRfZmxkcy51bnNoaWZ0KHsgZmllbGQ6ICckc2NvcmUnLCBkaXJlY3Rpb246ICdkZXNjJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdpdGhvdXQgYSBzZWFyY2gucXVlcnksIGFsbCBpdGVtcyB3aWxsIGhhdmUgdGhlIHNhbWUgc2NvcmVcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNvcnRfZmxkcyA9IHNvcnRfZmxkcy5maWx0ZXIoKGZsZCkgPT4gZmxkLmZpZWxkICE9PSAnJHNjb3JlJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYnVpbGQgZnVuY3Rpb25cbiAgICAgICAgY29uc3Qgc29ydF9mbGRzX2NvdW50ID0gc29ydF9mbGRzLmxlbmd0aDtcbiAgICAgICAgaWYgKCFzb3J0X2ZsZHNfY291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgZmllbGQ7XG4gICAgICAgICAgICBmb3IgKGxldCBzb3J0X2ZsZCBvZiBzb3J0X2ZsZHMpIHtcbiAgICAgICAgICAgICAgICBmaWVsZCA9IHNvcnRfZmxkLmZpZWxkO1xuICAgICAgICAgICAgICAgIGxldCBtdWx0aXBsaWVyID0gc29ydF9mbGQuZGlyZWN0aW9uID09PSAnZGVzYycgPyAtMSA6IDE7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbXVsdGlwbGllciAqIGNtcChnZXRfZmllbGQoZmllbGQsIGEpLCBnZXRfZmllbGQoZmllbGQsIGIpKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH07XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBzZWFyY2ggcXVlcnkgYW5kIHJldHVybnMgYW4gb2JqZWN0XG4gICAgICogd2l0aCB0b2tlbnMgYW5kIGZpZWxkcyByZWFkeSB0byBiZSBwb3B1bGF0ZWRcbiAgICAgKiB3aXRoIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKi9cbiAgICBwcmVwYXJlU2VhcmNoKHF1ZXJ5LCBvcHRzVXNlcikge1xuICAgICAgICBjb25zdCB3ZWlnaHRzID0ge307XG4gICAgICAgIHZhciBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0c1VzZXIpO1xuICAgICAgICBwcm9wVG9BcnJheShvcHRpb25zLCAnc29ydCcpO1xuICAgICAgICBwcm9wVG9BcnJheShvcHRpb25zLCAnc29ydF9lbXB0eScpO1xuICAgICAgICAvLyBjb252ZXJ0IGZpZWxkcyB0byBuZXcgZm9ybWF0XG4gICAgICAgIGlmIChvcHRpb25zLmZpZWxkcykge1xuICAgICAgICAgICAgcHJvcFRvQXJyYXkob3B0aW9ucywgJ2ZpZWxkcycpO1xuICAgICAgICAgICAgY29uc3QgZmllbGRzID0gW107XG4gICAgICAgICAgICBvcHRpb25zLmZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmllbGQgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQgPSB7IGZpZWxkOiBmaWVsZCwgd2VpZ2h0OiAxIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICAgICAgICAgICAgICB3ZWlnaHRzW2ZpZWxkLmZpZWxkXSA9ICgnd2VpZ2h0JyBpbiBmaWVsZCkgPyBmaWVsZC53ZWlnaHQgOiAxO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvcHRpb25zLmZpZWxkcyA9IGZpZWxkcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeS50b0xvd2VyQ2FzZSgpLnRyaW0oKSxcbiAgICAgICAgICAgIHRva2VuczogdGhpcy50b2tlbml6ZShxdWVyeSwgb3B0aW9ucy5yZXNwZWN0X3dvcmRfYm91bmRhcmllcywgd2VpZ2h0cyksXG4gICAgICAgICAgICB0b3RhbDogMCxcbiAgICAgICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgICAgIHdlaWdodHM6IHdlaWdodHMsXG4gICAgICAgICAgICBnZXRBdHRyRm46IChvcHRpb25zLm5lc3RpbmcpID8gZ2V0QXR0ck5lc3RpbmcgOiBnZXRBdHRyLFxuICAgICAgICB9O1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgdGhyb3VnaCBhbGwgaXRlbXMgYW5kIHJldHVybnMgYSBzb3J0ZWQgYXJyYXkgb2YgbWF0Y2hlcy5cbiAgICAgKlxuICAgICAqL1xuICAgIHNlYXJjaChxdWVyeSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIHNjb3JlLCBzZWFyY2g7XG4gICAgICAgIHNlYXJjaCA9IHRoaXMucHJlcGFyZVNlYXJjaChxdWVyeSwgb3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMgPSBzZWFyY2gub3B0aW9ucztcbiAgICAgICAgcXVlcnkgPSBzZWFyY2gucXVlcnk7XG4gICAgICAgIC8vIGdlbmVyYXRlIHJlc3VsdCBzY29yaW5nIGZ1bmN0aW9uXG4gICAgICAgIGNvbnN0IGZuX3Njb3JlID0gb3B0aW9ucy5zY29yZSB8fCBzZWxmLl9nZXRTY29yZUZ1bmN0aW9uKHNlYXJjaCk7XG4gICAgICAgIC8vIHBlcmZvcm0gc2VhcmNoIGFuZCBzb3J0XG4gICAgICAgIGlmIChxdWVyeS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGl0ZXJhdGUoc2VsZi5pdGVtcywgKGl0ZW0sIGlkKSA9PiB7XG4gICAgICAgICAgICAgICAgc2NvcmUgPSBmbl9zY29yZShpdGVtKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5maWx0ZXIgPT09IGZhbHNlIHx8IHNjb3JlID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzZWFyY2guaXRlbXMucHVzaCh7ICdzY29yZSc6IHNjb3JlLCAnaWQnOiBpZCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGl0ZXJhdGUoc2VsZi5pdGVtcywgKF8sIGlkKSA9PiB7XG4gICAgICAgICAgICAgICAgc2VhcmNoLml0ZW1zLnB1c2goeyAnc2NvcmUnOiAxLCAnaWQnOiBpZCB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZuX3NvcnQgPSBzZWxmLl9nZXRTb3J0RnVuY3Rpb24oc2VhcmNoKTtcbiAgICAgICAgaWYgKGZuX3NvcnQpXG4gICAgICAgICAgICBzZWFyY2guaXRlbXMuc29ydChmbl9zb3J0KTtcbiAgICAgICAgLy8gYXBwbHkgbGltaXRzXG4gICAgICAgIHNlYXJjaC50b3RhbCA9IHNlYXJjaC5pdGVtcy5sZW5ndGg7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5saW1pdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHNlYXJjaC5pdGVtcyA9IHNlYXJjaC5pdGVtcy5zbGljZSgwLCBvcHRpb25zLmxpbWl0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VhcmNoO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnQgeyBTaWZ0ZXIsIHNjb3JlVmFsdWUsIGdldEF0dHIsIGdldEF0dHJOZXN0aW5nLCBwcm9wVG9BcnJheSwgaXRlcmF0ZSwgY21wLCBnZXRQYXR0ZXJuIH07XG5leHBvcnQgKiBmcm9tIFwiLi90eXBlcy5qc1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lmdGVyLmpzLm1hcCIsImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsImltcG9ydCB7IGFzY2lpZm9sZCB9IGZyb20gJ0BvcmNoaWRqcy91bmljb2RlLXZhcmlhbnRzJztcbi8qKlxuICogQSBwcm9wZXJ0eSBnZXR0ZXIgcmVzb2x2aW5nIGRvdC1ub3RhdGlvblxuICogQHBhcmFtICB7T2JqZWN0fSAgb2JqICAgICBUaGUgcm9vdCBvYmplY3QgdG8gZmV0Y2ggcHJvcGVydHkgb25cbiAqIEBwYXJhbSAge1N0cmluZ30gIG5hbWUgICAgVGhlIG9wdGlvbmFsbHkgZG90dGVkIHByb3BlcnR5IG5hbWUgdG8gZmV0Y2hcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgVGhlIHJlc29sdmVkIHByb3BlcnR5IHZhbHVlXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRBdHRyID0gKG9iaiwgbmFtZSkgPT4ge1xuICAgIGlmICghb2JqKVxuICAgICAgICByZXR1cm47XG4gICAgcmV0dXJuIG9ialtuYW1lXTtcbn07XG4vKipcbiAqIEEgcHJvcGVydHkgZ2V0dGVyIHJlc29sdmluZyBkb3Qtbm90YXRpb25cbiAqIEBwYXJhbSAge09iamVjdH0gIG9iaiAgICAgVGhlIHJvb3Qgb2JqZWN0IHRvIGZldGNoIHByb3BlcnR5IG9uXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICBuYW1lICAgIFRoZSBvcHRpb25hbGx5IGRvdHRlZCBwcm9wZXJ0eSBuYW1lIHRvIGZldGNoXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgIFRoZSByZXNvbHZlZCBwcm9wZXJ0eSB2YWx1ZVxuICovXG5leHBvcnQgY29uc3QgZ2V0QXR0ck5lc3RpbmcgPSAob2JqLCBuYW1lKSA9PiB7XG4gICAgaWYgKCFvYmopXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgcGFydCwgbmFtZXMgPSBuYW1lLnNwbGl0KFwiLlwiKTtcbiAgICB3aGlsZSAoKHBhcnQgPSBuYW1lcy5zaGlmdCgpKSAmJiAob2JqID0gb2JqW3BhcnRdKSlcbiAgICAgICAgO1xuICAgIHJldHVybiBvYmo7XG59O1xuLyoqXG4gKiBDYWxjdWxhdGVzIGhvdyBjbG9zZSBvZiBhIG1hdGNoIHRoZVxuICogZ2l2ZW4gdmFsdWUgaXMgYWdhaW5zdCBhIHNlYXJjaCB0b2tlbi5cbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBzY29yZVZhbHVlID0gKHZhbHVlLCB0b2tlbiwgd2VpZ2h0KSA9PiB7XG4gICAgdmFyIHNjb3JlLCBwb3M7XG4gICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgdmFsdWUgPSB2YWx1ZSArICcnO1xuICAgIGlmICh0b2tlbi5yZWdleCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gMDtcbiAgICBwb3MgPSB2YWx1ZS5zZWFyY2godG9rZW4ucmVnZXgpO1xuICAgIGlmIChwb3MgPT09IC0xKVxuICAgICAgICByZXR1cm4gMDtcbiAgICBzY29yZSA9IHRva2VuLnN0cmluZy5sZW5ndGggLyB2YWx1ZS5sZW5ndGg7XG4gICAgaWYgKHBvcyA9PT0gMClcbiAgICAgICAgc2NvcmUgKz0gMC41O1xuICAgIHJldHVybiBzY29yZSAqIHdlaWdodDtcbn07XG4vKipcbiAqIENhc3Qgb2JqZWN0IHByb3BlcnR5IHRvIGFuIGFycmF5IGlmIGl0IGV4aXN0cyBhbmQgaGFzIGEgdmFsdWVcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBwcm9wVG9BcnJheSA9IChvYmosIGtleSkgPT4ge1xuICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGlmICh2YWx1ZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgb2JqW2tleV0gPSBbdmFsdWVdO1xuICAgIH1cbn07XG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgYXJyYXlzIGFuZCBoYXNoZXMuXG4gKlxuICogYGBgXG4gKiBpdGVyYXRlKHRoaXMuaXRlbXMsIGZ1bmN0aW9uKGl0ZW0sIGlkKSB7XG4gKiAgICAvLyBpbnZva2VkIGZvciBlYWNoIGl0ZW1cbiAqIH0pO1xuICogYGBgXG4gKlxuICovXG5leHBvcnQgY29uc3QgaXRlcmF0ZSA9IChvYmplY3QsIGNhbGxiYWNrKSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICBvYmplY3QuZm9yRWFjaChjYWxsYmFjayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhvYmplY3Rba2V5XSwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgY21wID0gKGEsIGIpID0+IHtcbiAgICBpZiAodHlwZW9mIGEgPT09ICdudW1iZXInICYmIHR5cGVvZiBiID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gYSA+IGIgPyAxIDogKGEgPCBiID8gLTEgOiAwKTtcbiAgICB9XG4gICAgYSA9IGFzY2lpZm9sZChhICsgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgYiA9IGFzY2lpZm9sZChiICsgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGEgPiBiKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAoYiA+IGEpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICByZXR1cm4gMDtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJpbXBvcnQgeyBzZXRUb1BhdHRlcm4sIGFycmF5VG9QYXR0ZXJuLCBlc2NhcGVfcmVnZXgsIHNlcXVlbmNlUGF0dGVybiB9IGZyb20gXCIuL3JlZ2V4LmpzXCI7XG5pbXBvcnQgeyBhbGxTdWJzdHJpbmdzIH0gZnJvbSBcIi4vc3RyaW5ncy5qc1wiO1xuZXhwb3J0IGNvbnN0IGNvZGVfcG9pbnRzID0gW1swLCA2NTUzNV1dO1xuY29uc3QgYWNjZW50X3BhdCA9ICdbXFx1MDMwMC1cXHUwMzZGXFx1e2I3fVxcdXsyYmV9XFx1ezJiY31dJztcbmV4cG9ydCBsZXQgdW5pY29kZV9tYXA7XG5sZXQgbXVsdGlfY2hhcl9yZWc7XG5jb25zdCBtYXhfY2hhcl9sZW5ndGggPSAzO1xuY29uc3QgbGF0aW5fY29udmVydCA9IHt9O1xuY29uc3QgbGF0aW5fY29uZGVuc2VkID0ge1xuICAgICcvJzogJ+KBhOKIlScsXG4gICAgJzAnOiAn34AnLFxuICAgIFwiYVwiOiBcIuKxpcmQyZFcIixcbiAgICBcImFhXCI6IFwi6pyzXCIsXG4gICAgXCJhZVwiOiBcIsOmx73Ho1wiLFxuICAgIFwiYW9cIjogXCLqnLVcIixcbiAgICBcImF1XCI6IFwi6py3XCIsXG4gICAgXCJhdlwiOiBcIuqcueqcu1wiLFxuICAgIFwiYXlcIjogXCLqnL1cIixcbiAgICBcImJcIjogXCLGgMmTxoNcIixcbiAgICBcImNcIjogXCLqnL/GiMi84oaEXCIsXG4gICAgXCJkXCI6IFwixJHJl8mW4bSFxozqrrfUgcmmXCIsXG4gICAgXCJlXCI6IFwiyZvHneG0h8mHXCIsXG4gICAgXCJmXCI6IFwi6p28xpJcIixcbiAgICBcImdcIjogXCLHpcmg6p6h4bW56p2/yaJcIixcbiAgICBcImhcIjogXCLEp+KxqOKxtsmlXCIsXG4gICAgXCJpXCI6IFwiyajEsVwiLFxuICAgIFwialwiOiBcIsmJyLdcIixcbiAgICBcImtcIjogXCLGmeKxquqdgeqdg+qdheqeo1wiLFxuICAgIFwibFwiOiBcIsWCxprJq+Kxoeqdieqdh+qegcmtXCIsXG4gICAgXCJtXCI6IFwiybHJr8+7XCIsXG4gICAgXCJuXCI6IFwi6p6lxp7JsuqekeG0jtC71IlcIixcbiAgICBcIm9cIjogXCLDuMe/yZTJteqdi+qdjeG0kVwiLFxuICAgIFwib2VcIjogXCLFk1wiLFxuICAgIFwib2lcIjogXCLGo1wiLFxuICAgIFwib29cIjogXCLqnY9cIixcbiAgICBcIm91XCI6IFwiyKNcIixcbiAgICBcInBcIjogXCLGpeG1veqdkeqdk+qdlc+BXCIsXG4gICAgXCJxXCI6IFwi6p2X6p2ZyYtcIixcbiAgICBcInJcIjogXCLJjcm96p2b6p6n6p6DXCIsXG4gICAgXCJzXCI6IFwiw5/Iv+qeqeqehcqCXCIsXG4gICAgXCJ0XCI6IFwixafGrcqI4rGm6p6HXCIsXG4gICAgXCJ0aFwiOiBcIsO+XCIsXG4gICAgXCJ0elwiOiBcIuqcqVwiLFxuICAgIFwidVwiOiBcIsqJXCIsXG4gICAgXCJ2XCI6IFwiyovqnZ/KjFwiLFxuICAgIFwidnlcIjogXCLqnaFcIixcbiAgICBcIndcIjogXCLisbNcIixcbiAgICBcInlcIjogXCLGtMmP4bu/XCIsXG4gICAgXCJ6XCI6IFwixrbIpcmA4rGs6p2jXCIsXG4gICAgXCJodlwiOiBcIsaVXCJcbn07XG5mb3IgKGxldCBsYXRpbiBpbiBsYXRpbl9jb25kZW5zZWQpIHtcbiAgICBsZXQgdW5pY29kZSA9IGxhdGluX2NvbmRlbnNlZFtsYXRpbl0gfHwgJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1bmljb2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjaGFyID0gdW5pY29kZS5zdWJzdHJpbmcoaSwgaSArIDEpO1xuICAgICAgICBsYXRpbl9jb252ZXJ0W2NoYXJdID0gbGF0aW47XG4gICAgfVxufVxuY29uc3QgY29udmVydF9wYXQgPSBuZXcgUmVnRXhwKE9iamVjdC5rZXlzKGxhdGluX2NvbnZlcnQpLmpvaW4oJ3wnKSArICd8JyArIGFjY2VudF9wYXQsICdndScpO1xuLyoqXG4gKiBJbml0aWFsaXplIHRoZSB1bmljb2RlX21hcCBmcm9tIHRoZSBnaXZlIGNvZGUgcG9pbnQgcmFuZ2VzXG4gKi9cbmV4cG9ydCBjb25zdCBpbml0aWFsaXplID0gKF9jb2RlX3BvaW50cykgPT4ge1xuICAgIGlmICh1bmljb2RlX21hcCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgdW5pY29kZV9tYXAgPSBnZW5lcmF0ZU1hcChfY29kZV9wb2ludHMgfHwgY29kZV9wb2ludHMpO1xufTtcbi8qKlxuICogSGVscGVyIG1ldGhvZCBmb3Igbm9ybWFsaXplIGEgc3RyaW5nXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvbm9ybWFsaXplXG4gKi9cbmV4cG9ydCBjb25zdCBub3JtYWxpemUgPSAoc3RyLCBmb3JtID0gJ05GS0QnKSA9PiBzdHIubm9ybWFsaXplKGZvcm0pO1xuLyoqXG4gKiBSZW1vdmUgYWNjZW50cyB3aXRob3V0IHJlb3JkZXJpbmcgc3RyaW5nXG4gKiBjYWxsaW5nIHN0ci5ub3JtYWxpemUoJ05GS0QnKSBvbiBcXHV7NTk0fVxcdXs1OTV9XFx1ezU5Nn0gYmVjb21lcyBcXHV7NTk2fVxcdXs1OTR9XFx1ezU5NX1cbiAqIHZpYSBodHRwczovL2dpdGh1Yi5jb20va3Jpc2svRnVzZS9pc3N1ZXMvMTMzI2lzc3VlY29tbWVudC0zMTg2OTI3MDNcbiAqL1xuZXhwb3J0IGNvbnN0IGFzY2lpZm9sZCA9IChzdHIpID0+IHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShzdHIpLnJlZHVjZShcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVzdWx0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJcbiAgICAgKi9cbiAgICAocmVzdWx0LCBjaGFyKSA9PiB7XG4gICAgICAgIHJldHVybiByZXN1bHQgKyBfYXNjaWlmb2xkKGNoYXIpO1xuICAgIH0sICcnKTtcbn07XG5leHBvcnQgY29uc3QgX2FzY2lpZm9sZCA9IChzdHIpID0+IHtcbiAgICBzdHIgPSBub3JtYWxpemUoc3RyKVxuICAgICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgICAucmVwbGFjZShjb252ZXJ0X3BhdCwgKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyBjaGFyKSA9PiB7XG4gICAgICAgIHJldHVybiBsYXRpbl9jb252ZXJ0W2NoYXJdIHx8ICcnO1xuICAgIH0pO1xuICAgIC8vcmV0dXJuIHN0cjtcbiAgICByZXR1cm4gbm9ybWFsaXplKHN0ciwgJ05GQycpO1xufTtcbi8qKlxuICogR2VuZXJhdGUgYSBsaXN0IG9mIHVuaWNvZGUgdmFyaWFudHMgZnJvbSB0aGUgbGlzdCBvZiBjb2RlIHBvaW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24qIGdlbmVyYXRvcihjb2RlX3BvaW50cykge1xuICAgIGZvciAoY29uc3QgW2NvZGVfcG9pbnRfbWluLCBjb2RlX3BvaW50X21heF0gb2YgY29kZV9wb2ludHMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGNvZGVfcG9pbnRfbWluOyBpIDw9IGNvZGVfcG9pbnRfbWF4OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjb21wb3NlZCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XG4gICAgICAgICAgICBsZXQgZm9sZGVkID0gYXNjaWlmb2xkKGNvbXBvc2VkKTtcbiAgICAgICAgICAgIGlmIChmb2xkZWQgPT0gY29tcG9zZWQudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2tpcCB3aGVuIGZvbGRlZCBpcyBhIHN0cmluZyBsb25nZXIgdGhhbiAzIGNoYXJhY3RlcnMgbG9uZ1xuICAgICAgICAgICAgLy8gYmMgdGhlIHJlc3VsdGluZyByZWdleCBwYXR0ZXJucyB3aWxsIGJlIGxvbmdcbiAgICAgICAgICAgIC8vIGVnOlxuICAgICAgICAgICAgLy8gZm9sZGVkINi12YTZiSDYp9mE2YTZhyDYudmE2YrZhyDZiNiz2YTZhSBsZW5ndGggMTggY29kZSBwb2ludCA2NTAxOFxuICAgICAgICAgICAgLy8gZm9sZGVkINis2YQg2KzZhNin2YTZhyBsZW5ndGggOCBjb2RlIHBvaW50IDY1MDE5XG4gICAgICAgICAgICBpZiAoZm9sZGVkLmxlbmd0aCA+IG1heF9jaGFyX2xlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvbGRlZC5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgeyBmb2xkZWQ6IGZvbGRlZCwgY29tcG9zZWQ6IGNvbXBvc2VkLCBjb2RlX3BvaW50OiBpIH07XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEdlbmVyYXRlIGEgdW5pY29kZSBtYXAgZnJvbSB0aGUgbGlzdCBvZiBjb2RlIHBvaW50c1xuICovXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVTZXRzID0gKGNvZGVfcG9pbnRzKSA9PiB7XG4gICAgY29uc3QgdW5pY29kZV9zZXRzID0ge307XG4gICAgY29uc3QgYWRkTWF0Y2hpbmcgPSAoZm9sZGVkLCB0b19hZGQpID0+IHtcbiAgICAgICAgLyoqIEB0eXBlIHtTZXQ8c3RyaW5nPn0gKi9cbiAgICAgICAgY29uc3QgZm9sZGVkX3NldCA9IHVuaWNvZGVfc2V0c1tmb2xkZWRdIHx8IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgcGF0dCA9IG5ldyBSZWdFeHAoJ14nICsgc2V0VG9QYXR0ZXJuKGZvbGRlZF9zZXQpICsgJyQnLCAnaXUnKTtcbiAgICAgICAgaWYgKHRvX2FkZC5tYXRjaChwYXR0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvbGRlZF9zZXQuYWRkKGVzY2FwZV9yZWdleCh0b19hZGQpKTtcbiAgICAgICAgdW5pY29kZV9zZXRzW2ZvbGRlZF0gPSBmb2xkZWRfc2V0O1xuICAgIH07XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgZ2VuZXJhdG9yKGNvZGVfcG9pbnRzKSkge1xuICAgICAgICBhZGRNYXRjaGluZyh2YWx1ZS5mb2xkZWQsIHZhbHVlLmZvbGRlZCk7XG4gICAgICAgIGFkZE1hdGNoaW5nKHZhbHVlLmZvbGRlZCwgdmFsdWUuY29tcG9zZWQpO1xuICAgIH1cbiAgICByZXR1cm4gdW5pY29kZV9zZXRzO1xufTtcbi8qKlxuICogR2VuZXJhdGUgYSB1bmljb2RlIG1hcCBmcm9tIHRoZSBsaXN0IG9mIGNvZGUgcG9pbnRzXG4gKiBhZSA9PiAoPzooPzphZXzDhnzHvHzHoil8KD86QXzikrZ877yhLi4uKSg/OkV8yZt84pK6Li4uKSlcbiAqL1xuZXhwb3J0IGNvbnN0IGdlbmVyYXRlTWFwID0gKGNvZGVfcG9pbnRzKSA9PiB7XG4gICAgY29uc3QgdW5pY29kZV9zZXRzID0gZ2VuZXJhdGVTZXRzKGNvZGVfcG9pbnRzKTtcbiAgICBjb25zdCB1bmljb2RlX21hcCA9IHt9O1xuICAgIGxldCBtdWx0aV9jaGFyID0gW107XG4gICAgZm9yIChsZXQgZm9sZGVkIGluIHVuaWNvZGVfc2V0cykge1xuICAgICAgICBsZXQgc2V0ID0gdW5pY29kZV9zZXRzW2ZvbGRlZF07XG4gICAgICAgIGlmIChzZXQpIHtcbiAgICAgICAgICAgIHVuaWNvZGVfbWFwW2ZvbGRlZF0gPSBzZXRUb1BhdHRlcm4oc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9sZGVkLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIG11bHRpX2NoYXIucHVzaChlc2NhcGVfcmVnZXgoZm9sZGVkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbXVsdGlfY2hhci5zb3J0KChhLCBiKSA9PiBiLmxlbmd0aCAtIGEubGVuZ3RoKTtcbiAgICBjb25zdCBtdWx0aV9jaGFyX3BhdHQgPSBhcnJheVRvUGF0dGVybihtdWx0aV9jaGFyKTtcbiAgICBtdWx0aV9jaGFyX3JlZyA9IG5ldyBSZWdFeHAoJ14nICsgbXVsdGlfY2hhcl9wYXR0LCAndScpO1xuICAgIHJldHVybiB1bmljb2RlX21hcDtcbn07XG4vKipcbiAqIE1hcCBlYWNoIGVsZW1lbnQgb2YgYW4gYXJyYXkgZnJvbSBpdHMgZm9sZGVkIHZhbHVlIHRvIGFsbCBwb3NzaWJsZSB1bmljb2RlIG1hdGNoZXNcbiAqL1xuZXhwb3J0IGNvbnN0IG1hcFNlcXVlbmNlID0gKHN0cmluZ3MsIG1pbl9yZXBsYWNlbWVudCA9IDEpID0+IHtcbiAgICBsZXQgY2hhcnNfcmVwbGFjZWQgPSAwO1xuICAgIHN0cmluZ3MgPSBzdHJpbmdzLm1hcCgoc3RyKSA9PiB7XG4gICAgICAgIGlmICh1bmljb2RlX21hcFtzdHJdKSB7XG4gICAgICAgICAgICBjaGFyc19yZXBsYWNlZCArPSBzdHIubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmljb2RlX21hcFtzdHJdIHx8IHN0cjtcbiAgICB9KTtcbiAgICBpZiAoY2hhcnNfcmVwbGFjZWQgPj0gbWluX3JlcGxhY2VtZW50KSB7XG4gICAgICAgIHJldHVybiBzZXF1ZW5jZVBhdHRlcm4oc3RyaW5ncyk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn07XG4vKipcbiAqIENvbnZlcnQgYSBzaG9ydCBzdHJpbmcgYW5kIHNwbGl0IGl0IGludG8gYWxsIHBvc3NpYmxlIHBhdHRlcm5zXG4gKiBLZWVwIGEgcGF0dGVybiBvbmx5IGlmIG1pbl9yZXBsYWNlbWVudCBpcyBtZXRcbiAqXG4gKiAnYWJjJ1xuICogXHRcdD0+IFtbJ2FiYyddLFsnYWInLCdjJ10sWydhJywnYmMnXSxbJ2EnLCdiJywnYyddXVxuICpcdFx0PT4gWydhYmMtcGF0dGVybicsJ2FiLWMtcGF0dGVybicuLi5dXG4gKi9cbmV4cG9ydCBjb25zdCBzdWJzdHJpbmdzVG9QYXR0ZXJuID0gKHN0ciwgbWluX3JlcGxhY2VtZW50ID0gMSkgPT4ge1xuICAgIG1pbl9yZXBsYWNlbWVudCA9IE1hdGgubWF4KG1pbl9yZXBsYWNlbWVudCwgc3RyLmxlbmd0aCAtIDEpO1xuICAgIHJldHVybiBhcnJheVRvUGF0dGVybihhbGxTdWJzdHJpbmdzKHN0cikubWFwKChzdWJfcGF0KSA9PiB7XG4gICAgICAgIHJldHVybiBtYXBTZXF1ZW5jZShzdWJfcGF0LCBtaW5fcmVwbGFjZW1lbnQpO1xuICAgIH0pKTtcbn07XG4vKipcbiAqIENvbnZlcnQgYW4gYXJyYXkgb2Ygc2VxdWVuY2VzIGludG8gYSBwYXR0ZXJuXG4gKiBbe3N0YXJ0OjAsZW5kOjMsbGVuZ3RoOjMsc3Vic3RyOidpaWknfS4uLl0gPT4gKD86aWlpLi4uKVxuICovXG5jb25zdCBzZXF1ZW5jZXNUb1BhdHRlcm4gPSAoc2VxdWVuY2VzLCBhbGwgPSB0cnVlKSA9PiB7XG4gICAgbGV0IG1pbl9yZXBsYWNlbWVudCA9IHNlcXVlbmNlcy5sZW5ndGggPiAxID8gMSA6IDA7XG4gICAgcmV0dXJuIGFycmF5VG9QYXR0ZXJuKHNlcXVlbmNlcy5tYXAoKHNlcXVlbmNlKSA9PiB7XG4gICAgICAgIGxldCBzZXEgPSBbXTtcbiAgICAgICAgY29uc3QgbGVuID0gYWxsID8gc2VxdWVuY2UubGVuZ3RoKCkgOiBzZXF1ZW5jZS5sZW5ndGgoKSAtIDE7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIHNlcS5wdXNoKHN1YnN0cmluZ3NUb1BhdHRlcm4oc2VxdWVuY2Uuc3Vic3Ryc1tqXSB8fCAnJywgbWluX3JlcGxhY2VtZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlcXVlbmNlUGF0dGVybihzZXEpO1xuICAgIH0pKTtcbn07XG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHRoZSBzZXF1ZW5jZSBpcyBhbHJlYWR5IGluIHRoZSBzZXF1ZW5jZXNcbiAqL1xuY29uc3QgaW5TZXF1ZW5jZXMgPSAobmVlZGxlX3NlcSwgc2VxdWVuY2VzKSA9PiB7XG4gICAgZm9yIChjb25zdCBzZXEgb2Ygc2VxdWVuY2VzKSB7XG4gICAgICAgIGlmIChzZXEuc3RhcnQgIT0gbmVlZGxlX3NlcS5zdGFydCB8fCBzZXEuZW5kICE9IG5lZWRsZV9zZXEuZW5kKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VxLnN1YnN0cnMuam9pbignJykgIT09IG5lZWRsZV9zZXEuc3Vic3Rycy5qb2luKCcnKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5lZWRsZV9wYXJ0cyA9IG5lZWRsZV9zZXEucGFydHM7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IChwYXJ0KSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5lZWRsZV9wYXJ0IG9mIG5lZWRsZV9wYXJ0cykge1xuICAgICAgICAgICAgICAgIGlmIChuZWVkbGVfcGFydC5zdGFydCA9PT0gcGFydC5zdGFydCAmJiBuZWVkbGVfcGFydC5zdWJzdHIgPT09IHBhcnQuc3Vic3RyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQubGVuZ3RoID09IDEgfHwgbmVlZGxlX3BhcnQubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBvdmVybGFwcGluZyBwYXJ0c1xuICAgICAgICAgICAgICAgIC8vIGEgPSBbJzo6PScsJz09J11cbiAgICAgICAgICAgICAgICAvLyBiID0gWyc6OicsJz09PSddXG4gICAgICAgICAgICAgICAgLy8gYSA9IFsncicsJ3NtJ11cbiAgICAgICAgICAgICAgICAvLyBiID0gWydycycsJ20nXVxuICAgICAgICAgICAgICAgIGlmIChwYXJ0LnN0YXJ0IDwgbmVlZGxlX3BhcnQuc3RhcnQgJiYgcGFydC5lbmQgPiBuZWVkbGVfcGFydC5zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5lZWRsZV9wYXJ0LnN0YXJ0IDwgcGFydC5zdGFydCAmJiBuZWVkbGVfcGFydC5lbmQgPiBwYXJ0LnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGZpbHRlcmVkID0gc2VxLnBhcnRzLmZpbHRlcihmaWx0ZXIpO1xuICAgICAgICBpZiAoZmlsdGVyZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5jbGFzcyBTZXF1ZW5jZSB7XG4gICAgcGFydHM7XG4gICAgc3Vic3RycztcbiAgICBzdGFydDtcbiAgICBlbmQ7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucGFydHMgPSBbXTtcbiAgICAgICAgdGhpcy5zdWJzdHJzID0gW107XG4gICAgICAgIHRoaXMuc3RhcnQgPSAwO1xuICAgICAgICB0aGlzLmVuZCA9IDA7XG4gICAgfVxuICAgIGFkZChwYXJ0KSB7XG4gICAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgICAgICB0aGlzLnBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgICAgICB0aGlzLnN1YnN0cnMucHVzaChwYXJ0LnN1YnN0cik7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gTWF0aC5taW4ocGFydC5zdGFydCwgdGhpcy5zdGFydCk7XG4gICAgICAgICAgICB0aGlzLmVuZCA9IE1hdGgubWF4KHBhcnQuZW5kLCB0aGlzLmVuZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGFzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFydHNbdGhpcy5wYXJ0cy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJ0cy5sZW5ndGg7XG4gICAgfVxuICAgIGNsb25lKHBvc2l0aW9uLCBsYXN0X3BpZWNlKSB7XG4gICAgICAgIGxldCBjbG9uZSA9IG5ldyBTZXF1ZW5jZSgpO1xuICAgICAgICBsZXQgcGFydHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMucGFydHMpKTtcbiAgICAgICAgbGV0IGxhc3RfcGFydCA9IHBhcnRzLnBvcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgICAgICAgIGNsb25lLmFkZChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGFzdF9zdWJzdHIgPSBsYXN0X3BpZWNlLnN1YnN0ci5zdWJzdHJpbmcoMCwgcG9zaXRpb24gLSBsYXN0X3BhcnQuc3RhcnQpO1xuICAgICAgICBsZXQgY2xvbmVfbGFzdF9sZW4gPSBsYXN0X3N1YnN0ci5sZW5ndGg7XG4gICAgICAgIGNsb25lLmFkZCh7IHN0YXJ0OiBsYXN0X3BhcnQuc3RhcnQsIGVuZDogbGFzdF9wYXJ0LnN0YXJ0ICsgY2xvbmVfbGFzdF9sZW4sIGxlbmd0aDogY2xvbmVfbGFzdF9sZW4sIHN1YnN0cjogbGFzdF9zdWJzdHIgfSk7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG59XG4vKipcbiAqIEV4cGFuZCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXR0ZXJuIHRvIGluY2x1ZGUgdW5pY29kZSB2YXJpYW50c1xuICogXHRlZyAvYS8gYmVjb21lcyAvYeKTkO+9geG6msOgw6HDouG6p+G6peG6q+G6qcOjxIHEg+G6seG6r+G6teG6s8inx6HDpMef4bqjw6XHu8eOyIHIg+G6oeG6reG6t+G4gcSF4rGlyZDJkUHikrbvvKHDgMOBw4LhuqbhuqThuqrhuqjDg8SAxILhurDhuq7hurThurLIpsegw4THnuG6osOFx7rHjciAyILhuqDhuqzhurbhuIDEhMi64rGvL1xuICpcbiAqIElzc3VlOlxuICogIO+6iu+6iyBbICfvuoogPSBcXFxcdXtmZThhfScsICfvuosgPSBcXFxcdXtmZThifScgXVxuICpcdGJlY29tZXM6XHTZitmU2YrZlCBbICfZiiA9IFxcXFx1ezY0YX0nLCAn2ZQgPSBcXFxcdXs2NTR9JywgJ9mKID0gXFxcXHV7NjRhfScsICfZlCA9IFxcXFx1ezY1NH0nIF1cbiAqXG4gKlx0xLDEsiA9IElJSiA9IOKFoUpcbiAqXG4gKiBcdDEvMi80XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRQYXR0ZXJuID0gKHN0cikgPT4ge1xuICAgIGluaXRpYWxpemUoKTtcbiAgICBzdHIgPSBhc2NpaWZvbGQoc3RyKTtcbiAgICBsZXQgcGF0dGVybiA9ICcnO1xuICAgIGxldCBzZXF1ZW5jZXMgPSBbbmV3IFNlcXVlbmNlKCldO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBzdWJzdHIgPSBzdHIuc3Vic3RyaW5nKGkpO1xuICAgICAgICBsZXQgbWF0Y2ggPSBzdWJzdHIubWF0Y2gobXVsdGlfY2hhcl9yZWcpO1xuICAgICAgICBjb25zdCBjaGFyID0gc3RyLnN1YnN0cmluZyhpLCBpICsgMSk7XG4gICAgICAgIGNvbnN0IG1hdGNoX3N0ciA9IG1hdGNoID8gbWF0Y2hbMF0gOiBudWxsO1xuICAgICAgICAvLyBsb29wIHRocm91Z2ggc2VxdWVuY2VzXG4gICAgICAgIC8vIGFkZCBlaXRoZXIgdGhlIGNoYXIgb3IgbXVsdGlfbWF0Y2hcbiAgICAgICAgbGV0IG92ZXJsYXBwaW5nID0gW107XG4gICAgICAgIGxldCBhZGRlZF90eXBlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgZm9yIChjb25zdCBzZXF1ZW5jZSBvZiBzZXF1ZW5jZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RfcGllY2UgPSBzZXF1ZW5jZS5sYXN0KCk7XG4gICAgICAgICAgICBpZiAoIWxhc3RfcGllY2UgfHwgbGFzdF9waWVjZS5sZW5ndGggPT0gMSB8fCBsYXN0X3BpZWNlLmVuZCA8PSBpKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIG11bHRpIG1hdGNoXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoX3N0cikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW4gPSBtYXRjaF9zdHIubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBzZXF1ZW5jZS5hZGQoeyBzdGFydDogaSwgZW5kOiBpICsgbGVuLCBsZW5ndGg6IGxlbiwgc3Vic3RyOiBtYXRjaF9zdHIgfSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZGVkX3R5cGVzLmFkZCgnMScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VxdWVuY2UuYWRkKHsgc3RhcnQ6IGksIGVuZDogaSArIDEsIGxlbmd0aDogMSwgc3Vic3RyOiBjaGFyIH0pO1xuICAgICAgICAgICAgICAgICAgICBhZGRlZF90eXBlcy5hZGQoJzInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXRjaF9zdHIpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2xvbmUgPSBzZXF1ZW5jZS5jbG9uZShpLCBsYXN0X3BpZWNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW4gPSBtYXRjaF9zdHIubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNsb25lLmFkZCh7IHN0YXJ0OiBpLCBlbmQ6IGkgKyBsZW4sIGxlbmd0aDogbGVuLCBzdWJzdHI6IG1hdGNoX3N0ciB9KTtcbiAgICAgICAgICAgICAgICBvdmVybGFwcGluZy5wdXNoKGNsb25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IGFkZCBjaGFyXG4gICAgICAgICAgICAgICAgLy8gYWRkaW5nIHdvdWxkIGNyZWF0ZSBpbnZhbGlkIHBhdHRlcm5zOiAyMzQgPT4gWzIsMzQsNF1cbiAgICAgICAgICAgICAgICBhZGRlZF90eXBlcy5hZGQoJzMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3ZSBoYXZlIG92ZXJsYXBwaW5nXG4gICAgICAgIGlmIChvdmVybGFwcGluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBbJ2lpJywnaWlpJ10gYmVmb3JlIFsnaScsJ2knLCdpaWknXVxuICAgICAgICAgICAgb3ZlcmxhcHBpbmcgPSBvdmVybGFwcGluZy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEubGVuZ3RoKCkgLSBiLmxlbmd0aCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKGxldCBjbG9uZSBvZiBvdmVybGFwcGluZykge1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IGFkZCBpZiB3ZSBhbHJlYWR5IGhhdmUgYW4gZXF1aXZhbGVudCBzZXF1ZW5jZVxuICAgICAgICAgICAgICAgIGlmIChpblNlcXVlbmNlcyhjbG9uZSwgc2VxdWVuY2VzKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VxdWVuY2VzLnB1c2goY2xvbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgaGF2ZW4ndCBkb25lIGFueXRoaW5nIHVuaXF1ZVxuICAgICAgICAvLyBjbGVhbiB1cCB0aGUgcGF0dGVybnNcbiAgICAgICAgLy8gaGVscHMga2VlcCBwYXR0ZXJucyBzbWFsbGVyXG4gICAgICAgIC8vIGlmIHN0ciA9ICdy4oKo446nYWFyc3MnLCBwYXR0ZXJuIHdpbGwgYmUgNDQ2IGluc3RlYWQgb2YgNjU1XG4gICAgICAgIGlmIChpID4gMCAmJiBhZGRlZF90eXBlcy5zaXplID09IDEgJiYgIWFkZGVkX3R5cGVzLmhhcygnMycpKSB7XG4gICAgICAgICAgICBwYXR0ZXJuICs9IHNlcXVlbmNlc1RvUGF0dGVybihzZXF1ZW5jZXMsIGZhbHNlKTtcbiAgICAgICAgICAgIGxldCBuZXdfc2VxID0gbmV3IFNlcXVlbmNlKCk7XG4gICAgICAgICAgICBjb25zdCBvbGRfc2VxID0gc2VxdWVuY2VzWzBdO1xuICAgICAgICAgICAgaWYgKG9sZF9zZXEpIHtcbiAgICAgICAgICAgICAgICBuZXdfc2VxLmFkZChvbGRfc2VxLmxhc3QoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXF1ZW5jZXMgPSBbbmV3X3NlcV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGF0dGVybiArPSBzZXF1ZW5jZXNUb1BhdHRlcm4oc2VxdWVuY2VzLCB0cnVlKTtcbiAgICByZXR1cm4gcGF0dGVybjtcbn07XG5leHBvcnQgeyBlc2NhcGVfcmVnZXggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8qKlxuICogQ29udmVydCBhcnJheSBvZiBzdHJpbmdzIHRvIGEgcmVndWxhciBleHByZXNzaW9uXG4gKlx0ZXggWydhYicsJ2EnXSA9PiAoPzphYnxhKVxuICogXHRleCBbJ2EnLCdiJ10gPT4gW2FiXVxuICovXG5leHBvcnQgY29uc3QgYXJyYXlUb1BhdHRlcm4gPSAoY2hhcnMpID0+IHtcbiAgICBjaGFycyA9IGNoYXJzLmZpbHRlcihCb29sZWFuKTtcbiAgICBpZiAoY2hhcnMubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gY2hhcnNbMF0gfHwgJyc7XG4gICAgfVxuICAgIHJldHVybiAobWF4VmFsdWVMZW5ndGgoY2hhcnMpID09IDEpID8gJ1snICsgY2hhcnMuam9pbignJykgKyAnXScgOiAnKD86JyArIGNoYXJzLmpvaW4oJ3wnKSArICcpJztcbn07XG5leHBvcnQgY29uc3Qgc2VxdWVuY2VQYXR0ZXJuID0gKGFycmF5KSA9PiB7XG4gICAgaWYgKCFoYXNEdXBsaWNhdGVzKGFycmF5KSkge1xuICAgICAgICByZXR1cm4gYXJyYXkuam9pbignJyk7XG4gICAgfVxuICAgIGxldCBwYXR0ZXJuID0gJyc7XG4gICAgbGV0IHByZXZfY2hhcl9jb3VudCA9IDA7XG4gICAgY29uc3QgcHJldl9wYXR0ZXJuID0gKCkgPT4ge1xuICAgICAgICBpZiAocHJldl9jaGFyX2NvdW50ID4gMSkge1xuICAgICAgICAgICAgcGF0dGVybiArPSAneycgKyBwcmV2X2NoYXJfY291bnQgKyAnfSc7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGFycmF5LmZvckVhY2goKGNoYXIsIGkpID0+IHtcbiAgICAgICAgaWYgKGNoYXIgPT09IGFycmF5W2kgLSAxXSkge1xuICAgICAgICAgICAgcHJldl9jaGFyX2NvdW50Kys7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcHJldl9wYXR0ZXJuKCk7XG4gICAgICAgIHBhdHRlcm4gKz0gY2hhcjtcbiAgICAgICAgcHJldl9jaGFyX2NvdW50ID0gMTtcbiAgICB9KTtcbiAgICBwcmV2X3BhdHRlcm4oKTtcbiAgICByZXR1cm4gcGF0dGVybjtcbn07XG4vKipcbiAqIENvbnZlcnQgYXJyYXkgb2Ygc3RyaW5ncyB0byBhIHJlZ3VsYXIgZXhwcmVzc2lvblxuICpcdGV4IFsnYWInLCdhJ10gPT4gKD86YWJ8YSlcbiAqIFx0ZXggWydhJywnYiddID0+IFthYl1cbiAqL1xuZXhwb3J0IGNvbnN0IHNldFRvUGF0dGVybiA9IChjaGFycykgPT4ge1xuICAgIGxldCBhcnJheSA9IEFycmF5LmZyb20oY2hhcnMpO1xuICAgIHJldHVybiBhcnJheVRvUGF0dGVybihhcnJheSk7XG59O1xuLyoqXG4gKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83Mzc2NTk4L2luLWphdmFzY3JpcHQtaG93LWRvLWktY2hlY2staWYtYW4tYXJyYXktaGFzLWR1cGxpY2F0ZS12YWx1ZXNcbiAqL1xuZXhwb3J0IGNvbnN0IGhhc0R1cGxpY2F0ZXMgPSAoYXJyYXkpID0+IHtcbiAgICByZXR1cm4gKG5ldyBTZXQoYXJyYXkpKS5zaXplICE9PSBhcnJheS5sZW5ndGg7XG59O1xuLyoqXG4gKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82MzAwNjYwMS93aHktZG9lcy11LXRocm93LWFuLWludmFsaWQtZXNjYXBlLWVycm9yXG4gKi9cbmV4cG9ydCBjb25zdCBlc2NhcGVfcmVnZXggPSAoc3RyKSA9PiB7XG4gICAgcmV0dXJuIChzdHIgKyAnJykucmVwbGFjZSgvKFtcXCRcXChcXClcXCpcXCtcXC5cXD9cXFtcXF1cXF5cXHtcXHxcXH1cXFxcXSkvZ3UsICdcXFxcJDEnKTtcbn07XG4vKipcbiAqIFJldHVybiB0aGUgbWF4IGxlbmd0aCBvZiBhcnJheSB2YWx1ZXNcbiAqL1xuZXhwb3J0IGNvbnN0IG1heFZhbHVlTGVuZ3RoID0gKGFycmF5KSA9PiB7XG4gICAgcmV0dXJuIGFycmF5LnJlZHVjZSgobG9uZ2VzdCwgdmFsdWUpID0+IE1hdGgubWF4KGxvbmdlc3QsIHVuaWNvZGVMZW5ndGgodmFsdWUpKSwgMCk7XG59O1xuZXhwb3J0IGNvbnN0IHVuaWNvZGVMZW5ndGggPSAoc3RyKSA9PiB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oc3RyKS5sZW5ndGg7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVnZXguanMubWFwIiwiLyoqXG4gKiBHZXQgYWxsIHBvc3NpYmxlIGNvbWJpbmF0aW9ucyBvZiBzdWJzdHJpbmdzIHRoYXQgYWRkIHVwIHRvIHRoZSBnaXZlbiBzdHJpbmdcbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzMwMTY5NTg3L2ZpbmQtYWxsLXRoZS1jb21iaW5hdGlvbi1vZi1zdWJzdHJpbmdzLXRoYXQtYWRkLXVwLXRvLXRoZS1naXZlbi1zdHJpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGFsbFN1YnN0cmluZ3MgPSAoaW5wdXQpID0+IHtcbiAgICBpZiAoaW5wdXQubGVuZ3RoID09PSAxKVxuICAgICAgICByZXR1cm4gW1tpbnB1dF1dO1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBzdGFydCA9IGlucHV0LnN1YnN0cmluZygxKTtcbiAgICBjb25zdCBzdWJhID0gYWxsU3Vic3RyaW5ncyhzdGFydCk7XG4gICAgc3ViYS5mb3JFYWNoKGZ1bmN0aW9uIChzdWJyZXN1bHQpIHtcbiAgICAgICAgbGV0IHRtcCA9IHN1YnJlc3VsdC5zbGljZSgwKTtcbiAgICAgICAgdG1wWzBdID0gaW5wdXQuY2hhckF0KDApICsgdG1wWzBdO1xuICAgICAgICByZXN1bHQucHVzaCh0bXApO1xuICAgICAgICB0bXAgPSBzdWJyZXN1bHQuc2xpY2UoMCk7XG4gICAgICAgIHRtcC51bnNoaWZ0KGlucHV0LmNoYXJBdCgwKSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRtcCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpbmdzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBjaGFyQXQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZScpLmNoYXJBdDtcblxuLy8gYEFkdmFuY2VTdHJpbmdJbmRleGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFkdmFuY2VzdHJpbmdpbmRleFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUywgaW5kZXgsIHVuaWNvZGUpIHtcbiAgcmV0dXJuIGluZGV4ICsgKHVuaWNvZGUgPyBjaGFyQXQoUywgaW5kZXgpLmxlbmd0aCA6IDEpO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEZGMjYtIGJ1ZzogQXJyYXlCdWZmZXJzIGFyZSBub24tZXh0ZW5zaWJsZSwgYnV0IE9iamVjdC5pc0V4dGVuc2libGUgZG9lcyBub3QgcmVwb3J0IGl0XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoOCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1pc2V4dGVuc2libGUsIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG4gICAgaWYgKE9iamVjdC5pc0V4dGVuc2libGUoYnVmZmVyKSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGJ1ZmZlciwgJ2EnLCB7IHZhbHVlOiA4IH0pO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlZmluZUJ1aWx0SW5BY2Nlc3NvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4tYWNjZXNzb3InKTtcbnZhciBkZWZpbmVCdWlsdElucyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW5zJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLWluc3RhbmNlJyk7XG52YXIgaXNOdWxsT3JVbmRlZmluZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtbnVsbC1vci11bmRlZmluZWQnKTtcbnZhciBpdGVyYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdGUnKTtcbnZhciBkZWZpbmVJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvci1kZWZpbmUnKTtcbnZhciBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1pdGVyLXJlc3VsdC1vYmplY3QnKTtcbnZhciBzZXRTcGVjaWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC1zcGVjaWVzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBmYXN0S2V5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLW1ldGFkYXRhJykuZmFzdEtleTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG5cbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgaW50ZXJuYWxTdGF0ZUdldHRlckZvciA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgdmFyIENvbnN0cnVjdG9yID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgUHJvdG90eXBlKTtcbiAgICAgIHNldEludGVybmFsU3RhdGUodGhhdCwge1xuICAgICAgICB0eXBlOiBDT05TVFJVQ1RPUl9OQU1FLFxuICAgICAgICBpbmRleDogY3JlYXRlKG51bGwpLFxuICAgICAgICBmaXJzdDogbnVsbCxcbiAgICAgICAgbGFzdDogbnVsbCxcbiAgICAgICAgc2l6ZTogMFxuICAgICAgfSk7XG4gICAgICBpZiAoIURFU0NSSVBUT1JTKSB0aGF0LnNpemUgPSAwO1xuICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChpdGVyYWJsZSkpIGl0ZXJhdGUoaXRlcmFibGUsIHRoYXRbQURERVJdLCB7IHRoYXQ6IHRoYXQsIEFTX0VOVFJJRVM6IElTX01BUCB9KTtcbiAgICB9KTtcblxuICAgIHZhciBQcm90b3R5cGUgPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbiAgICB2YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGVHZXR0ZXJGb3IoQ09OU1RSVUNUT1JfTkFNRSk7XG5cbiAgICB2YXIgZGVmaW5lID0gZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG4gICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgdmFyIHByZXZpb3VzLCBpbmRleDtcbiAgICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgIGVudHJ5LnZhbHVlID0gdmFsdWU7XG4gICAgICAvLyBjcmVhdGUgbmV3IGVudHJ5XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5sYXN0ID0gZW50cnkgPSB7XG4gICAgICAgICAgaW5kZXg6IGluZGV4ID0gZmFzdEtleShrZXksIHRydWUpLFxuICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBwcmV2aW91czogcHJldmlvdXMgPSBzdGF0ZS5sYXN0LFxuICAgICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgICAgcmVtb3ZlZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFzdGF0ZS5maXJzdCkgc3RhdGUuZmlyc3QgPSBlbnRyeTtcbiAgICAgICAgaWYgKHByZXZpb3VzKSBwcmV2aW91cy5uZXh0ID0gZW50cnk7XG4gICAgICAgIGlmIChERVNDUklQVE9SUykgc3RhdGUuc2l6ZSsrO1xuICAgICAgICBlbHNlIHRoYXQuc2l6ZSsrO1xuICAgICAgICAvLyBhZGQgdG8gaW5kZXhcbiAgICAgICAgaWYgKGluZGV4ICE9PSAnRicpIHN0YXRlLmluZGV4W2luZGV4XSA9IGVudHJ5O1xuICAgICAgfSByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgdmFyIGdldEVudHJ5ID0gZnVuY3Rpb24gKHRoYXQsIGtleSkge1xuICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcbiAgICAgIC8vIGZhc3QgY2FzZVxuICAgICAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpO1xuICAgICAgdmFyIGVudHJ5O1xuICAgICAgaWYgKGluZGV4ICE9PSAnRicpIHJldHVybiBzdGF0ZS5pbmRleFtpbmRleF07XG4gICAgICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcbiAgICAgIGZvciAoZW50cnkgPSBzdGF0ZS5maXJzdDsgZW50cnk7IGVudHJ5ID0gZW50cnkubmV4dCkge1xuICAgICAgICBpZiAoZW50cnkua2V5ID09PSBrZXkpIHJldHVybiBlbnRyeTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZGVmaW5lQnVpbHRJbnMoUHJvdG90eXBlLCB7XG4gICAgICAvLyBgeyBNYXAsIFNldCB9LnByb3RvdHlwZS5jbGVhcigpYCBtZXRob2RzXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuY2xlYXJcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5jbGVhclxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG4gICAgICAgIHZhciBlbnRyeSA9IHN0YXRlLmZpcnN0O1xuICAgICAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgICAgICBlbnRyeS5yZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZW50cnkucHJldmlvdXMpIGVudHJ5LnByZXZpb3VzID0gZW50cnkucHJldmlvdXMubmV4dCA9IG51bGw7XG4gICAgICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmZpcnN0ID0gc3RhdGUubGFzdCA9IG51bGw7XG4gICAgICAgIHN0YXRlLmluZGV4ID0gY3JlYXRlKG51bGwpO1xuICAgICAgICBpZiAoREVTQ1JJUFRPUlMpIHN0YXRlLnNpemUgPSAwO1xuICAgICAgICBlbHNlIHRoYXQuc2l6ZSA9IDA7XG4gICAgICB9LFxuICAgICAgLy8gYHsgTWFwLCBTZXQgfS5wcm90b3R5cGUuZGVsZXRlKGtleSlgIG1ldGhvZHNcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5kZWxldGVcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5kZWxldGVcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcbiAgICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uZXh0O1xuICAgICAgICAgIHZhciBwcmV2ID0gZW50cnkucHJldmlvdXM7XG4gICAgICAgICAgZGVsZXRlIHN0YXRlLmluZGV4W2VudHJ5LmluZGV4XTtcbiAgICAgICAgICBlbnRyeS5yZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAocHJldikgcHJldi5uZXh0ID0gbmV4dDtcbiAgICAgICAgICBpZiAobmV4dCkgbmV4dC5wcmV2aW91cyA9IHByZXY7XG4gICAgICAgICAgaWYgKHN0YXRlLmZpcnN0ID09PSBlbnRyeSkgc3RhdGUuZmlyc3QgPSBuZXh0O1xuICAgICAgICAgIGlmIChzdGF0ZS5sYXN0ID09PSBlbnRyeSkgc3RhdGUubGFzdCA9IHByZXY7XG4gICAgICAgICAgaWYgKERFU0NSSVBUT1JTKSBzdGF0ZS5zaXplLS07XG4gICAgICAgICAgZWxzZSB0aGF0LnNpemUtLTtcbiAgICAgICAgfSByZXR1cm4gISFlbnRyeTtcbiAgICAgIH0sXG4gICAgICAvLyBgeyBNYXAsIFNldCB9LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpYCBtZXRob2RzXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuZm9yZWFjaFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmZvcmVhY2hcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kKGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICAgICAgdmFyIGVudHJ5O1xuICAgICAgICB3aGlsZSAoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm5leHQgOiBzdGF0ZS5maXJzdCkge1xuICAgICAgICAgIGJvdW5kRnVuY3Rpb24oZW50cnkudmFsdWUsIGVudHJ5LmtleSwgdGhpcyk7XG4gICAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnJlbW92ZWQpIGVudHJ5ID0gZW50cnkucHJldmlvdXM7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBgeyBNYXAsIFNldH0ucHJvdG90eXBlLmhhcyhrZXkpYCBtZXRob2RzXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuaGFzXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuaGFzXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkodGhpcywga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRlZmluZUJ1aWx0SW5zKFByb3RvdHlwZSwgSVNfTUFQID8ge1xuICAgICAgLy8gYE1hcC5wcm90b3R5cGUuZ2V0KGtleSlgIG1ldGhvZFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmdldFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52YWx1ZTtcbiAgICAgIH0sXG4gICAgICAvLyBgTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlgIG1ldGhvZFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLnNldFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZGVmaW5lKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IDoge1xuICAgICAgLy8gYFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKWAgbWV0aG9kXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuYWRkXG4gICAgICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZGVmaW5lKHRoaXMsIHZhbHVlID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoREVTQ1JJUFRPUlMpIGRlZmluZUJ1aWx0SW5BY2Nlc3NvcihQcm90b3R5cGUsICdzaXplJywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLnNpemU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9LFxuICBzZXRTdHJvbmc6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQKSB7XG4gICAgdmFyIElURVJBVE9SX05BTUUgPSBDT05TVFJVQ1RPUl9OQU1FICsgJyBJdGVyYXRvcic7XG4gICAgdmFyIGdldEludGVybmFsQ29sbGVjdGlvblN0YXRlID0gaW50ZXJuYWxTdGF0ZUdldHRlckZvcihDT05TVFJVQ1RPUl9OQU1FKTtcbiAgICB2YXIgZ2V0SW50ZXJuYWxJdGVyYXRvclN0YXRlID0gaW50ZXJuYWxTdGF0ZUdldHRlckZvcihJVEVSQVRPUl9OQU1FKTtcbiAgICAvLyBgeyBNYXAsIFNldCB9LnByb3RvdHlwZS57IGtleXMsIHZhbHVlcywgZW50cmllcywgQEBpdGVyYXRvciB9KClgIG1ldGhvZHNcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuZW50cmllc1xuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5rZXlzXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLnZhbHVlc1xuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS1AQGl0ZXJhdG9yXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmVudHJpZXNcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUua2V5c1xuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS52YWx1ZXNcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUtQEBpdGVyYXRvclxuICAgIGRlZmluZUl0ZXJhdG9yKENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgICAgIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgICAgICB0eXBlOiBJVEVSQVRPUl9OQU1FLFxuICAgICAgICB0YXJnZXQ6IGl0ZXJhdGVkLFxuICAgICAgICBzdGF0ZTogZ2V0SW50ZXJuYWxDb2xsZWN0aW9uU3RhdGUoaXRlcmF0ZWQpLFxuICAgICAgICBraW5kOiBraW5kLFxuICAgICAgICBsYXN0OiBudWxsXG4gICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbEl0ZXJhdG9yU3RhdGUodGhpcyk7XG4gICAgICB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XG4gICAgICB2YXIgZW50cnkgPSBzdGF0ZS5sYXN0O1xuICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucmVtb3ZlZCkgZW50cnkgPSBlbnRyeS5wcmV2aW91cztcbiAgICAgIC8vIGdldCBuZXh0IGVudHJ5XG4gICAgICBpZiAoIXN0YXRlLnRhcmdldCB8fCAhKHN0YXRlLmxhc3QgPSBlbnRyeSA9IGVudHJ5ID8gZW50cnkubmV4dCA6IHN0YXRlLnN0YXRlLmZpcnN0KSkge1xuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuICAgICAgICBzdGF0ZS50YXJnZXQgPSBudWxsO1xuICAgICAgICByZXR1cm4gY3JlYXRlSXRlclJlc3VsdE9iamVjdCh1bmRlZmluZWQsIHRydWUpO1xuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxuICAgICAgaWYgKGtpbmQgPT09ICdrZXlzJykgcmV0dXJuIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QoZW50cnkua2V5LCBmYWxzZSk7XG4gICAgICBpZiAoa2luZCA9PT0gJ3ZhbHVlcycpIHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KGVudHJ5LnZhbHVlLCBmYWxzZSk7XG4gICAgICByZXR1cm4gY3JlYXRlSXRlclJlc3VsdE9iamVjdChbZW50cnkua2V5LCBlbnRyeS52YWx1ZV0sIGZhbHNlKTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJywgIUlTX01BUCwgdHJ1ZSk7XG5cbiAgICAvLyBgeyBNYXAsIFNldCB9LnByb3RvdHlwZVtAQHNwZWNpZXNdYCBhY2Nlc3NvcnNcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldC1tYXAtQEBzcGVjaWVzXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXQtc2V0LUBAc3BlY2llc1xuICAgIHNldFNwZWNpZXMoQ09OU1RSVUNUT1JfTkFNRSk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgZGVmaW5lQnVpbHRJbnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWlucycpO1xudmFyIGdldFdlYWtEYXRhID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLW1ldGFkYXRhJykuZ2V0V2Vha0RhdGE7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1pbnN0YW5jZScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGlzTnVsbE9yVW5kZWZpbmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW51bGwtb3ItdW5kZWZpbmVkJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgaXRlcmF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRlJyk7XG52YXIgQXJyYXlJdGVyYXRpb25Nb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG5cbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgaW50ZXJuYWxTdGF0ZUdldHRlckZvciA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yO1xudmFyIGZpbmQgPSBBcnJheUl0ZXJhdGlvbk1vZHVsZS5maW5kO1xudmFyIGZpbmRJbmRleCA9IEFycmF5SXRlcmF0aW9uTW9kdWxlLmZpbmRJbmRleDtcbnZhciBzcGxpY2UgPSB1bmN1cnJ5VGhpcyhbXS5zcGxpY2UpO1xudmFyIGlkID0gMDtcblxuLy8gZmFsbGJhY2sgZm9yIHVuY2F1Z2h0IGZyb3plbiBrZXlzXG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZnJvemVuIHx8IChzdGF0ZS5mcm96ZW4gPSBuZXcgVW5jYXVnaHRGcm96ZW5TdG9yZSgpKTtcbn07XG5cbnZhciBVbmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVudHJpZXMgPSBbXTtcbn07XG5cbnZhciBmaW5kVW5jYXVnaHRGcm96ZW4gPSBmdW5jdGlvbiAoc3RvcmUsIGtleSkge1xuICByZXR1cm4gZmluZChzdG9yZS5lbnRyaWVzLCBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgfSk7XG59O1xuXG5VbmNhdWdodEZyb3plblN0b3JlLnByb3RvdHlwZSA9IHtcbiAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSByZXR1cm4gZW50cnlbMV07XG4gIH0sXG4gIGhhczogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhIWZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSBlbnRyeVsxXSA9IHZhbHVlO1xuICAgIGVsc2UgdGhpcy5lbnRyaWVzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSxcbiAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXgodGhpcy5lbnRyaWVzLCBmdW5jdGlvbiAoaXQpIHtcbiAgICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICAgIH0pO1xuICAgIGlmICh+aW5kZXgpIHNwbGljZSh0aGlzLmVudHJpZXMsIGluZGV4LCAxKTtcbiAgICByZXR1cm4gISF+aW5kZXg7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHdyYXBwZXIsIENPTlNUUlVDVE9SX05BTUUsIElTX01BUCwgQURERVIpIHtcbiAgICB2YXIgQ29uc3RydWN0b3IgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBQcm90b3R5cGUpO1xuICAgICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGF0LCB7XG4gICAgICAgIHR5cGU6IENPTlNUUlVDVE9SX05BTUUsXG4gICAgICAgIGlkOiBpZCsrLFxuICAgICAgICBmcm96ZW46IG51bGxcbiAgICAgIH0pO1xuICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChpdGVyYWJsZSkpIGl0ZXJhdGUoaXRlcmFibGUsIHRoYXRbQURERVJdLCB7IHRoYXQ6IHRoYXQsIEFTX0VOVFJJRVM6IElTX01BUCB9KTtcbiAgICB9KTtcblxuICAgIHZhciBQcm90b3R5cGUgPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbiAgICB2YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGVHZXR0ZXJGb3IoQ09OU1RSVUNUT1JfTkFNRSk7XG5cbiAgICB2YXIgZGVmaW5lID0gZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG4gICAgICB2YXIgZGF0YSA9IGdldFdlYWtEYXRhKGFuT2JqZWN0KGtleSksIHRydWUpO1xuICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHVuY2F1Z2h0RnJvemVuU3RvcmUoc3RhdGUpLnNldChrZXksIHZhbHVlKTtcbiAgICAgIGVsc2UgZGF0YVtzdGF0ZS5pZF0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICBkZWZpbmVCdWlsdElucyhQcm90b3R5cGUsIHtcbiAgICAgIC8vIGB7IFdlYWtNYXAsIFdlYWtTZXQgfS5wcm90b3R5cGUuZGVsZXRlKGtleSlgIG1ldGhvZHNcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtd2Vha21hcC5wcm90b3R5cGUuZGVsZXRlXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXdlYWtzZXQucHJvdG90eXBlLmRlbGV0ZVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgaWYgKCFpc09iamVjdChrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2Vha0RhdGEoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHN0YXRlKVsnZGVsZXRlJ10oa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgaGFzT3duKGRhdGEsIHN0YXRlLmlkKSAmJiBkZWxldGUgZGF0YVtzdGF0ZS5pZF07XG4gICAgICB9LFxuICAgICAgLy8gYHsgV2Vha01hcCwgV2Vha1NldCB9LnByb3RvdHlwZS5oYXMoa2V5KWAgbWV0aG9kc1xuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy13ZWFrbWFwLnByb3RvdHlwZS5oYXNcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtd2Vha3NldC5wcm90b3R5cGUuaGFzXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgaWYgKCFpc09iamVjdChrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2Vha0RhdGEoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHN0YXRlKS5oYXMoa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgaGFzT3duKGRhdGEsIHN0YXRlLmlkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRlZmluZUJ1aWx0SW5zKFByb3RvdHlwZSwgSVNfTUFQID8ge1xuICAgICAgLy8gYFdlYWtNYXAucHJvdG90eXBlLmdldChrZXkpYCBtZXRob2RcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtd2Vha21hcC5wcm90b3R5cGUuZ2V0XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KGtleSkpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWtEYXRhKGtleSk7XG4gICAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHN0YXRlKS5nZXQoa2V5KTtcbiAgICAgICAgICBpZiAoZGF0YSkgcmV0dXJuIGRhdGFbc3RhdGUuaWRdO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gYFdlYWtNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKWAgbWV0aG9kXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXdlYWttYXAucHJvdG90eXBlLnNldFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZGVmaW5lKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gOiB7XG4gICAgICAvLyBgV2Vha1NldC5wcm90b3R5cGUuYWRkKHZhbHVlKWAgbWV0aG9kXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXdlYWtzZXQucHJvdG90eXBlLmFkZFxuICAgICAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZSh0aGlzLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBnbG9iYWxUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbC10aGlzJyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgaXNGb3JjZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtZm9yY2VkJyk7XG52YXIgZGVmaW5lQnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4nKTtcbnZhciBJbnRlcm5hbE1ldGFkYXRhTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLW1ldGFkYXRhJyk7XG52YXIgaXRlcmF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRlJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1pbnN0YW5jZScpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBpc051bGxPclVuZGVmaW5lZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1udWxsLW9yLXVuZGVmaW5lZCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NoZWNrLWNvcnJlY3RuZXNzLW9mLWl0ZXJhdGlvbicpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT05TVFJVQ1RPUl9OQU1FLCB3cmFwcGVyLCBjb21tb24pIHtcbiAgdmFyIElTX01BUCA9IENPTlNUUlVDVE9SX05BTUUuaW5kZXhPZignTWFwJykgIT09IC0xO1xuICB2YXIgSVNfV0VBSyA9IENPTlNUUlVDVE9SX05BTUUuaW5kZXhPZignV2VhaycpICE9PSAtMTtcbiAgdmFyIEFEREVSID0gSVNfTUFQID8gJ3NldCcgOiAnYWRkJztcbiAgdmFyIE5hdGl2ZUNvbnN0cnVjdG9yID0gZ2xvYmFsVGhpc1tDT05TVFJVQ1RPUl9OQU1FXTtcbiAgdmFyIE5hdGl2ZVByb3RvdHlwZSA9IE5hdGl2ZUNvbnN0cnVjdG9yICYmIE5hdGl2ZUNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgdmFyIENvbnN0cnVjdG9yID0gTmF0aXZlQ29uc3RydWN0b3I7XG4gIHZhciBleHBvcnRlZCA9IHt9O1xuXG4gIHZhciBmaXhNZXRob2QgPSBmdW5jdGlvbiAoS0VZKSB7XG4gICAgdmFyIHVuY3VycmllZE5hdGl2ZU1ldGhvZCA9IHVuY3VycnlUaGlzKE5hdGl2ZVByb3RvdHlwZVtLRVldKTtcbiAgICBkZWZpbmVCdWlsdEluKE5hdGl2ZVByb3RvdHlwZSwgS0VZLFxuICAgICAgS0VZID09PSAnYWRkJyA/IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgICAgICB1bmN1cnJpZWROYXRpdmVNZXRob2QodGhpcywgdmFsdWUgPT09IDAgPyAwIDogdmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gOiBLRVkgPT09ICdkZWxldGUnID8gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3Qoa2V5KSA/IGZhbHNlIDogdW5jdXJyaWVkTmF0aXZlTWV0aG9kKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXkpO1xuICAgICAgfSA6IEtFWSA9PT0gJ2dldCcgPyBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChrZXkpID8gdW5kZWZpbmVkIDogdW5jdXJyaWVkTmF0aXZlTWV0aG9kKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXkpO1xuICAgICAgfSA6IEtFWSA9PT0gJ2hhcycgPyBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChrZXkpID8gZmFsc2UgOiB1bmN1cnJpZWROYXRpdmVNZXRob2QodGhpcywga2V5ID09PSAwID8gMCA6IGtleSk7XG4gICAgICB9IDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgdW5jdXJyaWVkTmF0aXZlTWV0aG9kKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgKTtcbiAgfTtcblxuICB2YXIgUkVQTEFDRSA9IGlzRm9yY2VkKFxuICAgIENPTlNUUlVDVE9SX05BTUUsXG4gICAgIWlzQ2FsbGFibGUoTmF0aXZlQ29uc3RydWN0b3IpIHx8ICEoSVNfV0VBSyB8fCBOYXRpdmVQcm90b3R5cGUuZm9yRWFjaCAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKCkuZW50cmllcygpLm5leHQoKTtcbiAgICB9KSlcbiAgKTtcblxuICBpZiAoUkVQTEFDRSkge1xuICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAgQ29uc3RydWN0b3IgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgSW50ZXJuYWxNZXRhZGF0YU1vZHVsZS5lbmFibGUoKTtcbiAgfSBlbHNlIGlmIChpc0ZvcmNlZChDT05TVFJVQ1RPUl9OQU1FLCB0cnVlKSkge1xuICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgIC8vIGVhcmx5IGltcGxlbWVudGF0aW9ucyBub3Qgc3VwcG9ydHMgY2hhaW5pbmdcbiAgICB2YXIgSEFTTlRfQ0hBSU5JTkcgPSBpbnN0YW5jZVtBRERFUl0oSVNfV0VBSyA/IHt9IDogLTAsIDEpICE9PSBpbnN0YW5jZTtcbiAgICAvLyBWOCB+IENocm9taXVtIDQwLSB3ZWFrLWNvbGxlY3Rpb25zIHRocm93cyBvbiBwcmltaXRpdmVzLCBidXQgc2hvdWxkIHJldHVybiBmYWxzZVxuICAgIHZhciBUSFJPV1NfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgaW5zdGFuY2UuaGFzKDEpOyB9KTtcbiAgICAvLyBtb3N0IGVhcmx5IGltcGxlbWVudGF0aW9ucyBkb2Vzbid0IHN1cHBvcnRzIGl0ZXJhYmxlcywgbW9zdCBtb2Rlcm4gLSBub3QgY2xvc2UgaXQgY29ycmVjdGx5XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICAgIHZhciBBQ0NFUFRfSVRFUkFCTEVTID0gY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uKGZ1bmN0aW9uIChpdGVyYWJsZSkgeyBuZXcgTmF0aXZlQ29uc3RydWN0b3IoaXRlcmFibGUpOyB9KTtcbiAgICAvLyBmb3IgZWFybHkgaW1wbGVtZW50YXRpb25zIC0wIGFuZCArMCBub3QgdGhlIHNhbWVcbiAgICB2YXIgQlVHR1lfWkVSTyA9ICFJU19XRUFLICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFY4IH4gQ2hyb21pdW0gNDItIGZhaWxzIG9ubHkgd2l0aCA1KyBlbGVtZW50c1xuICAgICAgdmFyICRpbnN0YW5jZSA9IG5ldyBOYXRpdmVDb25zdHJ1Y3RvcigpO1xuICAgICAgdmFyIGluZGV4ID0gNTtcbiAgICAgIHdoaWxlIChpbmRleC0tKSAkaW5zdGFuY2VbQURERVJdKGluZGV4LCBpbmRleCk7XG4gICAgICByZXR1cm4gISRpbnN0YW5jZS5oYXMoLTApO1xuICAgIH0pO1xuXG4gICAgaWYgKCFBQ0NFUFRfSVRFUkFCTEVTKSB7XG4gICAgICBDb25zdHJ1Y3RvciA9IHdyYXBwZXIoZnVuY3Rpb24gKGR1bW15LCBpdGVyYWJsZSkge1xuICAgICAgICBhbkluc3RhbmNlKGR1bW15LCBOYXRpdmVQcm90b3R5cGUpO1xuICAgICAgICB2YXIgdGhhdCA9IGluaGVyaXRJZlJlcXVpcmVkKG5ldyBOYXRpdmVDb25zdHJ1Y3RvcigpLCBkdW1teSwgQ29uc3RydWN0b3IpO1xuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGl0ZXJhYmxlKSkgaXRlcmF0ZShpdGVyYWJsZSwgdGhhdFtBRERFUl0sIHsgdGhhdDogdGhhdCwgQVNfRU5UUklFUzogSVNfTUFQIH0pO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICAgIH0pO1xuICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gTmF0aXZlUHJvdG90eXBlO1xuICAgICAgTmF0aXZlUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gICAgfVxuXG4gICAgaWYgKFRIUk9XU19PTl9QUklNSVRJVkVTIHx8IEJVR0dZX1pFUk8pIHtcbiAgICAgIGZpeE1ldGhvZCgnZGVsZXRlJyk7XG4gICAgICBmaXhNZXRob2QoJ2hhcycpO1xuICAgICAgSVNfTUFQICYmIGZpeE1ldGhvZCgnZ2V0Jyk7XG4gICAgfVxuXG4gICAgaWYgKEJVR0dZX1pFUk8gfHwgSEFTTlRfQ0hBSU5JTkcpIGZpeE1ldGhvZChBRERFUik7XG5cbiAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIHNob3VsZCBub3QgY29udGFpbnMgLmNsZWFyIG1ldGhvZFxuICAgIGlmIChJU19XRUFLICYmIE5hdGl2ZVByb3RvdHlwZS5jbGVhcikgZGVsZXRlIE5hdGl2ZVByb3RvdHlwZS5jbGVhcjtcbiAgfVxuXG4gIGV4cG9ydGVkW0NPTlNUUlVDVE9SX05BTUVdID0gQ29uc3RydWN0b3I7XG4gICQoeyBnbG9iYWw6IHRydWUsIGNvbnN0cnVjdG9yOiB0cnVlLCBmb3JjZWQ6IENvbnN0cnVjdG9yICE9PSBOYXRpdmVDb25zdHJ1Y3RvciB9LCBleHBvcnRlZCk7XG5cbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIENPTlNUUlVDVE9SX05BTUUpO1xuXG4gIGlmICghSVNfV0VBSykgY29tbW9uLnNldFN0cm9uZyhDb25zdHJ1Y3RvciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQKTtcblxuICByZXR1cm4gQ29uc3RydWN0b3I7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgTUFUQ0ggPSB3ZWxsS25vd25TeW1ib2woJ21hdGNoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FKSB7XG4gIHZhciByZWdleHAgPSAvLi87XG4gIHRyeSB7XG4gICAgJy8uLydbTUVUSE9EX05BTUVdKHJlZ2V4cCk7XG4gIH0gY2F0Y2ggKGVycm9yMSkge1xuICAgIHRyeSB7XG4gICAgICByZWdleHBbTUFUQ0hdID0gZmFsc2U7XG4gICAgICByZXR1cm4gJy8uLydbTUVUSE9EX05BTUVdKHJlZ2V4cCk7XG4gICAgfSBjYXRjaCAoZXJyb3IyKSB7IC8qIGVtcHR5ICovIH1cbiAgfSByZXR1cm4gZmFsc2U7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRlZmluZUJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIGRlZmluZUJ1aWx0SW4odGFyZ2V0LCBrZXksIHNyY1trZXldLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRhcmdldDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gMHgxRkZGRkZGRkZGRkZGRjsgLy8gMiAqKiA1MyAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPiBNQVhfU0FGRV9JTlRFR0VSKSB0aHJvdyAkVHlwZUVycm9yKCdNYXhpbXVtIGFsbG93ZWQgaW5kZXggZXhjZWVkZWQnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIFRPRE86IFJlbW92ZSBmcm9tIGBjb3JlLWpzQDRgIHNpbmNlIGl0J3MgbW92ZWQgdG8gZW50cnkgcG9pbnRzXG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjJyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgZGVmaW5lQnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4nKTtcbnZhciByZWdleHBFeGVjID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1leGVjJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG52YXIgUmVnRXhwUHJvdG90eXBlID0gUmVnRXhwLnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBleGVjLCBGT1JDRUQsIFNIQU0pIHtcbiAgdmFyIFNZTUJPTCA9IHdlbGxLbm93blN5bWJvbChLRVkpO1xuXG4gIHZhciBERUxFR0FURVNfVE9fU1lNQk9MID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTdHJpbmcgbWV0aG9kcyBjYWxsIHN5bWJvbC1uYW1lZCBSZWdFeHAgbWV0aG9kc1xuICAgIHZhciBPID0ge307XG4gICAgT1tTWU1CT0xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfTtcbiAgICByZXR1cm4gJydbS0VZXShPKSAhPT0gNztcbiAgfSk7XG5cbiAgdmFyIERFTEVHQVRFU19UT19FWEVDID0gREVMRUdBVEVTX1RPX1NZTUJPTCAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIFN5bWJvbC1uYW1lZCBSZWdFeHAgbWV0aG9kcyBjYWxsIC5leGVjXG4gICAgdmFyIGV4ZWNDYWxsZWQgPSBmYWxzZTtcbiAgICB2YXIgcmUgPSAvYS87XG5cbiAgICBpZiAoS0VZID09PSAnc3BsaXQnKSB7XG4gICAgICAvLyBXZSBjYW4ndCB1c2UgcmVhbCByZWdleCBoZXJlIHNpbmNlIGl0IGNhdXNlcyBkZW9wdGltaXphdGlvblxuICAgICAgLy8gYW5kIHNlcmlvdXMgcGVyZm9ybWFuY2UgZGVncmFkYXRpb24gaW4gVjhcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8zMDZcbiAgICAgIHJlID0ge307XG4gICAgICAvLyBSZWdFeHBbQEBzcGxpdF0gZG9lc24ndCBjYWxsIHRoZSByZWdleCdzIGV4ZWMgbWV0aG9kLCBidXQgZmlyc3QgY3JlYXRlc1xuICAgICAgLy8gYSBuZXcgb25lLiBXZSBuZWVkIHRvIHJldHVybiB0aGUgcGF0Y2hlZCByZWdleCB3aGVuIGNyZWF0aW5nIHRoZSBuZXcgb25lLlxuICAgICAgcmUuY29uc3RydWN0b3IgPSB7fTtcbiAgICAgIHJlLmNvbnN0cnVjdG9yW1NQRUNJRVNdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmU7IH07XG4gICAgICByZS5mbGFncyA9ICcnO1xuICAgICAgcmVbU1lNQk9MXSA9IC8uL1tTWU1CT0xdO1xuICAgIH1cblxuICAgIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBleGVjQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICByZVtTWU1CT0xdKCcnKTtcbiAgICByZXR1cm4gIWV4ZWNDYWxsZWQ7XG4gIH0pO1xuXG4gIGlmIChcbiAgICAhREVMRUdBVEVTX1RPX1NZTUJPTCB8fFxuICAgICFERUxFR0FURVNfVE9fRVhFQyB8fFxuICAgIEZPUkNFRFxuICApIHtcbiAgICB2YXIgbmF0aXZlUmVnRXhwTWV0aG9kID0gLy4vW1NZTUJPTF07XG4gICAgdmFyIG1ldGhvZHMgPSBleGVjKFNZTUJPTCwgJydbS0VZXSwgZnVuY3Rpb24gKG5hdGl2ZU1ldGhvZCwgcmVnZXhwLCBzdHIsIGFyZzIsIGZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICB2YXIgJGV4ZWMgPSByZWdleHAuZXhlYztcbiAgICAgIGlmICgkZXhlYyA9PT0gcmVnZXhwRXhlYyB8fCAkZXhlYyA9PT0gUmVnRXhwUHJvdG90eXBlLmV4ZWMpIHtcbiAgICAgICAgaWYgKERFTEVHQVRFU19UT19TWU1CT0wgJiYgIWZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICAgICAgLy8gVGhlIG5hdGl2ZSBTdHJpbmcgbWV0aG9kIGFscmVhZHkgZGVsZWdhdGVzIHRvIEBAbWV0aG9kICh0aGlzXG4gICAgICAgICAgLy8gcG9seWZpbGxlZCBmdW5jdGlvbiksIGxlYXNpbmcgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAgICAgICAgIC8vIFdlIGF2b2lkIGl0IGJ5IGRpcmVjdGx5IGNhbGxpbmcgdGhlIG5hdGl2ZSBAQG1ldGhvZCBtZXRob2QuXG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IGNhbGwobmF0aXZlUmVnRXhwTWV0aG9kLCByZWdleHAsIHN0ciwgYXJnMikgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogY2FsbChuYXRpdmVNZXRob2QsIHN0ciwgcmVnZXhwLCBhcmcyKSB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UgfTtcbiAgICB9KTtcblxuICAgIGRlZmluZUJ1aWx0SW4oU3RyaW5nLnByb3RvdHlwZSwgS0VZLCBtZXRob2RzWzBdKTtcbiAgICBkZWZpbmVCdWlsdEluKFJlZ0V4cFByb3RvdHlwZSwgU1lNQk9MLCBtZXRob2RzWzFdKTtcbiAgfVxuXG4gIGlmIChTSEFNKSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoUmVnRXhwUHJvdG90eXBlW1NZTUJPTF0sICdzaGFtJywgdHJ1ZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1pc2V4dGVuc2libGUsIGVzL25vLW9iamVjdC1wcmV2ZW50ZXh0ZW5zaW9ucyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xuXG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIGNoYXJBdCA9IHVuY3VycnlUaGlzKCcnLmNoYXJBdCk7XG52YXIgcmVwbGFjZSA9IHVuY3VycnlUaGlzKCcnLnJlcGxhY2UpO1xudmFyIHN0cmluZ1NsaWNlID0gdW5jdXJyeVRoaXMoJycuc2xpY2UpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZG9zL25vLXZ1bG5lcmFibGUgLS0gc2FmZVxudmFyIFNVQlNUSVRVVElPTl9TWU1CT0xTID0gL1xcJChbJCYnYF18XFxkezEsMn18PFtePl0qPikvZztcbnZhciBTVUJTVElUVVRJT05fU1lNQk9MU19OT19OQU1FRCA9IC9cXCQoWyQmJ2BdfFxcZHsxLDJ9KS9nO1xuXG4vLyBgR2V0U3Vic3RpdHV0aW9uYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0c3Vic3RpdHV0aW9uXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRjaGVkLCBzdHIsIHBvc2l0aW9uLCBjYXB0dXJlcywgbmFtZWRDYXB0dXJlcywgcmVwbGFjZW1lbnQpIHtcbiAgdmFyIHRhaWxQb3MgPSBwb3NpdGlvbiArIG1hdGNoZWQubGVuZ3RoO1xuICB2YXIgbSA9IGNhcHR1cmVzLmxlbmd0aDtcbiAgdmFyIHN5bWJvbHMgPSBTVUJTVElUVVRJT05fU1lNQk9MU19OT19OQU1FRDtcbiAgaWYgKG5hbWVkQ2FwdHVyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIG5hbWVkQ2FwdHVyZXMgPSB0b09iamVjdChuYW1lZENhcHR1cmVzKTtcbiAgICBzeW1ib2xzID0gU1VCU1RJVFVUSU9OX1NZTUJPTFM7XG4gIH1cbiAgcmV0dXJuIHJlcGxhY2UocmVwbGFjZW1lbnQsIHN5bWJvbHMsIGZ1bmN0aW9uIChtYXRjaCwgY2gpIHtcbiAgICB2YXIgY2FwdHVyZTtcbiAgICBzd2l0Y2ggKGNoYXJBdChjaCwgMCkpIHtcbiAgICAgIGNhc2UgJyQnOiByZXR1cm4gJyQnO1xuICAgICAgY2FzZSAnJic6IHJldHVybiBtYXRjaGVkO1xuICAgICAgY2FzZSAnYCc6IHJldHVybiBzdHJpbmdTbGljZShzdHIsIDAsIHBvc2l0aW9uKTtcbiAgICAgIGNhc2UgXCInXCI6IHJldHVybiBzdHJpbmdTbGljZShzdHIsIHRhaWxQb3MpO1xuICAgICAgY2FzZSAnPCc6XG4gICAgICAgIGNhcHR1cmUgPSBuYW1lZENhcHR1cmVzW3N0cmluZ1NsaWNlKGNoLCAxLCAtMSldO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IC8vIFxcZFxcZD9cbiAgICAgICAgdmFyIG4gPSArY2g7XG4gICAgICAgIGlmIChuID09PSAwKSByZXR1cm4gbWF0Y2g7XG4gICAgICAgIGlmIChuID4gbSkge1xuICAgICAgICAgIHZhciBmID0gZmxvb3IobiAvIDEwKTtcbiAgICAgICAgICBpZiAoZiA9PT0gMCkgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgIGlmIChmIDw9IG0pIHJldHVybiBjYXB0dXJlc1tmIC0gMV0gPT09IHVuZGVmaW5lZCA/IGNoYXJBdChjaCwgMSkgOiBjYXB0dXJlc1tmIC0gMV0gKyBjaGFyQXQoY2gsIDEpO1xuICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfVxuICAgICAgICBjYXB0dXJlID0gY2FwdHVyZXNbbiAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4gY2FwdHVyZSA9PT0gdW5kZWZpbmVkID8gJycgOiBjYXB0dXJlO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGRlbi1rZXlzJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLWV4dGVybmFsJyk7XG52YXIgaXNFeHRlbnNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1pcy1leHRlbnNpYmxlJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VpZCcpO1xudmFyIEZSRUVaSU5HID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZyZWV6aW5nJyk7XG5cbnZhciBSRVFVSVJFRCA9IGZhbHNlO1xudmFyIE1FVEFEQVRBID0gdWlkKCdtZXRhJyk7XG52YXIgaWQgPSAwO1xuXG52YXIgc2V0TWV0YWRhdGEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgZGVmaW5lUHJvcGVydHkoaXQsIE1FVEFEQVRBLCB7IHZhbHVlOiB7XG4gICAgb2JqZWN0SUQ6ICdPJyArIGlkKyssIC8vIG9iamVjdCBJRFxuICAgIHdlYWtEYXRhOiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IH0pO1xufTtcblxudmFyIGZhc3RLZXkgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICAvLyByZXR1cm4gYSBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmICghaGFzT3duKGl0LCBNRVRBREFUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YWRhdGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFEQVRBXS5vYmplY3RJRDtcbn07XG5cbnZhciBnZXRXZWFrRGF0YSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIGlmICghaGFzT3duKGl0LCBNRVRBREFUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YWRhdGEoaXQpO1xuICAvLyByZXR1cm4gdGhlIHN0b3JlIG9mIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFEQVRBXS53ZWFrRGF0YTtcbn07XG5cbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChGUkVFWklORyAmJiBSRVFVSVJFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXNPd24oaXQsIE1FVEFEQVRBKSkgc2V0TWV0YWRhdGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG52YXIgZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICBtZXRhLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbiAgUkVRVUlSRUQgPSB0cnVlO1xuICB2YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUuZjtcbiAgdmFyIHNwbGljZSA9IHVuY3VycnlUaGlzKFtdLnNwbGljZSk7XG4gIHZhciB0ZXN0ID0ge307XG4gIHRlc3RbTUVUQURBVEFdID0gMTtcblxuICAvLyBwcmV2ZW50IGV4cG9zaW5nIG9mIG1ldGFkYXRhIGtleVxuICBpZiAoZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0KS5sZW5ndGgpIHtcbiAgICBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICAgIHZhciByZXN1bHQgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSByZXN1bHQubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJlc3VsdFtpXSA9PT0gTUVUQURBVEEpIHtcbiAgICAgICAgICBzcGxpY2UocmVzdWx0LCBpLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAkKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiB0cnVlIH0sIHtcbiAgICAgIGdldE93blByb3BlcnR5TmFtZXM6IGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbE1vZHVsZS5mXG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIGVuYWJsZTogZW5hYmxlLFxuICBmYXN0S2V5OiBmYXN0S2V5LFxuICBnZXRXZWFrRGF0YTogZ2V0V2Vha0RhdGEsXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcblxuaGlkZGVuS2V5c1tNRVRBREFUQV0gPSB0cnVlO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIE1BVENIID0gd2VsbEtub3duU3ltYm9sKCdtYXRjaCcpO1xuXG4vLyBgSXNSZWdFeHBgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc3JlZ2V4cFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSF0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY2xhc3NvZihpdCkgPT09ICdSZWdFeHAnKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcmVnZXhwJyk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXNSZWdFeHAoaXQpKSB7XG4gICAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoXCJUaGUgbWV0aG9kIGRvZXNuJ3QgYWNjZXB0IHJlZ3VsYXIgZXhwcmVzc2lvbnNcIik7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcbnZhciBBUlJBWV9CVUZGRVJfTk9OX0VYVEVOU0lCTEUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLW5vbi1leHRlbnNpYmxlJyk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtaXNleHRlbnNpYmxlIC0tIHNhZmVcbnZhciAkaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcbnZhciBGQUlMU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24gKCkgeyAkaXNFeHRlbnNpYmxlKDEpOyB9KTtcblxuLy8gYE9iamVjdC5pc0V4dGVuc2libGVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuaXNleHRlbnNpYmxlXG5tb2R1bGUuZXhwb3J0cyA9IChGQUlMU19PTl9QUklNSVRJVkVTIHx8IEFSUkFZX0JVRkZFUl9OT05fRVhURU5TSUJMRSkgPyBmdW5jdGlvbiBpc0V4dGVuc2libGUoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBmYWxzZTtcbiAgaWYgKEFSUkFZX0JVRkZFUl9OT05fRVhURU5TSUJMRSAmJiBjbGFzc29mKGl0KSA9PT0gJ0FycmF5QnVmZmVyJykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gJGlzRXh0ZW5zaWJsZSA/ICRpc0V4dGVuc2libGUoaXQpIDogdHJ1ZTtcbn0gOiAkaXNFeHRlbnNpYmxlO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG52YXIgcmVnZXhwRXhlYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWdleHAtZXhlYycpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gYFJlZ0V4cEV4ZWNgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWdleHBleGVjXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChSLCBTKSB7XG4gIHZhciBleGVjID0gUi5leGVjO1xuICBpZiAoaXNDYWxsYWJsZShleGVjKSkge1xuICAgIHZhciByZXN1bHQgPSBjYWxsKGV4ZWMsIFIsIFMpO1xuICAgIGlmIChyZXN1bHQgIT09IG51bGwpIGFuT2JqZWN0KHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoY2xhc3NvZihSKSA9PT0gJ1JlZ0V4cCcpIHJldHVybiBjYWxsKHJlZ2V4cEV4ZWMsIFIsIFMpO1xuICB0aHJvdyBuZXcgJFR5cGVFcnJvcignUmVnRXhwI2V4ZWMgY2FsbGVkIG9uIGluY29tcGF0aWJsZSByZWNlaXZlcicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1hcnJheScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2xlbmd0aC1vZi1hcnJheS1saWtlJyk7XG52YXIgZG9lc05vdEV4Y2VlZFNhZmVJbnRlZ2VyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RvZXMtbm90LWV4Y2VlZC1zYWZlLWludGVnZXInKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHknKTtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0Jyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgVjhfVkVSU0lPTiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbnZpcm9ubWVudC12OC12ZXJzaW9uJyk7XG5cbnZhciBJU19DT05DQVRfU1BSRUFEQUJMRSA9IHdlbGxLbm93blN5bWJvbCgnaXNDb25jYXRTcHJlYWRhYmxlJyk7XG5cbi8vIFdlIGNhbid0IHVzZSB0aGlzIGZlYXR1cmUgZGV0ZWN0aW9uIGluIFY4IHNpbmNlIGl0IGNhdXNlc1xuLy8gZGVvcHRpbWl6YXRpb24gYW5kIHNlcmlvdXMgcGVyZm9ybWFuY2UgZGVncmFkYXRpb25cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NzlcbnZhciBJU19DT05DQVRfU1BSRUFEQUJMRV9TVVBQT1JUID0gVjhfVkVSU0lPTiA+PSA1MSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyYXkgPSBbXTtcbiAgYXJyYXlbSVNfQ09OQ0FUX1NQUkVBREFCTEVdID0gZmFsc2U7XG4gIHJldHVybiBhcnJheS5jb25jYXQoKVswXSAhPT0gYXJyYXk7XG59KTtcblxudmFyIGlzQ29uY2F0U3ByZWFkYWJsZSA9IGZ1bmN0aW9uIChPKSB7XG4gIGlmICghaXNPYmplY3QoTykpIHJldHVybiBmYWxzZTtcbiAgdmFyIHNwcmVhZGFibGUgPSBPW0lTX0NPTkNBVF9TUFJFQURBQkxFXTtcbiAgcmV0dXJuIHNwcmVhZGFibGUgIT09IHVuZGVmaW5lZCA/ICEhc3ByZWFkYWJsZSA6IGlzQXJyYXkoTyk7XG59O1xuXG52YXIgRk9SQ0VEID0gIUlTX0NPTkNBVF9TUFJFQURBQkxFX1NVUFBPUlQgfHwgIWFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQoJ2NvbmNhdCcpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmNvbmNhdGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5jb25jYXRcbi8vIHdpdGggYWRkaW5nIHN1cHBvcnQgb2YgQEBpc0NvbmNhdFNwcmVhZGFibGUgYW5kIEBAc3BlY2llc1xuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGFyaXR5OiAxLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gIGNvbmNhdDogZnVuY3Rpb24gY29uY2F0KGFyZykge1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIEEgPSBhcnJheVNwZWNpZXNDcmVhdGUoTywgMCk7XG4gICAgdmFyIG4gPSAwO1xuICAgIHZhciBpLCBrLCBsZW5ndGgsIGxlbiwgRTtcbiAgICBmb3IgKGkgPSAtMSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBFID0gaSA9PT0gLTEgPyBPIDogYXJndW1lbnRzW2ldO1xuICAgICAgaWYgKGlzQ29uY2F0U3ByZWFkYWJsZShFKSkge1xuICAgICAgICBsZW4gPSBsZW5ndGhPZkFycmF5TGlrZShFKTtcbiAgICAgICAgZG9lc05vdEV4Y2VlZFNhZmVJbnRlZ2VyKG4gKyBsZW4pO1xuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbGVuOyBrKyssIG4rKykgaWYgKGsgaW4gRSkgY3JlYXRlUHJvcGVydHkoQSwgbiwgRVtrXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb2VzTm90RXhjZWVkU2FmZUludGVnZXIobiArIDEpO1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShBLCBuKyssIEUpO1xuICAgICAgfVxuICAgIH1cbiAgICBBLmxlbmd0aCA9IG47XG4gICAgcmV0dXJuIEE7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgJGZpbHRlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24nKS5maWx0ZXI7XG52YXIgYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydCcpO1xuXG52YXIgSEFTX1NQRUNJRVNfU1VQUE9SVCA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQoJ2ZpbHRlcicpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWx0ZXJcbi8vIHdpdGggYWRkaW5nIHN1cHBvcnQgb2YgQEBzcGVjaWVzXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhSEFTX1NQRUNJRVNfU1VQUE9SVCB9LCB7XG4gIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRmaWx0ZXIodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyICRmaW5kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbicpLmZpbmQ7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hZGQtdG8tdW5zY29wYWJsZXMnKTtcblxudmFyIEZJTkQgPSAnZmluZCc7XG52YXIgU0tJUFNfSE9MRVMgPSB0cnVlO1xuXG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWFycmF5LXByb3RvdHlwZS1maW5kIC0tIHRlc3RpbmdcbmlmIChGSU5EIGluIFtdKSBBcnJheSgxKVtGSU5EXShmdW5jdGlvbiAoKSB7IFNLSVBTX0hPTEVTID0gZmFsc2U7IH0pO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmZpbmRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZFxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogU0tJUFNfSE9MRVMgfSwge1xuICBmaW5kOiBmdW5jdGlvbiBmaW5kKGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XG4gICAgcmV0dXJuICRmaW5kKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmFkZFRvVW5zY29wYWJsZXMoRklORCk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciAkaW5jbHVkZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMnKS5pbmNsdWRlcztcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYWRkLXRvLXVuc2NvcGFibGVzJyk7XG5cbi8vIEZGOTkrIGJ1Z1xudmFyIEJST0tFTl9PTl9TUEFSU0UgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1hcnJheS1wcm90b3R5cGUtaW5jbHVkZXMgLS0gZGV0ZWN0aW9uXG4gIHJldHVybiAhQXJyYXkoMSkuaW5jbHVkZXMoKTtcbn0pO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBCUk9LRU5fT05fU1BBUlNFIH0sIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKGVsIC8qICwgZnJvbUluZGV4ID0gMCAqLykge1xuICAgIHJldHVybiAkaW5jbHVkZXModGhpcywgZWwsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmFkZFRvVW5zY29wYWJsZXMoJ2luY2x1ZGVzJyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciAkZW50cmllcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtdG8tYXJyYXknKS5lbnRyaWVzO1xuXG4vLyBgT2JqZWN0LmVudHJpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZW50cmllc1xuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUgfSwge1xuICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKE8pIHtcbiAgICByZXR1cm4gJGVudHJpZXMoTyk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpLmY7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcblxudmFyIEZPUkNFRCA9ICFERVNDUklQVE9SUyB8fCBmYWlscyhmdW5jdGlvbiAoKSB7IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcigxKTsgfSk7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvclxuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogRk9SQ0VELCBzaGFtOiAhREVTQ1JJUFRPUlMgfSwge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gICAgcmV0dXJuIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcih0b0luZGV4ZWRPYmplY3QoaXQpLCBrZXkpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgb3duS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vd24ta2V5cycpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5Jyk7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JzXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgc2hhbTogIURFU0NSSVBUT1JTIH0sIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmplY3QpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xuICAgIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbiAgICB2YXIga2V5cyA9IG93bktleXMoTyk7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGtleSwgZGVzY3JpcHRvcjtcbiAgICB3aGlsZSAoa2V5cy5sZW5ndGggPiBpbmRleCkge1xuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBrZXkgPSBrZXlzW2luZGV4KytdKTtcbiAgICAgIGlmIChkZXNjcmlwdG9yICE9PSB1bmRlZmluZWQpIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jb2xsZWN0aW9uJyk7XG52YXIgY29sbGVjdGlvblN0cm9uZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jb2xsZWN0aW9uLXN0cm9uZycpO1xuXG4vLyBgU2V0YCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQtb2JqZWN0c1xuY29sbGVjdGlvbignU2V0JywgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFNldCgpIHsgcmV0dXJuIGluaXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCBjb2xsZWN0aW9uU3Ryb25nKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIFRPRE86IFJlbW92ZSB0aGlzIG1vZHVsZSBmcm9tIGBjb3JlLWpzQDRgIHNpbmNlIGl0J3MgcmVwbGFjZWQgdG8gbW9kdWxlIGJlbG93XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnNldC5jb25zdHJ1Y3RvcicpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgbm90QVJlZ0V4cCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9ub3QtYS1yZWdleHAnKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZycpO1xudmFyIGNvcnJlY3RJc1JlZ0V4cExvZ2ljID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvcnJlY3QtaXMtcmVnZXhwLWxvZ2ljJyk7XG5cbnZhciBzdHJpbmdJbmRleE9mID0gdW5jdXJyeVRoaXMoJycuaW5kZXhPZik7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlc1xuJCh7IHRhcmdldDogJ1N0cmluZycsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFjb3JyZWN0SXNSZWdFeHBMb2dpYygnaW5jbHVkZXMnKSB9LCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hTdHJpbmcgLyogLCBwb3NpdGlvbiA9IDAgKi8pIHtcbiAgICByZXR1cm4gISF+c3RyaW5nSW5kZXhPZihcbiAgICAgIHRvU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcykpLFxuICAgICAgdG9TdHJpbmcobm90QVJlZ0V4cChzZWFyY2hTdHJpbmcpKSxcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkXG4gICAgKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYXBwbHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYXBwbHknKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBmaXhSZWdFeHBXZWxsS25vd25TeW1ib2xMb2dpYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9maXgtcmVnZXhwLXdlbGwta25vd24tc3ltYm9sLWxvZ2ljJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyLW9yLWluZmluaXR5Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nJyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcbnZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYWR2YW5jZS1zdHJpbmctaW5kZXgnKTtcbnZhciBnZXRNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LW1ldGhvZCcpO1xudmFyIGdldFN1YnN0aXR1dGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtc3Vic3RpdHV0aW9uJyk7XG52YXIgcmVnRXhwRXhlYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWdleHAtZXhlYy1hYnN0cmFjdCcpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgUkVQTEFDRSA9IHdlbGxLbm93blN5bWJvbCgncmVwbGFjZScpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xudmFyIGNvbmNhdCA9IHVuY3VycnlUaGlzKFtdLmNvbmNhdCk7XG52YXIgcHVzaCA9IHVuY3VycnlUaGlzKFtdLnB1c2gpO1xudmFyIHN0cmluZ0luZGV4T2YgPSB1bmN1cnJ5VGhpcygnJy5pbmRleE9mKTtcbnZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzKCcnLnNsaWNlKTtcblxudmFyIG1heWJlVG9TdHJpbmcgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyBpdCA6IFN0cmluZyhpdCk7XG59O1xuXG4vLyBJRSA8PSAxMSByZXBsYWNlcyAkMCB3aXRoIHRoZSB3aG9sZSBtYXRjaCwgYXMgaWYgaXQgd2FzICQmXG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82MDI0NjY2L2dldHRpbmctaWUtdG8tcmVwbGFjZS1hLXJlZ2V4LXdpdGgtdGhlLWxpdGVyYWwtc3RyaW5nLTBcbnZhciBSRVBMQUNFX0tFRVBTXyQwID0gKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZ2V4cC9wcmVmZXItZXNjYXBlLXJlcGxhY2VtZW50LWRvbGxhci1jaGFyIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiAnYScucmVwbGFjZSgvLi8sICckMCcpID09PSAnJDAnO1xufSkoKTtcblxuLy8gU2FmYXJpIDw9IDEzLjAuMyg/KSBzdWJzdGl0dXRlcyBudGggY2FwdHVyZSB3aGVyZSBuPm0gd2l0aCBhbiBlbXB0eSBzdHJpbmdcbnZhciBSRUdFWFBfUkVQTEFDRV9TVUJTVElUVVRFU19VTkRFRklORURfQ0FQVFVSRSA9IChmdW5jdGlvbiAoKSB7XG4gIGlmICgvLi9bUkVQTEFDRV0pIHtcbiAgICByZXR1cm4gLy4vW1JFUExBQ0VdKCdhJywgJyQwJykgPT09ICcnO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn0pKCk7XG5cbnZhciBSRVBMQUNFX1NVUFBPUlRTX05BTUVEX0dST1VQUyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciByZSA9IC8uLztcbiAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgcmVzdWx0Lmdyb3VwcyA9IHsgYTogJzcnIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZ2V4cC9uby11c2VsZXNzLWRvbGxhci1yZXBsYWNlbWVudHMgLS0gZmFsc2UgcG9zaXRpdmVcbiAgcmV0dXJuICcnLnJlcGxhY2UocmUsICckPGE+JykgIT09ICc3Jztcbn0pO1xuXG4vLyBAQHJlcGxhY2UgbG9naWNcbmZpeFJlZ0V4cFdlbGxLbm93blN5bWJvbExvZ2ljKCdyZXBsYWNlJywgZnVuY3Rpb24gKF8sIG5hdGl2ZVJlcGxhY2UsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICB2YXIgVU5TQUZFX1NVQlNUSVRVVEUgPSBSRUdFWFBfUkVQTEFDRV9TVUJTVElUVVRFU19VTkRFRklORURfQ0FQVFVSRSA/ICckJyA6ICckMCc7XG5cbiAgcmV0dXJuIFtcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUucmVwbGFjZVxuICAgIGZ1bmN0aW9uIHJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSkge1xuICAgICAgdmFyIE8gPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpO1xuICAgICAgdmFyIHJlcGxhY2VyID0gaXNPYmplY3Qoc2VhcmNoVmFsdWUpID8gZ2V0TWV0aG9kKHNlYXJjaFZhbHVlLCBSRVBMQUNFKSA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiByZXBsYWNlclxuICAgICAgICA/IGNhbGwocmVwbGFjZXIsIHNlYXJjaFZhbHVlLCBPLCByZXBsYWNlVmFsdWUpXG4gICAgICAgIDogY2FsbChuYXRpdmVSZXBsYWNlLCB0b1N0cmluZyhPKSwgc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSk7XG4gICAgfSxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEByZXBsYWNlXG4gICAgZnVuY3Rpb24gKHN0cmluZywgcmVwbGFjZVZhbHVlKSB7XG4gICAgICB2YXIgcnggPSBhbk9iamVjdCh0aGlzKTtcbiAgICAgIHZhciBTID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgcmVwbGFjZVZhbHVlID09ICdzdHJpbmcnICYmXG4gICAgICAgIHN0cmluZ0luZGV4T2YocmVwbGFjZVZhbHVlLCBVTlNBRkVfU1VCU1RJVFVURSkgPT09IC0xICYmXG4gICAgICAgIHN0cmluZ0luZGV4T2YocmVwbGFjZVZhbHVlLCAnJDwnKSA9PT0gLTFcbiAgICAgICkge1xuICAgICAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKG5hdGl2ZVJlcGxhY2UsIHJ4LCBTLCByZXBsYWNlVmFsdWUpO1xuICAgICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBmdW5jdGlvbmFsUmVwbGFjZSA9IGlzQ2FsbGFibGUocmVwbGFjZVZhbHVlKTtcbiAgICAgIGlmICghZnVuY3Rpb25hbFJlcGxhY2UpIHJlcGxhY2VWYWx1ZSA9IHRvU3RyaW5nKHJlcGxhY2VWYWx1ZSk7XG5cbiAgICAgIHZhciBnbG9iYWwgPSByeC5nbG9iYWw7XG4gICAgICB2YXIgZnVsbFVuaWNvZGU7XG4gICAgICBpZiAoZ2xvYmFsKSB7XG4gICAgICAgIGZ1bGxVbmljb2RlID0gcngudW5pY29kZTtcbiAgICAgICAgcngubGFzdEluZGV4ID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICByZXN1bHQgPSByZWdFeHBFeGVjKHJ4LCBTKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkgYnJlYWs7XG5cbiAgICAgICAgcHVzaChyZXN1bHRzLCByZXN1bHQpO1xuICAgICAgICBpZiAoIWdsb2JhbCkgYnJlYWs7XG5cbiAgICAgICAgdmFyIG1hdGNoU3RyID0gdG9TdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgICAgaWYgKG1hdGNoU3RyID09PSAnJykgcngubGFzdEluZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHRvTGVuZ3RoKHJ4Lmxhc3RJbmRleCksIGZ1bGxVbmljb2RlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFjY3VtdWxhdGVkUmVzdWx0ID0gJyc7XG4gICAgICB2YXIgbmV4dFNvdXJjZVBvc2l0aW9uID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgPSByZXN1bHRzW2ldO1xuXG4gICAgICAgIHZhciBtYXRjaGVkID0gdG9TdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gbWF4KG1pbih0b0ludGVnZXJPckluZmluaXR5KHJlc3VsdC5pbmRleCksIFMubGVuZ3RoKSwgMCk7XG4gICAgICAgIHZhciBjYXB0dXJlcyA9IFtdO1xuICAgICAgICB2YXIgcmVwbGFjZW1lbnQ7XG4gICAgICAgIC8vIE5PVEU6IFRoaXMgaXMgZXF1aXZhbGVudCB0b1xuICAgICAgICAvLyAgIGNhcHR1cmVzID0gcmVzdWx0LnNsaWNlKDEpLm1hcChtYXliZVRvU3RyaW5nKVxuICAgICAgICAvLyBidXQgZm9yIHNvbWUgcmVhc29uIGBuYXRpdmVTbGljZS5jYWxsKHJlc3VsdCwgMSwgcmVzdWx0Lmxlbmd0aClgIChjYWxsZWQgaW5cbiAgICAgICAgLy8gdGhlIHNsaWNlIHBvbHlmaWxsIHdoZW4gc2xpY2luZyBuYXRpdmUgYXJyYXlzKSBcImRvZXNuJ3Qgd29ya1wiIGluIHNhZmFyaSA5IGFuZFxuICAgICAgICAvLyBjYXVzZXMgYSBjcmFzaCAoaHR0cHM6Ly9wYXN0ZWJpbi5jb20vTjIxUXplUUEpIHdoZW4gdHJ5aW5nIHRvIGRlYnVnIGl0LlxuICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHJlc3VsdC5sZW5ndGg7IGorKykgcHVzaChjYXB0dXJlcywgbWF5YmVUb1N0cmluZyhyZXN1bHRbal0pKTtcbiAgICAgICAgdmFyIG5hbWVkQ2FwdHVyZXMgPSByZXN1bHQuZ3JvdXBzO1xuICAgICAgICBpZiAoZnVuY3Rpb25hbFJlcGxhY2UpIHtcbiAgICAgICAgICB2YXIgcmVwbGFjZXJBcmdzID0gY29uY2F0KFttYXRjaGVkXSwgY2FwdHVyZXMsIHBvc2l0aW9uLCBTKTtcbiAgICAgICAgICBpZiAobmFtZWRDYXB0dXJlcyAhPT0gdW5kZWZpbmVkKSBwdXNoKHJlcGxhY2VyQXJncywgbmFtZWRDYXB0dXJlcyk7XG4gICAgICAgICAgcmVwbGFjZW1lbnQgPSB0b1N0cmluZyhhcHBseShyZXBsYWNlVmFsdWUsIHVuZGVmaW5lZCwgcmVwbGFjZXJBcmdzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVwbGFjZW1lbnQgPSBnZXRTdWJzdGl0dXRpb24obWF0Y2hlZCwgUywgcG9zaXRpb24sIGNhcHR1cmVzLCBuYW1lZENhcHR1cmVzLCByZXBsYWNlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbiA+PSBuZXh0U291cmNlUG9zaXRpb24pIHtcbiAgICAgICAgICBhY2N1bXVsYXRlZFJlc3VsdCArPSBzdHJpbmdTbGljZShTLCBuZXh0U291cmNlUG9zaXRpb24sIHBvc2l0aW9uKSArIHJlcGxhY2VtZW50O1xuICAgICAgICAgIG5leHRTb3VyY2VQb3NpdGlvbiA9IHBvc2l0aW9uICsgbWF0Y2hlZC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjY3VtdWxhdGVkUmVzdWx0ICsgc3RyaW5nU2xpY2UoUywgbmV4dFNvdXJjZVBvc2l0aW9uKTtcbiAgICB9XG4gIF07XG59LCAhUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMgfHwgIVJFUExBQ0VfS0VFUFNfJDAgfHwgUkVHRVhQX1JFUExBQ0VfU1VCU1RJVFVURVNfVU5ERUZJTkVEX0NBUFRVUkUpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29sbGVjdGlvbicpO1xudmFyIGNvbGxlY3Rpb25XZWFrID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvbGxlY3Rpb24td2VhaycpO1xuXG4vLyBgV2Vha1NldGAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtd2Vha3NldC1jb25zdHJ1Y3RvclxuY29sbGVjdGlvbignV2Vha1NldCcsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrU2V0KCkgeyByZXR1cm4gaW5pdCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIGNvbGxlY3Rpb25XZWFrKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIFRPRE86IFJlbW92ZSB0aGlzIG1vZHVsZSBmcm9tIGBjb3JlLWpzQDRgIHNpbmNlIGl0J3MgcmVwbGFjZWQgdG8gbW9kdWxlIGJlbG93XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLndlYWstc2V0LmNvbnN0cnVjdG9yJyk7XG4iLCJleHBvcnQgY29uc3QgS0VZX0EgPSA2NTtcbmV4cG9ydCBjb25zdCBLRVlfUkVUVVJOID0gMTM7XG5leHBvcnQgY29uc3QgS0VZX0VTQyA9IDI3O1xuZXhwb3J0IGNvbnN0IEtFWV9MRUZUID0gMzc7XG5leHBvcnQgY29uc3QgS0VZX1VQID0gMzg7XG5leHBvcnQgY29uc3QgS0VZX1JJR0hUID0gMzk7XG5leHBvcnQgY29uc3QgS0VZX0RPV04gPSA0MDtcbmV4cG9ydCBjb25zdCBLRVlfQkFDS1NQQUNFID0gODtcbmV4cG9ydCBjb25zdCBLRVlfREVMRVRFID0gNDY7XG5leHBvcnQgY29uc3QgS0VZX1RBQiA9IDk7XG5leHBvcnQgY29uc3QgSVNfTUFDID0gdHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgPyBmYWxzZSA6IC9NYWMvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5leHBvcnQgY29uc3QgS0VZX1NIT1JUQ1VUID0gSVNfTUFDID8gJ21ldGFLZXknIDogJ2N0cmxLZXknOyAvLyBjdHJsIGtleSBvciBhcHBsZSBrZXkgZm9yIG1hXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIiwiLyoqXG4gKiBoaWdobGlnaHQgdjMgfCBNSVQgbGljZW5zZSB8IEpvaGFubiBCdXJrYXJkIDxqYkBlYWlvLmNvbT5cbiAqIEhpZ2hsaWdodHMgYXJiaXRyYXJ5IHRlcm1zIGluIGEgbm9kZS5cbiAqXG4gKiAtIE1vZGlmaWVkIGJ5IE1hcnNoYWwgPGJlYXRnYXRlc0BnbWFpbC5jb20+IDIwMTEtNi0yNCAoYWRkZWQgcmVnZXgpXG4gKiAtIE1vZGlmaWVkIGJ5IEJyaWFuIFJlYXZpcyA8YnJpYW5AdGhpcmRyb3V0ZS5jb20+IDIwMTItOC0yNyAoY2xlYW51cClcbiAqL1xuaW1wb3J0IHsgcmVwbGFjZU5vZGUgfSBmcm9tIFwiLi4vdmFuaWxsYS5qc1wiO1xuZXhwb3J0IGNvbnN0IGhpZ2hsaWdodCA9IChlbGVtZW50LCByZWdleCkgPT4ge1xuICAgIGlmIChyZWdleCA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgIC8vIGNvbnZldCBzdHJpbmcgdG8gcmVnZXhcbiAgICBpZiAodHlwZW9mIHJlZ2V4ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoIXJlZ2V4Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4LCAnaScpO1xuICAgIH1cbiAgICAvLyBXcmFwIG1hdGNoaW5nIHBhcnQgb2YgdGV4dCBub2RlIHdpdGggaGlnaGxpZ2h0aW5nIDxzcGFuPiwgZS5nLlxuICAgIC8vIFNvY2NlciAgLT4gIDxzcGFuIGNsYXNzPVwiaGlnaGxpZ2h0XCI+U29jPC9zcGFuPmNlciAgZm9yIHJlZ2V4ID0gL3NvYy9pXG4gICAgY29uc3QgaGlnaGxpZ2h0VGV4dCA9IChub2RlKSA9PiB7XG4gICAgICAgIHZhciBtYXRjaCA9IG5vZGUuZGF0YS5tYXRjaChyZWdleCk7XG4gICAgICAgIGlmIChtYXRjaCAmJiBub2RlLmRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHNwYW5ub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgc3Bhbm5vZGUuY2xhc3NOYW1lID0gJ2hpZ2hsaWdodCc7XG4gICAgICAgICAgICB2YXIgbWlkZGxlYml0ID0gbm9kZS5zcGxpdFRleHQobWF0Y2guaW5kZXgpO1xuICAgICAgICAgICAgbWlkZGxlYml0LnNwbGl0VGV4dChtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIG1pZGRsZWNsb25lID0gbWlkZGxlYml0LmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgICAgIHNwYW5ub2RlLmFwcGVuZENoaWxkKG1pZGRsZWNsb25lKTtcbiAgICAgICAgICAgIHJlcGxhY2VOb2RlKG1pZGRsZWJpdCwgc3Bhbm5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICAvLyBSZWN1cnNlIGVsZW1lbnQgbm9kZSwgbG9va2luZyBmb3IgY2hpbGQgdGV4dCBub2RlcyB0byBoaWdobGlnaHQsIHVubGVzcyBlbGVtZW50XG4gICAgLy8gaXMgY2hpbGRsZXNzLCA8c2NyaXB0PiwgPHN0eWxlPiwgb3IgYWxyZWFkeSBoaWdobGlnaHRlZDogPHNwYW4gY2xhc3M9XCJoaWdodGxpZ2h0XCI+XG4gICAgY29uc3QgaGlnaGxpZ2h0Q2hpbGRyZW4gPSAobm9kZSkgPT4ge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBub2RlLmNoaWxkTm9kZXMgJiYgIS8oc2NyaXB0fHN0eWxlKS9pLnRlc3Qobm9kZS50YWdOYW1lKSAmJiAobm9kZS5jbGFzc05hbWUgIT09ICdoaWdobGlnaHQnIHx8IG5vZGUudGFnTmFtZSAhPT0gJ1NQQU4nKSkge1xuICAgICAgICAgICAgQXJyYXkuZnJvbShub2RlLmNoaWxkTm9kZXMpLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVjdXJzaXZlKGVsZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGhpZ2hsaWdodFJlY3Vyc2l2ZSA9IChub2RlKSA9PiB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gaGlnaGxpZ2h0VGV4dChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBoaWdobGlnaHRDaGlsZHJlbihub2RlKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBoaWdobGlnaHRSZWN1cnNpdmUoZWxlbWVudCk7XG59O1xuLyoqXG4gKiByZW1vdmVIaWdobGlnaHQgZm4gY29waWVkIGZyb20gaGlnaGxpZ2h0IHY1IGFuZFxuICogZWRpdGVkIHRvIHJlbW92ZSB3aXRoKCksIHBhc3MganMgc3RyaWN0IG1vZGUsIGFuZCB1c2Ugd2l0aG91dCBqcXVlcnlcbiAqL1xuZXhwb3J0IGNvbnN0IHJlbW92ZUhpZ2hsaWdodCA9IChlbCkgPT4ge1xuICAgIHZhciBlbGVtZW50cyA9IGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJzcGFuLmhpZ2hsaWdodFwiKTtcbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGVsZW1lbnRzLCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQoZWwuZmlyc3RDaGlsZCwgZWwpO1xuICAgICAgICBwYXJlbnQubm9ybWFsaXplKCk7XG4gICAgfSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGlnaGxpZ2h0LmpzLm1hcCIsIi8qKlxuICogTWljcm9FdmVudCAtIHRvIG1ha2UgYW55IGpzIG9iamVjdCBhbiBldmVudCBlbWl0dGVyXG4gKlxuICogLSBwdXJlIGphdmFzY3JpcHQgLSBzZXJ2ZXIgY29tcGF0aWJsZSwgYnJvd3NlciBjb21wYXRpYmxlXG4gKiAtIGRvbnQgcmVseSBvbiB0aGUgYnJvd3NlciBkb21zXG4gKiAtIHN1cGVyIHNpbXBsZSAtIHlvdSBnZXQgaXQgaW1tZWRpYXRseSwgbm8gbWlzdGVyeSwgbm8gbWFnaWMgaW52b2x2ZWRcbiAqXG4gKiBAYXV0aG9yIEplcm9tZSBFdGllbm5lIChodHRwczovL2dpdGh1Yi5jb20vamVyb21lZXRpZW5uZSlcbiAqL1xuLyoqXG4gKiBFeGVjdXRlIGNhbGxiYWNrIGZvciBlYWNoIGV2ZW50IGluIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGV2ZW50IG5hbWVzXG4gKlxuICovXG5mdW5jdGlvbiBmb3JFdmVudHMoZXZlbnRzLCBjYWxsYmFjaykge1xuICAgIGV2ZW50cy5zcGxpdCgvXFxzKy8pLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKGV2ZW50KTtcbiAgICB9KTtcbn1cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1pY3JvRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICB9XG4gICAgb24oZXZlbnRzLCBmY3QpIHtcbiAgICAgICAgZm9yRXZlbnRzKGV2ZW50cywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBldmVudF9hcnJheSA9IHRoaXMuX2V2ZW50c1tldmVudF0gfHwgW107XG4gICAgICAgICAgICBldmVudF9hcnJheS5wdXNoKGZjdCk7XG4gICAgICAgICAgICB0aGlzLl9ldmVudHNbZXZlbnRdID0gZXZlbnRfYXJyYXk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvZmYoZXZlbnRzLCBmY3QpIHtcbiAgICAgICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yRXZlbnRzKGV2ZW50cywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAobiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbZXZlbnRdO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV2ZW50X2FycmF5ID0gdGhpcy5fZXZlbnRzW2V2ZW50XTtcbiAgICAgICAgICAgIGlmIChldmVudF9hcnJheSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGV2ZW50X2FycmF5LnNwbGljZShldmVudF9hcnJheS5pbmRleE9mKGZjdCksIDEpO1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50XSA9IGV2ZW50X2FycmF5O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdHJpZ2dlcihldmVudHMsIC4uLmFyZ3MpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBmb3JFdmVudHMoZXZlbnRzLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50X2FycmF5ID0gc2VsZi5fZXZlbnRzW2V2ZW50XTtcbiAgICAgICAgICAgIGlmIChldmVudF9hcnJheSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGV2ZW50X2FycmF5LmZvckVhY2goZmN0ID0+IHtcbiAgICAgICAgICAgICAgICBmY3QuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWljcm9ldmVudC5qcy5tYXAiLCIvKipcbiAqIG1pY3JvcGx1Z2luLmpzXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMgQnJpYW4gUmVhdmlzICYgY29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcbiAqIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBhdXRob3IgQnJpYW4gUmVhdmlzIDxicmlhbkB0aGlyZHJvdXRlLmNvbT5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTWljcm9QbHVnaW4oSW50ZXJmYWNlKSB7XG4gICAgSW50ZXJmYWNlLnBsdWdpbnMgPSB7fTtcbiAgICByZXR1cm4gY2xhc3MgZXh0ZW5kcyBJbnRlcmZhY2Uge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbnMgPSB7XG4gICAgICAgICAgICAgICAgbmFtZXM6IFtdLFxuICAgICAgICAgICAgICAgIHNldHRpbmdzOiB7fSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0ZWQ6IHt9LFxuICAgICAgICAgICAgICAgIGxvYWRlZDoge31cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVycyBhIHBsdWdpbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBkZWZpbmUobmFtZSwgZm4pIHtcbiAgICAgICAgICAgIEludGVyZmFjZS5wbHVnaW5zW25hbWVdID0ge1xuICAgICAgICAgICAgICAgICduYW1lJzogbmFtZSxcbiAgICAgICAgICAgICAgICAnZm4nOiBmblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgdGhlIGxpc3RlZCBwbHVnaW5zICh3aXRoIG9wdGlvbnMpLlxuICAgICAgICAgKiBBY2NlcHRhYmxlIGZvcm1hdHM6XG4gICAgICAgICAqXG4gICAgICAgICAqIExpc3QgKHdpdGhvdXQgb3B0aW9ucyk6XG4gICAgICAgICAqICAgWydhJywgJ2InLCAnYyddXG4gICAgICAgICAqXG4gICAgICAgICAqIExpc3QgKHdpdGggb3B0aW9ucyk6XG4gICAgICAgICAqICAgW3snbmFtZSc6ICdhJywgb3B0aW9uczoge319LCB7J25hbWUnOiAnYicsIG9wdGlvbnM6IHt9fV1cbiAgICAgICAgICpcbiAgICAgICAgICogSGFzaCAod2l0aCBvcHRpb25zKTpcbiAgICAgICAgICogICB7J2EnOiB7IC4uLiB9LCAnYic6IHsgLi4uIH0sICdjJzogeyAuLi4gfX1cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHthcnJheXxvYmplY3R9IHBsdWdpbnNcbiAgICAgICAgICovXG4gICAgICAgIGluaXRpYWxpemVQbHVnaW5zKHBsdWdpbnMpIHtcbiAgICAgICAgICAgIHZhciBrZXksIG5hbWU7XG4gICAgICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHF1ZXVlID0gW107XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwbHVnaW5zKSkge1xuICAgICAgICAgICAgICAgIHBsdWdpbnMuZm9yRWFjaCgocGx1Z2luKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGx1Z2luID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaChwbHVnaW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5wbHVnaW5zLnNldHRpbmdzW3BsdWdpbi5uYW1lXSA9IHBsdWdpbi5vcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaChwbHVnaW4ubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBsdWdpbnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBwbHVnaW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwbHVnaW5zLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucGx1Z2lucy5zZXR0aW5nc1trZXldID0gcGx1Z2luc1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKG5hbWUgPSBxdWV1ZS5zaGlmdCgpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5yZXF1aXJlKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxvYWRQbHVnaW4obmFtZSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHBsdWdpbnMgPSBzZWxmLnBsdWdpbnM7XG4gICAgICAgICAgICB2YXIgcGx1Z2luID0gSW50ZXJmYWNlLnBsdWdpbnNbbmFtZV07XG4gICAgICAgICAgICBpZiAoIUludGVyZmFjZS5wbHVnaW5zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBcIicgKyBuYW1lICsgJ1wiIHBsdWdpbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGx1Z2lucy5yZXF1ZXN0ZWRbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgcGx1Z2lucy5sb2FkZWRbbmFtZV0gPSBwbHVnaW4uZm4uYXBwbHkoc2VsZiwgW3NlbGYucGx1Z2lucy5zZXR0aW5nc1tuYW1lXSB8fCB7fV0pO1xuICAgICAgICAgICAgcGx1Z2lucy5uYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWFsaXplcyBhIHBsdWdpbi5cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHJlcXVpcmUobmFtZSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHBsdWdpbnMgPSBzZWxmLnBsdWdpbnM7XG4gICAgICAgICAgICBpZiAoIXNlbGYucGx1Z2lucy5sb2FkZWQuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2lucy5yZXF1ZXN0ZWRbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbHVnaW4gaGFzIGNpcmN1bGFyIGRlcGVuZGVuY3kgKFwiJyArIG5hbWUgKyAnXCIpJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYubG9hZFBsdWdpbihuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwbHVnaW5zLmxvYWRlZFtuYW1lXTtcbiAgICAgICAgfVxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1taWNyb3BsdWdpbi5qcy5tYXAiLCJleHBvcnQgZGVmYXVsdCB7XG4gICAgb3B0aW9uczogW10sXG4gICAgb3B0Z3JvdXBzOiBbXSxcbiAgICBwbHVnaW5zOiBbXSxcbiAgICBkZWxpbWl0ZXI6ICcsJyxcbiAgICBzcGxpdE9uOiBudWxsLCAvLyByZWdleHAgb3Igc3RyaW5nIGZvciBzcGxpdHRpbmcgdXAgdmFsdWVzIGZyb20gYSBwYXN0ZSBjb21tYW5kXG4gICAgcGVyc2lzdDogdHJ1ZSxcbiAgICBkaWFjcml0aWNzOiB0cnVlLFxuICAgIGNyZWF0ZTogbnVsbCxcbiAgICBjcmVhdGVPbkJsdXI6IGZhbHNlLFxuICAgIGNyZWF0ZUZpbHRlcjogbnVsbCxcbiAgICBoaWdobGlnaHQ6IHRydWUsXG4gICAgb3Blbk9uRm9jdXM6IHRydWUsXG4gICAgc2hvdWxkT3BlbjogbnVsbCxcbiAgICBtYXhPcHRpb25zOiA1MCxcbiAgICBtYXhJdGVtczogbnVsbCxcbiAgICBoaWRlU2VsZWN0ZWQ6IG51bGwsXG4gICAgZHVwbGljYXRlczogZmFsc2UsXG4gICAgYWRkUHJlY2VkZW5jZTogZmFsc2UsXG4gICAgc2VsZWN0T25UYWI6IGZhbHNlLFxuICAgIHByZWxvYWQ6IG51bGwsXG4gICAgYWxsb3dFbXB0eU9wdGlvbjogZmFsc2UsXG4gICAgLy9jbG9zZUFmdGVyU2VsZWN0OiBmYWxzZSxcbiAgICByZWZyZXNoVGhyb3R0bGU6IDMwMCxcbiAgICBsb2FkVGhyb3R0bGU6IDMwMCxcbiAgICBsb2FkaW5nQ2xhc3M6ICdsb2FkaW5nJyxcbiAgICBkYXRhQXR0cjogbnVsbCwgLy8nZGF0YS1kYXRhJyxcbiAgICBvcHRncm91cEZpZWxkOiAnb3B0Z3JvdXAnLFxuICAgIHZhbHVlRmllbGQ6ICd2YWx1ZScsXG4gICAgbGFiZWxGaWVsZDogJ3RleHQnLFxuICAgIGRpc2FibGVkRmllbGQ6ICdkaXNhYmxlZCcsXG4gICAgb3B0Z3JvdXBMYWJlbEZpZWxkOiAnbGFiZWwnLFxuICAgIG9wdGdyb3VwVmFsdWVGaWVsZDogJ3ZhbHVlJyxcbiAgICBsb2NrT3B0Z3JvdXBPcmRlcjogZmFsc2UsXG4gICAgc29ydEZpZWxkOiAnJG9yZGVyJyxcbiAgICBzZWFyY2hGaWVsZDogWyd0ZXh0J10sXG4gICAgc2VhcmNoQ29uanVuY3Rpb246ICdhbmQnLFxuICAgIG1vZGU6IG51bGwsXG4gICAgd3JhcHBlckNsYXNzOiAndHMtd3JhcHBlcicsXG4gICAgY29udHJvbENsYXNzOiAndHMtY29udHJvbCcsXG4gICAgZHJvcGRvd25DbGFzczogJ3RzLWRyb3Bkb3duJyxcbiAgICBkcm9wZG93bkNvbnRlbnRDbGFzczogJ3RzLWRyb3Bkb3duLWNvbnRlbnQnLFxuICAgIGl0ZW1DbGFzczogJ2l0ZW0nLFxuICAgIG9wdGlvbkNsYXNzOiAnb3B0aW9uJyxcbiAgICBkcm9wZG93blBhcmVudDogbnVsbCxcbiAgICBjb250cm9sSW5wdXQ6ICc8aW5wdXQgdHlwZT1cInRleHRcIiBhdXRvY29tcGxldGU9XCJvZmZcIiBzaXplPVwiMVwiIC8+JyxcbiAgICBjb3B5Q2xhc3Nlc1RvRHJvcGRvd246IGZhbHNlLFxuICAgIHBsYWNlaG9sZGVyOiBudWxsLFxuICAgIGhpZGVQbGFjZWhvbGRlcjogbnVsbCxcbiAgICBzaG91bGRMb2FkOiBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIHF1ZXJ5Lmxlbmd0aCA+IDA7XG4gICAgfSxcbiAgICAvKlxuICAgIGxvYWQgICAgICAgICAgICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24ocXVlcnksIGNhbGxiYWNrKSB7IC4uLiB9XG4gICAgc2NvcmUgICAgICAgICAgICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbihzZWFyY2gpIHsgLi4uIH1cbiAgICBvbkluaXRpYWxpemUgICAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgIG9uQ2hhbmdlICAgICAgICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24odmFsdWUpIHsgLi4uIH1cbiAgICBvbkl0ZW1BZGQgICAgICAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKHZhbHVlLCAkaXRlbSkgeyAuLi4gfVxuICAgIG9uSXRlbVJlbW92ZSAgICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24odmFsdWUpIHsgLi4uIH1cbiAgICBvbkNsZWFyICAgICAgICAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgIG9uT3B0aW9uQWRkICAgICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24odmFsdWUsIGRhdGEpIHsgLi4uIH1cbiAgICBvbk9wdGlvblJlbW92ZSAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKHZhbHVlKSB7IC4uLiB9XG4gICAgb25PcHRpb25DbGVhciAgICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICBvbk9wdGlvbkdyb3VwQWRkICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKGlkLCBkYXRhKSB7IC4uLiB9XG4gICAgb25PcHRpb25Hcm91cFJlbW92ZSAgOiBudWxsLCAvLyBmdW5jdGlvbihpZCkgeyAuLi4gfVxuICAgIG9uT3B0aW9uR3JvdXBDbGVhciAgIDogbnVsbCwgLy8gZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAgb25Ecm9wZG93bk9wZW4gICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbihkcm9wZG93bikgeyAuLi4gfVxuICAgIG9uRHJvcGRvd25DbG9zZSAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24oZHJvcGRvd24pIHsgLi4uIH1cbiAgICBvblR5cGUgICAgICAgICAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKHN0cikgeyAuLi4gfVxuICAgIG9uRGVsZXRlICAgICAgICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24odmFsdWVzKSB7IC4uLiB9XG4gICAgKi9cbiAgICByZW5kZXI6IHtcbiAgICAvKlxuICAgIGl0ZW06IG51bGwsXG4gICAgb3B0Z3JvdXA6IG51bGwsXG4gICAgb3B0Z3JvdXBfaGVhZGVyOiBudWxsLFxuICAgIG9wdGlvbjogbnVsbCxcbiAgICBvcHRpb25fY3JlYXRlOiBudWxsXG4gICAgKi9cbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdHMuanMubWFwIiwiaW1wb3J0IGRlZmF1bHRzIGZyb20gXCIuL2RlZmF1bHRzLmpzXCI7XG5pbXBvcnQgeyBoYXNoX2tleSwgaXRlcmF0ZSB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTZXR0aW5ncyhpbnB1dCwgc2V0dGluZ3NfdXNlcikge1xuICAgIHZhciBzZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCBzZXR0aW5nc191c2VyKTtcbiAgICB2YXIgYXR0cl9kYXRhID0gc2V0dGluZ3MuZGF0YUF0dHI7XG4gICAgdmFyIGZpZWxkX2xhYmVsID0gc2V0dGluZ3MubGFiZWxGaWVsZDtcbiAgICB2YXIgZmllbGRfdmFsdWUgPSBzZXR0aW5ncy52YWx1ZUZpZWxkO1xuICAgIHZhciBmaWVsZF9kaXNhYmxlZCA9IHNldHRpbmdzLmRpc2FibGVkRmllbGQ7XG4gICAgdmFyIGZpZWxkX29wdGdyb3VwID0gc2V0dGluZ3Mub3B0Z3JvdXBGaWVsZDtcbiAgICB2YXIgZmllbGRfb3B0Z3JvdXBfbGFiZWwgPSBzZXR0aW5ncy5vcHRncm91cExhYmVsRmllbGQ7XG4gICAgdmFyIGZpZWxkX29wdGdyb3VwX3ZhbHVlID0gc2V0dGluZ3Mub3B0Z3JvdXBWYWx1ZUZpZWxkO1xuICAgIHZhciB0YWdfbmFtZSA9IGlucHV0LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgcGxhY2Vob2xkZXIgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJykgfHwgaW5wdXQuZ2V0QXR0cmlidXRlKCdkYXRhLXBsYWNlaG9sZGVyJyk7XG4gICAgaWYgKCFwbGFjZWhvbGRlciAmJiAhc2V0dGluZ3MuYWxsb3dFbXB0eU9wdGlvbikge1xuICAgICAgICBsZXQgb3B0aW9uID0gaW5wdXQucXVlcnlTZWxlY3Rvcignb3B0aW9uW3ZhbHVlPVwiXCJdJyk7XG4gICAgICAgIGlmIChvcHRpb24pIHtcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyID0gb3B0aW9uLnRleHRDb250ZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBzZXR0aW5nc19lbGVtZW50ID0ge1xuICAgICAgICBwbGFjZWhvbGRlcjogcGxhY2Vob2xkZXIsXG4gICAgICAgIG9wdGlvbnM6IFtdLFxuICAgICAgICBvcHRncm91cHM6IFtdLFxuICAgICAgICBpdGVtczogW10sXG4gICAgICAgIG1heEl0ZW1zOiBudWxsLFxuICAgIH07XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBmcm9tIGEgPHNlbGVjdD4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqL1xuICAgIHZhciBpbml0X3NlbGVjdCA9ICgpID0+IHtcbiAgICAgICAgdmFyIHRhZ05hbWU7XG4gICAgICAgIHZhciBvcHRpb25zID0gc2V0dGluZ3NfZWxlbWVudC5vcHRpb25zO1xuICAgICAgICB2YXIgb3B0aW9uc01hcCA9IHt9O1xuICAgICAgICB2YXIgZ3JvdXBfY291bnQgPSAxO1xuICAgICAgICBsZXQgJG9yZGVyID0gMDtcbiAgICAgICAgdmFyIHJlYWREYXRhID0gKGVsKSA9PiB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIGVsLmRhdGFzZXQpOyAvLyBnZXQgcGxhaW4gb2JqZWN0IGZyb20gRE9NU3RyaW5nTWFwXG4gICAgICAgICAgICB2YXIganNvbiA9IGF0dHJfZGF0YSAmJiBkYXRhW2F0dHJfZGF0YV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gPT09ICdzdHJpbmcnICYmIGpzb24ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IE9iamVjdC5hc3NpZ24oZGF0YSwgSlNPTi5wYXJzZShqc29uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGFkZE9wdGlvbiA9IChvcHRpb24sIGdyb3VwKSA9PiB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBoYXNoX2tleShvcHRpb24udmFsdWUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSAmJiAhc2V0dGluZ3MuYWxsb3dFbXB0eU9wdGlvbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBpZiB0aGUgb3B0aW9uIGFscmVhZHkgZXhpc3RzLCBpdCdzIHByb2JhYmx5IGJlZW5cbiAgICAgICAgICAgIC8vIGR1cGxpY2F0ZWQgaW4gYW5vdGhlciBvcHRncm91cC4gaW4gdGhpcyBjYXNlLCBwdXNoXG4gICAgICAgICAgICAvLyB0aGUgY3VycmVudCBncm91cCB0byB0aGUgXCJvcHRncm91cFwiIHByb3BlcnR5IG9uIHRoZVxuICAgICAgICAgICAgLy8gZXhpc3Rpbmcgb3B0aW9uIHNvIHRoYXQgaXQncyByZW5kZXJlZCBpbiBib3RoIHBsYWNlcy5cbiAgICAgICAgICAgIGlmIChvcHRpb25zTWFwLmhhc093blByb3BlcnR5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmIChncm91cCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJyID0gb3B0aW9uc01hcFt2YWx1ZV1bZmllbGRfb3B0Z3JvdXBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc01hcFt2YWx1ZV1bZmllbGRfb3B0Z3JvdXBdID0gZ3JvdXA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc01hcFt2YWx1ZV1bZmllbGRfb3B0Z3JvdXBdID0gW2FyciwgZ3JvdXBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2goZ3JvdXApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbl9kYXRhID0gcmVhZERhdGEob3B0aW9uKTtcbiAgICAgICAgICAgICAgICBvcHRpb25fZGF0YVtmaWVsZF9sYWJlbF0gPSBvcHRpb25fZGF0YVtmaWVsZF9sYWJlbF0gfHwgb3B0aW9uLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgIG9wdGlvbl9kYXRhW2ZpZWxkX3ZhbHVlXSA9IG9wdGlvbl9kYXRhW2ZpZWxkX3ZhbHVlXSB8fCB2YWx1ZTtcbiAgICAgICAgICAgICAgICBvcHRpb25fZGF0YVtmaWVsZF9kaXNhYmxlZF0gPSBvcHRpb25fZGF0YVtmaWVsZF9kaXNhYmxlZF0gfHwgb3B0aW9uLmRpc2FibGVkO1xuICAgICAgICAgICAgICAgIG9wdGlvbl9kYXRhW2ZpZWxkX29wdGdyb3VwXSA9IG9wdGlvbl9kYXRhW2ZpZWxkX29wdGdyb3VwXSB8fCBncm91cDtcbiAgICAgICAgICAgICAgICBvcHRpb25fZGF0YS4kb3B0aW9uID0gb3B0aW9uO1xuICAgICAgICAgICAgICAgIG9wdGlvbl9kYXRhLiRvcmRlciA9IG9wdGlvbl9kYXRhLiRvcmRlciB8fCArKyRvcmRlcjtcbiAgICAgICAgICAgICAgICBvcHRpb25zTWFwW3ZhbHVlXSA9IG9wdGlvbl9kYXRhO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucHVzaChvcHRpb25fZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9uLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3NfZWxlbWVudC5pdGVtcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGFkZEdyb3VwID0gKG9wdGdyb3VwKSA9PiB7XG4gICAgICAgICAgICB2YXIgaWQsIG9wdGdyb3VwX2RhdGE7XG4gICAgICAgICAgICBvcHRncm91cF9kYXRhID0gcmVhZERhdGEob3B0Z3JvdXApO1xuICAgICAgICAgICAgb3B0Z3JvdXBfZGF0YVtmaWVsZF9vcHRncm91cF9sYWJlbF0gPSBvcHRncm91cF9kYXRhW2ZpZWxkX29wdGdyb3VwX2xhYmVsXSB8fCBvcHRncm91cC5nZXRBdHRyaWJ1dGUoJ2xhYmVsJykgfHwgJyc7XG4gICAgICAgICAgICBvcHRncm91cF9kYXRhW2ZpZWxkX29wdGdyb3VwX3ZhbHVlXSA9IG9wdGdyb3VwX2RhdGFbZmllbGRfb3B0Z3JvdXBfdmFsdWVdIHx8IGdyb3VwX2NvdW50Kys7XG4gICAgICAgICAgICBvcHRncm91cF9kYXRhW2ZpZWxkX2Rpc2FibGVkXSA9IG9wdGdyb3VwX2RhdGFbZmllbGRfZGlzYWJsZWRdIHx8IG9wdGdyb3VwLmRpc2FibGVkO1xuICAgICAgICAgICAgb3B0Z3JvdXBfZGF0YS4kb3JkZXIgPSBvcHRncm91cF9kYXRhLiRvcmRlciB8fCArKyRvcmRlcjtcbiAgICAgICAgICAgIHNldHRpbmdzX2VsZW1lbnQub3B0Z3JvdXBzLnB1c2gob3B0Z3JvdXBfZGF0YSk7XG4gICAgICAgICAgICBpZCA9IG9wdGdyb3VwX2RhdGFbZmllbGRfb3B0Z3JvdXBfdmFsdWVdO1xuICAgICAgICAgICAgaXRlcmF0ZShvcHRncm91cC5jaGlsZHJlbiwgKG9wdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGFkZE9wdGlvbihvcHRpb24sIGlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBzZXR0aW5nc19lbGVtZW50Lm1heEl0ZW1zID0gaW5wdXQuaGFzQXR0cmlidXRlKCdtdWx0aXBsZScpID8gbnVsbCA6IDE7XG4gICAgICAgIGl0ZXJhdGUoaW5wdXQuY2hpbGRyZW4sIChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgdGFnTmFtZSA9IGNoaWxkLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmICh0YWdOYW1lID09PSAnb3B0Z3JvdXAnKSB7XG4gICAgICAgICAgICAgICAgYWRkR3JvdXAoY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGFnTmFtZSA9PT0gJ29wdGlvbicpIHtcbiAgICAgICAgICAgICAgICBhZGRPcHRpb24oY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgZnJvbSBhIDxpbnB1dCB0eXBlPVwidGV4dFwiPiBlbGVtZW50LlxuICAgICAqXG4gICAgICovXG4gICAgdmFyIGluaXRfdGV4dGJveCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YV9yYXcgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoYXR0cl9kYXRhKTtcbiAgICAgICAgaWYgKCFkYXRhX3Jhdykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gaW5wdXQudmFsdWUudHJpbSgpIHx8ICcnO1xuICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5hbGxvd0VtcHR5T3B0aW9uICYmICF2YWx1ZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gdmFsdWUuc3BsaXQoc2V0dGluZ3MuZGVsaW1pdGVyKTtcbiAgICAgICAgICAgIGl0ZXJhdGUodmFsdWVzLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb24gPSB7fTtcbiAgICAgICAgICAgICAgICBvcHRpb25bZmllbGRfbGFiZWxdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgb3B0aW9uW2ZpZWxkX3ZhbHVlXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHNldHRpbmdzX2VsZW1lbnQub3B0aW9ucy5wdXNoKG9wdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNldHRpbmdzX2VsZW1lbnQuaXRlbXMgPSB2YWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXR0aW5nc19lbGVtZW50Lm9wdGlvbnMgPSBKU09OLnBhcnNlKGRhdGFfcmF3KTtcbiAgICAgICAgICAgIGl0ZXJhdGUoc2V0dGluZ3NfZWxlbWVudC5vcHRpb25zLCAob3B0KSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3NfZWxlbWVudC5pdGVtcy5wdXNoKG9wdFtmaWVsZF92YWx1ZV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGlmICh0YWdfbmFtZSA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgaW5pdF9zZWxlY3QoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGluaXRfdGV4dGJveCgpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMsIHNldHRpbmdzX2VsZW1lbnQsIHNldHRpbmdzX3VzZXIpO1xufVxuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0U2V0dGluZ3MuanMubWFwIiwiLyoqXG4qIFRvbSBTZWxlY3QgdjIuNC4zXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qL1xuXG4vKipcbiAqIENvbnZlcnRzIGEgc2NhbGFyIHRvIGl0cyBiZXN0IHN0cmluZyByZXByZXNlbnRhdGlvblxuICogZm9yIGhhc2gga2V5cyBhbmQgSFRNTCBhdHRyaWJ1dGUgdmFsdWVzLlxuICpcbiAqIFRyYW5zZm9ybWF0aW9uczpcbiAqICAgJ3N0cicgICAgIC0+ICdzdHInXG4gKiAgIG51bGwgICAgICAtPiAnJ1xuICogICB1bmRlZmluZWQgLT4gJydcbiAqICAgdHJ1ZSAgICAgIC0+ICcxJ1xuICogICBmYWxzZSAgICAgLT4gJzAnXG4gKiAgIDAgICAgICAgICAtPiAnMCdcbiAqICAgMSAgICAgICAgIC0+ICcxJ1xuICpcbiAqL1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgYXJyYXlzIGFuZCBoYXNoZXMuXG4gKlxuICogYGBgXG4gKiBpdGVyYXRlKHRoaXMuaXRlbXMsIGZ1bmN0aW9uKGl0ZW0sIGlkKSB7XG4gKiAgICAvLyBpbnZva2VkIGZvciBlYWNoIGl0ZW1cbiAqIH0pO1xuICogYGBgXG4gKlxuICovXG5jb25zdCBpdGVyYXRlID0gKG9iamVjdCwgY2FsbGJhY2spID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgIG9iamVjdC5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgY2FsbGJhY2sob2JqZWN0W2tleV0sIGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBjc3MgY2xhc3Nlc1xuICpcbiAqL1xuY29uc3QgcmVtb3ZlQ2xhc3NlcyA9IChlbG10cywgLi4uY2xhc3NlcykgPT4ge1xuICB2YXIgbm9ybV9jbGFzc2VzID0gY2xhc3Nlc0FycmF5KGNsYXNzZXMpO1xuICBlbG10cyA9IGNhc3RBc0FycmF5KGVsbXRzKTtcbiAgZWxtdHMubWFwKGVsID0+IHtcbiAgICBub3JtX2NsYXNzZXMubWFwKGNscyA9PiB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYXJndW1lbnRzXG4gKlxuICovXG5jb25zdCBjbGFzc2VzQXJyYXkgPSBhcmdzID0+IHtcbiAgdmFyIGNsYXNzZXMgPSBbXTtcbiAgaXRlcmF0ZShhcmdzLCBfY2xhc3NlcyA9PiB7XG4gICAgaWYgKHR5cGVvZiBfY2xhc3NlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIF9jbGFzc2VzID0gX2NsYXNzZXMudHJpbSgpLnNwbGl0KC9bXFx0XFxuXFxmXFxyXFxzXS8pO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShfY2xhc3NlcykpIHtcbiAgICAgIGNsYXNzZXMgPSBjbGFzc2VzLmNvbmNhdChfY2xhc3Nlcyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNsYXNzZXMuZmlsdGVyKEJvb2xlYW4pO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gYXJyYXkgZnJvbSBhcmcgaWYgaXQncyBub3QgYWxyZWFkeSBhbiBhcnJheVxuICpcbiAqL1xuY29uc3QgY2FzdEFzQXJyYXkgPSBhcmcgPT4ge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgIGFyZyA9IFthcmddO1xuICB9XG4gIHJldHVybiBhcmc7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgaW5kZXggb2YgYW4gZWxlbWVudCBhbW9uZ3N0IHNpYmxpbmcgbm9kZXMgb2YgdGhlIHNhbWUgdHlwZVxuICpcbiAqL1xuY29uc3Qgbm9kZUluZGV4ID0gKGVsLCBhbW9uZ3N0KSA9PiB7XG4gIGlmICghZWwpIHJldHVybiAtMTtcbiAgYW1vbmdzdCA9IGFtb25nc3QgfHwgZWwubm9kZU5hbWU7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKGVsID0gZWwucHJldmlvdXNFbGVtZW50U2libGluZykge1xuICAgIGlmIChlbC5tYXRjaGVzKGFtb25nc3QpKSB7XG4gICAgICBpKys7XG4gICAgfVxuICB9XG4gIHJldHVybiBpO1xufTtcblxuLyoqXG4gKiBQbHVnaW46IFwiZHJvcGRvd25faW5wdXRcIiAoVG9tIFNlbGVjdClcbiAqIENvcHlyaWdodCAoYykgY29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcbiAqIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBwbHVnaW4gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLyoqXG4gICAqIE1vdmVzIHRoZSBjYXJldCB0byB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgKlxuICAgKiBUaGUgaW5wdXQgbXVzdCBiZSBtb3ZlZCBieSBsZWF2aW5nIGl0IGluIHBsYWNlIGFuZCBtb3ZpbmcgdGhlXG4gICAqIHNpYmxpbmdzLCBkdWUgdG8gdGhlIGZhY3QgdGhhdCBmb2N1cyBjYW5ub3QgYmUgcmVzdG9yZWQgb25jZSBsb3N0XG4gICAqIG9uIG1vYmlsZSB3ZWJraXQgZGV2aWNlc1xuICAgKlxuICAgKi9cbiAgc2VsZi5ob29rKCdpbnN0ZWFkJywgJ3NldENhcmV0JywgbmV3X3BvcyA9PiB7XG4gICAgaWYgKHNlbGYuc2V0dGluZ3MubW9kZSA9PT0gJ3NpbmdsZScgfHwgIXNlbGYuY29udHJvbC5jb250YWlucyhzZWxmLmNvbnRyb2xfaW5wdXQpKSB7XG4gICAgICBuZXdfcG9zID0gc2VsZi5pdGVtcy5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld19wb3MgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzZWxmLml0ZW1zLmxlbmd0aCwgbmV3X3BvcykpO1xuICAgICAgaWYgKG5ld19wb3MgIT0gc2VsZi5jYXJldFBvcyAmJiAhc2VsZi5pc1BlbmRpbmcpIHtcbiAgICAgICAgc2VsZi5jb250cm9sQ2hpbGRyZW4oKS5mb3JFYWNoKChjaGlsZCwgaikgPT4ge1xuICAgICAgICAgIGlmIChqIDwgbmV3X3Bvcykge1xuICAgICAgICAgICAgc2VsZi5jb250cm9sX2lucHV0Lmluc2VydEFkamFjZW50RWxlbWVudCgnYmVmb3JlYmVnaW4nLCBjaGlsZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuY29udHJvbC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZi5jYXJldFBvcyA9IG5ld19wb3M7XG4gIH0pO1xuICBzZWxmLmhvb2soJ2luc3RlYWQnLCAnbW92ZUNhcmV0JywgZGlyZWN0aW9uID0+IHtcbiAgICBpZiAoIXNlbGYuaXNGb2N1c2VkKSByZXR1cm47XG5cbiAgICAvLyBtb3ZlIGNhcmV0IGJlZm9yZSBvciBhZnRlciBzZWxlY3RlZCBpdGVtc1xuICAgIGNvbnN0IGxhc3RfYWN0aXZlID0gc2VsZi5nZXRMYXN0QWN0aXZlKGRpcmVjdGlvbik7XG4gICAgaWYgKGxhc3RfYWN0aXZlKSB7XG4gICAgICBjb25zdCBpZHggPSBub2RlSW5kZXgobGFzdF9hY3RpdmUpO1xuICAgICAgc2VsZi5zZXRDYXJldChkaXJlY3Rpb24gPiAwID8gaWR4ICsgMSA6IGlkeCk7XG4gICAgICBzZWxmLnNldEFjdGl2ZUl0ZW0oKTtcbiAgICAgIHJlbW92ZUNsYXNzZXMobGFzdF9hY3RpdmUsICdsYXN0LWFjdGl2ZScpO1xuXG4gICAgICAvLyBtb3ZlIGNhcmV0IGxlZnQgb3IgcmlnaHQgb2YgY3VycmVudCBwb3NpdGlvblxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLnNldENhcmV0KHNlbGYuY2FyZXRQb3MgKyBkaXJlY3Rpb24pO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCB7IHBsdWdpbiBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbHVnaW4uanMubWFwXG4iLCIvKipcbiogVG9tIFNlbGVjdCB2Mi40LjNcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiovXG5cbi8qKlxuICogQ29udmVydHMgYSBzY2FsYXIgdG8gaXRzIGJlc3Qgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gKiBmb3IgaGFzaCBrZXlzIGFuZCBIVE1MIGF0dHJpYnV0ZSB2YWx1ZXMuXG4gKlxuICogVHJhbnNmb3JtYXRpb25zOlxuICogICAnc3RyJyAgICAgLT4gJ3N0cidcbiAqICAgbnVsbCAgICAgIC0+ICcnXG4gKiAgIHVuZGVmaW5lZCAtPiAnJ1xuICogICB0cnVlICAgICAgLT4gJzEnXG4gKiAgIGZhbHNlICAgICAtPiAnMCdcbiAqICAgMCAgICAgICAgIC0+ICcwJ1xuICogICAxICAgICAgICAgLT4gJzEnXG4gKlxuICovXG5cbi8qKlxuICogQWRkIGV2ZW50IGhlbHBlclxuICpcbiAqL1xuY29uc3QgYWRkRXZlbnQgPSAodGFyZ2V0LCB0eXBlLCBjYWxsYmFjaywgb3B0aW9ucykgPT4ge1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFBsdWdpbjogXCJjaGFuZ2VfbGlzdGVuZXJcIiAoVG9tIFNlbGVjdClcbiAqIENvcHlyaWdodCAoYykgY29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcbiAqIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBwbHVnaW4gKCkge1xuICBhZGRFdmVudCh0aGlzLmlucHV0LCAnY2hhbmdlJywgKCkgPT4ge1xuICAgIHRoaXMuc3luYygpO1xuICB9KTtcbn1cblxuZXhwb3J0IHsgcGx1Z2luIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsdWdpbi5qcy5tYXBcbiIsIi8qKlxuKiBUb20gU2VsZWN0IHYyLjQuM1xuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKi9cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHNjYWxhciB0byBpdHMgYmVzdCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAqIGZvciBoYXNoIGtleXMgYW5kIEhUTUwgYXR0cmlidXRlIHZhbHVlcy5cbiAqXG4gKiBUcmFuc2Zvcm1hdGlvbnM6XG4gKiAgICdzdHInICAgICAtPiAnc3RyJ1xuICogICBudWxsICAgICAgLT4gJydcbiAqICAgdW5kZWZpbmVkIC0+ICcnXG4gKiAgIHRydWUgICAgICAtPiAnMSdcbiAqICAgZmFsc2UgICAgIC0+ICcwJ1xuICogICAwICAgICAgICAgLT4gJzAnXG4gKiAgIDEgICAgICAgICAtPiAnMSdcbiAqXG4gKi9cbmNvbnN0IGhhc2hfa2V5ID0gdmFsdWUgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fCB2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIHJldHVybiBnZXRfaGFzaCh2YWx1ZSk7XG59O1xuY29uc3QgZ2V0X2hhc2ggPSB2YWx1ZSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykgcmV0dXJuIHZhbHVlID8gJzEnIDogJzAnO1xuICByZXR1cm4gdmFsdWUgKyAnJztcbn07XG5cbi8qKlxuICogUHJldmVudCBkZWZhdWx0XG4gKlxuICovXG5jb25zdCBwcmV2ZW50RGVmYXVsdCA9IChldnQsIHN0b3AgPSBmYWxzZSkgPT4ge1xuICBpZiAoZXZ0KSB7XG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKHN0b3ApIHtcbiAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJuIGEgZG9tIGVsZW1lbnQgZnJvbSBlaXRoZXIgYSBkb20gcXVlcnkgc3RyaW5nLCBqUXVlcnkgb2JqZWN0LCBhIGRvbSBlbGVtZW50IG9yIGh0bWwgc3RyaW5nXG4gKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80OTQxNDMvY3JlYXRpbmctYS1uZXctZG9tLWVsZW1lbnQtZnJvbS1hbi1odG1sLXN0cmluZy11c2luZy1idWlsdC1pbi1kb20tbWV0aG9kcy1vci1wcm8vMzUzODU1MTgjMzUzODU1MThcbiAqXG4gKiBwYXJhbSBxdWVyeSBzaG91bGQgYmUge31cbiAqL1xuY29uc3QgZ2V0RG9tID0gcXVlcnkgPT4ge1xuICBpZiAocXVlcnkuanF1ZXJ5KSB7XG4gICAgcmV0dXJuIHF1ZXJ5WzBdO1xuICB9XG4gIGlmIChxdWVyeSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgcmV0dXJuIHF1ZXJ5O1xuICB9XG4gIGlmIChpc0h0bWxTdHJpbmcocXVlcnkpKSB7XG4gICAgdmFyIHRwbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgdHBsLmlubmVySFRNTCA9IHF1ZXJ5LnRyaW0oKTsgLy8gTmV2ZXIgcmV0dXJuIGEgdGV4dCBub2RlIG9mIHdoaXRlc3BhY2UgYXMgdGhlIHJlc3VsdFxuICAgIHJldHVybiB0cGwuY29udGVudC5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHF1ZXJ5KTtcbn07XG5jb25zdCBpc0h0bWxTdHJpbmcgPSBhcmcgPT4ge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgJiYgYXJnLmluZGV4T2YoJzwnKSA+IC0xKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBQbHVnaW46IFwiY2hlY2tib3hfb3B0aW9uc1wiIChUb20gU2VsZWN0KVxuICogQ29weXJpZ2h0IChjKSBjb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuICogZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GXG4gKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbmZ1bmN0aW9uIHBsdWdpbiAodXNlck9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgb3JpZ19vbk9wdGlvblNlbGVjdCA9IHNlbGYub25PcHRpb25TZWxlY3Q7XG4gIHNlbGYuc2V0dGluZ3MuaGlkZVNlbGVjdGVkID0gZmFsc2U7XG4gIGNvbnN0IGNiT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIC8vIHNvIHRoYXQgdGhlIHVzZXIgbWF5IGFkZCBkaWZmZXJlbnQgb25lcyBhcyB3ZWxsXG4gICAgY2xhc3NOYW1lOiBcInRvbXNlbGVjdC1jaGVja2JveFwiLFxuICAgIC8vIHRoZSBmb2xsb3dpbmcgZGVmYXVsdCB0byB0aGUgaGlzdG9yaWMgcGx1Z2luJ3MgdmFsdWVzXG4gICAgY2hlY2tlZENsYXNzTmFtZXM6IHVuZGVmaW5lZCxcbiAgICB1bmNoZWNrZWRDbGFzc05hbWVzOiB1bmRlZmluZWRcbiAgfSwgdXNlck9wdGlvbnMpO1xuICB2YXIgVXBkYXRlQ2hlY2tlZCA9IGZ1bmN0aW9uIFVwZGF0ZUNoZWNrZWQoY2hlY2tib3gsIHRvQ2hlY2spIHtcbiAgICBpZiAodG9DaGVjaykge1xuICAgICAgY2hlY2tib3guY2hlY2tlZCA9IHRydWU7XG4gICAgICBpZiAoY2JPcHRpb25zLnVuY2hlY2tlZENsYXNzTmFtZXMpIHtcbiAgICAgICAgY2hlY2tib3guY2xhc3NMaXN0LnJlbW92ZSguLi5jYk9wdGlvbnMudW5jaGVja2VkQ2xhc3NOYW1lcyk7XG4gICAgICB9XG4gICAgICBpZiAoY2JPcHRpb25zLmNoZWNrZWRDbGFzc05hbWVzKSB7XG4gICAgICAgIGNoZWNrYm94LmNsYXNzTGlzdC5hZGQoLi4uY2JPcHRpb25zLmNoZWNrZWRDbGFzc05hbWVzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2hlY2tib3guY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgaWYgKGNiT3B0aW9ucy5jaGVja2VkQ2xhc3NOYW1lcykge1xuICAgICAgICBjaGVja2JveC5jbGFzc0xpc3QucmVtb3ZlKC4uLmNiT3B0aW9ucy5jaGVja2VkQ2xhc3NOYW1lcyk7XG4gICAgICB9XG4gICAgICBpZiAoY2JPcHRpb25zLnVuY2hlY2tlZENsYXNzTmFtZXMpIHtcbiAgICAgICAgY2hlY2tib3guY2xhc3NMaXN0LmFkZCguLi5jYk9wdGlvbnMudW5jaGVja2VkQ2xhc3NOYW1lcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIHVwZGF0ZSB0aGUgY2hlY2tib3ggZm9yIGFuIG9wdGlvblxuICB2YXIgVXBkYXRlQ2hlY2tib3ggPSBmdW5jdGlvbiBVcGRhdGVDaGVja2JveChvcHRpb24pIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHZhciBjaGVja2JveCA9IG9wdGlvbi5xdWVyeVNlbGVjdG9yKCdpbnB1dC4nICsgY2JPcHRpb25zLmNsYXNzTmFtZSk7XG4gICAgICBpZiAoY2hlY2tib3ggaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgICAgIFVwZGF0ZUNoZWNrZWQoY2hlY2tib3gsIG9wdGlvbi5jbGFzc0xpc3QuY29udGFpbnMoJ3NlbGVjdGVkJykpO1xuICAgICAgfVxuICAgIH0sIDEpO1xuICB9O1xuXG4gIC8vIGFkZCBjaGVja2JveCB0byBvcHRpb24gdGVtcGxhdGVcbiAgc2VsZi5ob29rKCdhZnRlcicsICdzZXR1cFRlbXBsYXRlcycsICgpID0+IHtcbiAgICB2YXIgb3JpZ19yZW5kZXJfb3B0aW9uID0gc2VsZi5zZXR0aW5ncy5yZW5kZXIub3B0aW9uO1xuICAgIHNlbGYuc2V0dGluZ3MucmVuZGVyLm9wdGlvbiA9IChkYXRhLCBlc2NhcGVfaHRtbCkgPT4ge1xuICAgICAgdmFyIHJlbmRlcmVkID0gZ2V0RG9tKG9yaWdfcmVuZGVyX29wdGlvbi5jYWxsKHNlbGYsIGRhdGEsIGVzY2FwZV9odG1sKSk7XG4gICAgICB2YXIgY2hlY2tib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgaWYgKGNiT3B0aW9ucy5jbGFzc05hbWUpIHtcbiAgICAgICAgY2hlY2tib3guY2xhc3NMaXN0LmFkZChjYk9wdGlvbnMuY2xhc3NOYW1lKTtcbiAgICAgIH1cbiAgICAgIGNoZWNrYm94LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBwcmV2ZW50RGVmYXVsdChldnQpO1xuICAgICAgfSk7XG4gICAgICBjaGVja2JveC50eXBlID0gJ2NoZWNrYm94JztcbiAgICAgIGNvbnN0IGhhc2hlZCA9IGhhc2hfa2V5KGRhdGFbc2VsZi5zZXR0aW5ncy52YWx1ZUZpZWxkXSk7XG4gICAgICBVcGRhdGVDaGVja2VkKGNoZWNrYm94LCAhIShoYXNoZWQgJiYgc2VsZi5pdGVtcy5pbmRleE9mKGhhc2hlZCkgPiAtMSkpO1xuICAgICAgcmVuZGVyZWQucHJlcGVuZChjaGVja2JveCk7XG4gICAgICByZXR1cm4gcmVuZGVyZWQ7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gdW5jaGVjayB3aGVuIGl0ZW0gcmVtb3ZlZFxuICBzZWxmLm9uKCdpdGVtX3JlbW92ZScsIHZhbHVlID0+IHtcbiAgICB2YXIgb3B0aW9uID0gc2VsZi5nZXRPcHRpb24odmFsdWUpO1xuICAgIGlmIChvcHRpb24pIHtcbiAgICAgIC8vIGlmIGRyb3Bkb3duIGhhc24ndCBiZWVuIG9wZW5lZCB5ZXQsIHRoZSBvcHRpb24gd29uJ3QgZXhpc3RcbiAgICAgIG9wdGlvbi5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpOyAvLyBzZWxlY3RlZCBjbGFzcyB3b24ndCBiZSByZW1vdmVkIHlldFxuICAgICAgVXBkYXRlQ2hlY2tib3gob3B0aW9uKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGNoZWNrIHdoZW4gaXRlbSBhZGRlZFxuICBzZWxmLm9uKCdpdGVtX2FkZCcsIHZhbHVlID0+IHtcbiAgICB2YXIgb3B0aW9uID0gc2VsZi5nZXRPcHRpb24odmFsdWUpO1xuICAgIGlmIChvcHRpb24pIHtcbiAgICAgIC8vIGlmIGRyb3Bkb3duIGhhc24ndCBiZWVuIG9wZW5lZCB5ZXQsIHRoZSBvcHRpb24gd29uJ3QgZXhpc3RcbiAgICAgIFVwZGF0ZUNoZWNrYm94KG9wdGlvbik7XG4gICAgfVxuICB9KTtcblxuICAvLyByZW1vdmUgaXRlbXMgd2hlbiBzZWxlY3RlZCBvcHRpb24gaXMgY2xpY2tlZFxuICBzZWxmLmhvb2soJ2luc3RlYWQnLCAnb25PcHRpb25TZWxlY3QnLCAoZXZ0LCBvcHRpb24pID0+IHtcbiAgICBpZiAob3B0aW9uLmNsYXNzTGlzdC5jb250YWlucygnc2VsZWN0ZWQnKSkge1xuICAgICAgb3B0aW9uLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJyk7XG4gICAgICBzZWxmLnJlbW92ZUl0ZW0ob3B0aW9uLmRhdGFzZXQudmFsdWUpO1xuICAgICAgc2VsZi5yZWZyZXNoT3B0aW9ucygpO1xuICAgICAgcHJldmVudERlZmF1bHQoZXZ0LCB0cnVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb3JpZ19vbk9wdGlvblNlbGVjdC5jYWxsKHNlbGYsIGV2dCwgb3B0aW9uKTtcbiAgICBVcGRhdGVDaGVja2JveChvcHRpb24pO1xuICB9KTtcbn1cblxuZXhwb3J0IHsgcGx1Z2luIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsdWdpbi5qcy5tYXBcbiIsIi8qKlxuKiBUb20gU2VsZWN0IHYyLjQuM1xuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKi9cblxuLyoqXG4gKiBSZXR1cm4gYSBkb20gZWxlbWVudCBmcm9tIGVpdGhlciBhIGRvbSBxdWVyeSBzdHJpbmcsIGpRdWVyeSBvYmplY3QsIGEgZG9tIGVsZW1lbnQgb3IgaHRtbCBzdHJpbmdcbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ5NDE0My9jcmVhdGluZy1hLW5ldy1kb20tZWxlbWVudC1mcm9tLWFuLWh0bWwtc3RyaW5nLXVzaW5nLWJ1aWx0LWluLWRvbS1tZXRob2RzLW9yLXByby8zNTM4NTUxOCMzNTM4NTUxOFxuICpcbiAqIHBhcmFtIHF1ZXJ5IHNob3VsZCBiZSB7fVxuICovXG5jb25zdCBnZXREb20gPSBxdWVyeSA9PiB7XG4gIGlmIChxdWVyeS5qcXVlcnkpIHtcbiAgICByZXR1cm4gcXVlcnlbMF07XG4gIH1cbiAgaWYgKHF1ZXJ5IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICByZXR1cm4gcXVlcnk7XG4gIH1cbiAgaWYgKGlzSHRtbFN0cmluZyhxdWVyeSkpIHtcbiAgICB2YXIgdHBsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICB0cGwuaW5uZXJIVE1MID0gcXVlcnkudHJpbSgpOyAvLyBOZXZlciByZXR1cm4gYSB0ZXh0IG5vZGUgb2Ygd2hpdGVzcGFjZSBhcyB0aGUgcmVzdWx0XG4gICAgcmV0dXJuIHRwbC5jb250ZW50LmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocXVlcnkpO1xufTtcbmNvbnN0IGlzSHRtbFN0cmluZyA9IGFyZyA9PiB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJyAmJiBhcmcuaW5kZXhPZignPCcpID4gLTEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFBsdWdpbjogXCJkcm9wZG93bl9oZWFkZXJcIiAoVG9tIFNlbGVjdClcbiAqIENvcHlyaWdodCAoYykgY29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcbiAqIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBwbHVnaW4gKHVzZXJPcHRpb25zKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgY2xhc3NOYW1lOiAnY2xlYXItYnV0dG9uJyxcbiAgICB0aXRsZTogJ0NsZWFyIEFsbCcsXG4gICAgaHRtbDogZGF0YSA9PiB7XG4gICAgICByZXR1cm4gYDxkaXYgY2xhc3M9XCIke2RhdGEuY2xhc3NOYW1lfVwiIHRpdGxlPVwiJHtkYXRhLnRpdGxlfVwiPiYjMTA3OTk7PC9kaXY+YDtcbiAgICB9XG4gIH0sIHVzZXJPcHRpb25zKTtcbiAgc2VsZi5vbignaW5pdGlhbGl6ZScsICgpID0+IHtcbiAgICB2YXIgYnV0dG9uID0gZ2V0RG9tKG9wdGlvbnMuaHRtbChvcHRpb25zKSk7XG4gICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZXZ0ID0+IHtcbiAgICAgIGlmIChzZWxmLmlzTG9ja2VkKSByZXR1cm47XG4gICAgICBzZWxmLmNsZWFyKCk7XG4gICAgICBpZiAoc2VsZi5zZXR0aW5ncy5tb2RlID09PSAnc2luZ2xlJyAmJiBzZWxmLnNldHRpbmdzLmFsbG93RW1wdHlPcHRpb24pIHtcbiAgICAgICAgc2VsZi5hZGRJdGVtKCcnKTtcbiAgICAgIH1cbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0pO1xuICAgIHNlbGYuY29udHJvbC5hcHBlbmRDaGlsZChidXR0b24pO1xuICB9KTtcbn1cblxuZXhwb3J0IHsgcGx1Z2luIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsdWdpbi5qcy5tYXBcbiIsIi8qKlxuKiBUb20gU2VsZWN0IHYyLjQuM1xuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKi9cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHNjYWxhciB0byBpdHMgYmVzdCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAqIGZvciBoYXNoIGtleXMgYW5kIEhUTUwgYXR0cmlidXRlIHZhbHVlcy5cbiAqXG4gKiBUcmFuc2Zvcm1hdGlvbnM6XG4gKiAgICdzdHInICAgICAtPiAnc3RyJ1xuICogICBudWxsICAgICAgLT4gJydcbiAqICAgdW5kZWZpbmVkIC0+ICcnXG4gKiAgIHRydWUgICAgICAtPiAnMSdcbiAqICAgZmFsc2UgICAgIC0+ICcwJ1xuICogICAwICAgICAgICAgLT4gJzAnXG4gKiAgIDEgICAgICAgICAtPiAnMSdcbiAqXG4gKi9cblxuLyoqXG4gKiBQcmV2ZW50IGRlZmF1bHRcbiAqXG4gKi9cbmNvbnN0IHByZXZlbnREZWZhdWx0ID0gKGV2dCwgc3RvcCA9IGZhbHNlKSA9PiB7XG4gIGlmIChldnQpIHtcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoc3RvcCkge1xuICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBBZGQgZXZlbnQgaGVscGVyXG4gKlxuICovXG5jb25zdCBhZGRFdmVudCA9ICh0YXJnZXQsIHR5cGUsIGNhbGxiYWNrLCBvcHRpb25zKSA9PiB7XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBhcnJheXMgYW5kIGhhc2hlcy5cbiAqXG4gKiBgYGBcbiAqIGl0ZXJhdGUodGhpcy5pdGVtcywgZnVuY3Rpb24oaXRlbSwgaWQpIHtcbiAqICAgIC8vIGludm9rZWQgZm9yIGVhY2ggaXRlbVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKi9cbmNvbnN0IGl0ZXJhdGUgPSAob2JqZWN0LCBjYWxsYmFjaykgPT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgb2JqZWN0LmZvckVhY2goY2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBjYWxsYmFjayhvYmplY3Rba2V5XSwga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJuIGEgZG9tIGVsZW1lbnQgZnJvbSBlaXRoZXIgYSBkb20gcXVlcnkgc3RyaW5nLCBqUXVlcnkgb2JqZWN0LCBhIGRvbSBlbGVtZW50IG9yIGh0bWwgc3RyaW5nXG4gKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80OTQxNDMvY3JlYXRpbmctYS1uZXctZG9tLWVsZW1lbnQtZnJvbS1hbi1odG1sLXN0cmluZy11c2luZy1idWlsdC1pbi1kb20tbWV0aG9kcy1vci1wcm8vMzUzODU1MTgjMzUzODU1MThcbiAqXG4gKiBwYXJhbSBxdWVyeSBzaG91bGQgYmUge31cbiAqL1xuY29uc3QgZ2V0RG9tID0gcXVlcnkgPT4ge1xuICBpZiAocXVlcnkuanF1ZXJ5KSB7XG4gICAgcmV0dXJuIHF1ZXJ5WzBdO1xuICB9XG4gIGlmIChxdWVyeSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgcmV0dXJuIHF1ZXJ5O1xuICB9XG4gIGlmIChpc0h0bWxTdHJpbmcocXVlcnkpKSB7XG4gICAgdmFyIHRwbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgdHBsLmlubmVySFRNTCA9IHF1ZXJ5LnRyaW0oKTsgLy8gTmV2ZXIgcmV0dXJuIGEgdGV4dCBub2RlIG9mIHdoaXRlc3BhY2UgYXMgdGhlIHJlc3VsdFxuICAgIHJldHVybiB0cGwuY29udGVudC5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHF1ZXJ5KTtcbn07XG5jb25zdCBpc0h0bWxTdHJpbmcgPSBhcmcgPT4ge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgJiYgYXJnLmluZGV4T2YoJzwnKSA+IC0xKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBTZXQgYXR0cmlidXRlcyBvZiBhbiBlbGVtZW50XG4gKlxuICovXG5jb25zdCBzZXRBdHRyID0gKGVsLCBhdHRycykgPT4ge1xuICBpdGVyYXRlKGF0dHJzLCAodmFsLCBhdHRyKSA9PiB7XG4gICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyLCAnJyArIHZhbCk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogUGx1Z2luOiBcImRyYWdfZHJvcFwiIChUb20gU2VsZWN0KVxuICogQ29weXJpZ2h0IChjKSBjb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuICogZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GXG4gKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbmNvbnN0IGluc2VydEFmdGVyID0gKHJlZmVyZW5jZU5vZGUsIG5ld05vZGUpID0+IHtcbiAgdmFyIF9yZWZlcmVuY2VOb2RlJHBhcmVudDtcbiAgKF9yZWZlcmVuY2VOb2RlJHBhcmVudCA9IHJlZmVyZW5jZU5vZGUucGFyZW50Tm9kZSkgPT0gbnVsbCB8fCBfcmVmZXJlbmNlTm9kZSRwYXJlbnQuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUubmV4dFNpYmxpbmcpO1xufTtcbmNvbnN0IGluc2VydEJlZm9yZSA9IChyZWZlcmVuY2VOb2RlLCBuZXdOb2RlKSA9PiB7XG4gIHZhciBfcmVmZXJlbmNlTm9kZSRwYXJlbnQyO1xuICAoX3JlZmVyZW5jZU5vZGUkcGFyZW50MiA9IHJlZmVyZW5jZU5vZGUucGFyZW50Tm9kZSkgPT0gbnVsbCB8fCBfcmVmZXJlbmNlTm9kZSRwYXJlbnQyLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcbn07XG5jb25zdCBpc0JlZm9yZSA9IChyZWZlcmVuY2VOb2RlLCBuZXdOb2RlKSA9PiB7XG4gIGRvIHtcbiAgICB2YXIgX25ld05vZGU7XG4gICAgbmV3Tm9kZSA9IChfbmV3Tm9kZSA9IG5ld05vZGUpID09IG51bGwgPyB2b2lkIDAgOiBfbmV3Tm9kZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgIGlmIChyZWZlcmVuY2VOb2RlID09IG5ld05vZGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSB3aGlsZSAobmV3Tm9kZSAmJiBuZXdOb2RlLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpO1xuICByZXR1cm4gZmFsc2U7XG59O1xuZnVuY3Rpb24gcGx1Z2luICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoc2VsZi5zZXR0aW5ncy5tb2RlICE9PSAnbXVsdGknKSByZXR1cm47XG4gIHZhciBvcmlnX2xvY2sgPSBzZWxmLmxvY2s7XG4gIHZhciBvcmlnX3VubG9jayA9IHNlbGYudW5sb2NrO1xuICBsZXQgc29ydGFibGUgPSB0cnVlO1xuICBsZXQgZHJhZ19pdGVtO1xuXG4gIC8qKlxuICAgKiBBZGQgZHJhZ2dhYmxlIGF0dHJpYnV0ZSB0byBpdGVtXG4gICAqL1xuICBzZWxmLmhvb2soJ2FmdGVyJywgJ3NldHVwVGVtcGxhdGVzJywgKCkgPT4ge1xuICAgIHZhciBvcmlnX3JlbmRlcl9pdGVtID0gc2VsZi5zZXR0aW5ncy5yZW5kZXIuaXRlbTtcbiAgICBzZWxmLnNldHRpbmdzLnJlbmRlci5pdGVtID0gKGRhdGEsIGVzY2FwZSkgPT4ge1xuICAgICAgY29uc3QgaXRlbSA9IGdldERvbShvcmlnX3JlbmRlcl9pdGVtLmNhbGwoc2VsZiwgZGF0YSwgZXNjYXBlKSk7XG4gICAgICBzZXRBdHRyKGl0ZW0sIHtcbiAgICAgICAgJ2RyYWdnYWJsZSc6ICd0cnVlJ1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHByZXZlbnQgZG9jX21vdXNlZG93biAoc2VlIHRvbS1zZWxlY3QudHMpXG4gICAgICBjb25zdCBtb3VzZWRvd24gPSBldnQgPT4ge1xuICAgICAgICBpZiAoIXNvcnRhYmxlKSBwcmV2ZW50RGVmYXVsdChldnQpO1xuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZHJhZ1N0YXJ0ID0gZXZ0ID0+IHtcbiAgICAgICAgZHJhZ19pdGVtID0gaXRlbTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKCd0cy1kcmFnZ2luZycpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBkcmFnT3ZlciA9IGV2dCA9PiB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoJ3RzLWRyYWctb3ZlcicpO1xuICAgICAgICBtb3ZlaXRlbShpdGVtLCBkcmFnX2l0ZW0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGRyYWdMZWF2ZSA9ICgpID0+IHtcbiAgICAgICAgaXRlbS5jbGFzc0xpc3QucmVtb3ZlKCd0cy1kcmFnLW92ZXInKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBtb3ZlaXRlbSA9ICh0YXJnZXRpdGVtLCBkcmFnaXRlbSkgPT4ge1xuICAgICAgICBpZiAoZHJhZ2l0ZW0gPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgICBpZiAoaXNCZWZvcmUoZHJhZ2l0ZW0sIGl0ZW0pKSB7XG4gICAgICAgICAgaW5zZXJ0QWZ0ZXIodGFyZ2V0aXRlbSwgZHJhZ2l0ZW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluc2VydEJlZm9yZSh0YXJnZXRpdGVtLCBkcmFnaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBkcmFnZW5kID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2RyYWdfaXRlbTtcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnRzLWRyYWctb3ZlcicpLmZvckVhY2goZWwgPT4gZWwuY2xhc3NMaXN0LnJlbW92ZSgndHMtZHJhZy1vdmVyJykpO1xuICAgICAgICAoX2RyYWdfaXRlbSA9IGRyYWdfaXRlbSkgPT0gbnVsbCB8fCBfZHJhZ19pdGVtLmNsYXNzTGlzdC5yZW1vdmUoJ3RzLWRyYWdnaW5nJyk7XG4gICAgICAgIGRyYWdfaXRlbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICBzZWxmLmNvbnRyb2wucXVlcnlTZWxlY3RvckFsbChgW2RhdGEtdmFsdWVdYCkuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgaWYgKGVsLmRhdGFzZXQudmFsdWUpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGVsLmRhdGFzZXQudmFsdWU7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNlbGYuc2V0VmFsdWUodmFsdWVzKTtcbiAgICAgIH07XG4gICAgICBhZGRFdmVudChpdGVtLCAnbW91c2Vkb3duJywgbW91c2Vkb3duKTtcbiAgICAgIGFkZEV2ZW50KGl0ZW0sICdkcmFnc3RhcnQnLCBkcmFnU3RhcnQpO1xuICAgICAgYWRkRXZlbnQoaXRlbSwgJ2RyYWdlbnRlcicsIGRyYWdPdmVyKTtcbiAgICAgIGFkZEV2ZW50KGl0ZW0sICdkcmFnb3ZlcicsIGRyYWdPdmVyKTtcbiAgICAgIGFkZEV2ZW50KGl0ZW0sICdkcmFnbGVhdmUnLCBkcmFnTGVhdmUpO1xuICAgICAgYWRkRXZlbnQoaXRlbSwgJ2RyYWdlbmQnLCBkcmFnZW5kKTtcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH07XG4gIH0pO1xuICBzZWxmLmhvb2soJ2luc3RlYWQnLCAnbG9jaycsICgpID0+IHtcbiAgICBzb3J0YWJsZSA9IGZhbHNlO1xuICAgIHJldHVybiBvcmlnX2xvY2suY2FsbChzZWxmKTtcbiAgfSk7XG4gIHNlbGYuaG9vaygnaW5zdGVhZCcsICd1bmxvY2snLCAoKSA9PiB7XG4gICAgc29ydGFibGUgPSB0cnVlO1xuICAgIHJldHVybiBvcmlnX3VubG9jay5jYWxsKHNlbGYpO1xuICB9KTtcbn1cblxuZXhwb3J0IHsgcGx1Z2luIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsdWdpbi5qcy5tYXBcbiIsIi8qKlxuKiBUb20gU2VsZWN0IHYyLjQuM1xuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKi9cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHNjYWxhciB0byBpdHMgYmVzdCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAqIGZvciBoYXNoIGtleXMgYW5kIEhUTUwgYXR0cmlidXRlIHZhbHVlcy5cbiAqXG4gKiBUcmFuc2Zvcm1hdGlvbnM6XG4gKiAgICdzdHInICAgICAtPiAnc3RyJ1xuICogICBudWxsICAgICAgLT4gJydcbiAqICAgdW5kZWZpbmVkIC0+ICcnXG4gKiAgIHRydWUgICAgICAtPiAnMSdcbiAqICAgZmFsc2UgICAgIC0+ICcwJ1xuICogICAwICAgICAgICAgLT4gJzAnXG4gKiAgIDEgICAgICAgICAtPiAnMSdcbiAqXG4gKi9cblxuLyoqXG4gKiBQcmV2ZW50IGRlZmF1bHRcbiAqXG4gKi9cbmNvbnN0IHByZXZlbnREZWZhdWx0ID0gKGV2dCwgc3RvcCA9IGZhbHNlKSA9PiB7XG4gIGlmIChldnQpIHtcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoc3RvcCkge1xuICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm4gYSBkb20gZWxlbWVudCBmcm9tIGVpdGhlciBhIGRvbSBxdWVyeSBzdHJpbmcsIGpRdWVyeSBvYmplY3QsIGEgZG9tIGVsZW1lbnQgb3IgaHRtbCBzdHJpbmdcbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ5NDE0My9jcmVhdGluZy1hLW5ldy1kb20tZWxlbWVudC1mcm9tLWFuLWh0bWwtc3RyaW5nLXVzaW5nLWJ1aWx0LWluLWRvbS1tZXRob2RzLW9yLXByby8zNTM4NTUxOCMzNTM4NTUxOFxuICpcbiAqIHBhcmFtIHF1ZXJ5IHNob3VsZCBiZSB7fVxuICovXG5jb25zdCBnZXREb20gPSBxdWVyeSA9PiB7XG4gIGlmIChxdWVyeS5qcXVlcnkpIHtcbiAgICByZXR1cm4gcXVlcnlbMF07XG4gIH1cbiAgaWYgKHF1ZXJ5IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICByZXR1cm4gcXVlcnk7XG4gIH1cbiAgaWYgKGlzSHRtbFN0cmluZyhxdWVyeSkpIHtcbiAgICB2YXIgdHBsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICB0cGwuaW5uZXJIVE1MID0gcXVlcnkudHJpbSgpOyAvLyBOZXZlciByZXR1cm4gYSB0ZXh0IG5vZGUgb2Ygd2hpdGVzcGFjZSBhcyB0aGUgcmVzdWx0XG4gICAgcmV0dXJuIHRwbC5jb250ZW50LmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocXVlcnkpO1xufTtcbmNvbnN0IGlzSHRtbFN0cmluZyA9IGFyZyA9PiB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJyAmJiBhcmcuaW5kZXhPZignPCcpID4gLTEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFBsdWdpbjogXCJkcm9wZG93bl9oZWFkZXJcIiAoVG9tIFNlbGVjdClcbiAqIENvcHlyaWdodCAoYykgY29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcbiAqIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBwbHVnaW4gKHVzZXJPcHRpb25zKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgdGl0bGU6ICdVbnRpdGxlZCcsXG4gICAgaGVhZGVyQ2xhc3M6ICdkcm9wZG93bi1oZWFkZXInLFxuICAgIHRpdGxlUm93Q2xhc3M6ICdkcm9wZG93bi1oZWFkZXItdGl0bGUnLFxuICAgIGxhYmVsQ2xhc3M6ICdkcm9wZG93bi1oZWFkZXItbGFiZWwnLFxuICAgIGNsb3NlQ2xhc3M6ICdkcm9wZG93bi1oZWFkZXItY2xvc2UnLFxuICAgIGh0bWw6IGRhdGEgPT4ge1xuICAgICAgcmV0dXJuICc8ZGl2IGNsYXNzPVwiJyArIGRhdGEuaGVhZGVyQ2xhc3MgKyAnXCI+JyArICc8ZGl2IGNsYXNzPVwiJyArIGRhdGEudGl0bGVSb3dDbGFzcyArICdcIj4nICsgJzxzcGFuIGNsYXNzPVwiJyArIGRhdGEubGFiZWxDbGFzcyArICdcIj4nICsgZGF0YS50aXRsZSArICc8L3NwYW4+JyArICc8YSBjbGFzcz1cIicgKyBkYXRhLmNsb3NlQ2xhc3MgKyAnXCI+JnRpbWVzOzwvYT4nICsgJzwvZGl2PicgKyAnPC9kaXY+JztcbiAgICB9XG4gIH0sIHVzZXJPcHRpb25zKTtcbiAgc2VsZi5vbignaW5pdGlhbGl6ZScsICgpID0+IHtcbiAgICB2YXIgaGVhZGVyID0gZ2V0RG9tKG9wdGlvbnMuaHRtbChvcHRpb25zKSk7XG4gICAgdmFyIGNsb3NlX2xpbmsgPSBoZWFkZXIucXVlcnlTZWxlY3RvcignLicgKyBvcHRpb25zLmNsb3NlQ2xhc3MpO1xuICAgIGlmIChjbG9zZV9saW5rKSB7XG4gICAgICBjbG9zZV9saW5rLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZXZ0ID0+IHtcbiAgICAgICAgcHJldmVudERlZmF1bHQoZXZ0LCB0cnVlKTtcbiAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHNlbGYuZHJvcGRvd24uaW5zZXJ0QmVmb3JlKGhlYWRlciwgc2VsZi5kcm9wZG93bi5maXJzdENoaWxkKTtcbiAgfSk7XG59XG5cbmV4cG9ydCB7IHBsdWdpbiBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbHVnaW4uanMubWFwXG4iLCIvKipcbiogVG9tIFNlbGVjdCB2Mi40LjNcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiovXG5cbmNvbnN0IEtFWV9FU0MgPSAyNztcbmNvbnN0IEtFWV9UQUIgPSA5O1xuIC8vIGN0cmwga2V5IG9yIGFwcGxlIGtleSBmb3IgbWFcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHNjYWxhciB0byBpdHMgYmVzdCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAqIGZvciBoYXNoIGtleXMgYW5kIEhUTUwgYXR0cmlidXRlIHZhbHVlcy5cbiAqXG4gKiBUcmFuc2Zvcm1hdGlvbnM6XG4gKiAgICdzdHInICAgICAtPiAnc3RyJ1xuICogICBudWxsICAgICAgLT4gJydcbiAqICAgdW5kZWZpbmVkIC0+ICcnXG4gKiAgIHRydWUgICAgICAtPiAnMSdcbiAqICAgZmFsc2UgICAgIC0+ICcwJ1xuICogICAwICAgICAgICAgLT4gJzAnXG4gKiAgIDEgICAgICAgICAtPiAnMSdcbiAqXG4gKi9cblxuLyoqXG4gKiBQcmV2ZW50IGRlZmF1bHRcbiAqXG4gKi9cbmNvbnN0IHByZXZlbnREZWZhdWx0ID0gKGV2dCwgc3RvcCA9IGZhbHNlKSA9PiB7XG4gIGlmIChldnQpIHtcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoc3RvcCkge1xuICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBBZGQgZXZlbnQgaGVscGVyXG4gKlxuICovXG5jb25zdCBhZGRFdmVudCA9ICh0YXJnZXQsIHR5cGUsIGNhbGxiYWNrLCBvcHRpb25zKSA9PiB7XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBhcnJheXMgYW5kIGhhc2hlcy5cbiAqXG4gKiBgYGBcbiAqIGl0ZXJhdGUodGhpcy5pdGVtcywgZnVuY3Rpb24oaXRlbSwgaWQpIHtcbiAqICAgIC8vIGludm9rZWQgZm9yIGVhY2ggaXRlbVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKi9cbmNvbnN0IGl0ZXJhdGUgPSAob2JqZWN0LCBjYWxsYmFjaykgPT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgb2JqZWN0LmZvckVhY2goY2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBjYWxsYmFjayhvYmplY3Rba2V5XSwga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJuIGEgZG9tIGVsZW1lbnQgZnJvbSBlaXRoZXIgYSBkb20gcXVlcnkgc3RyaW5nLCBqUXVlcnkgb2JqZWN0LCBhIGRvbSBlbGVtZW50IG9yIGh0bWwgc3RyaW5nXG4gKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80OTQxNDMvY3JlYXRpbmctYS1uZXctZG9tLWVsZW1lbnQtZnJvbS1hbi1odG1sLXN0cmluZy11c2luZy1idWlsdC1pbi1kb20tbWV0aG9kcy1vci1wcm8vMzUzODU1MTgjMzUzODU1MThcbiAqXG4gKiBwYXJhbSBxdWVyeSBzaG91bGQgYmUge31cbiAqL1xuY29uc3QgZ2V0RG9tID0gcXVlcnkgPT4ge1xuICBpZiAocXVlcnkuanF1ZXJ5KSB7XG4gICAgcmV0dXJuIHF1ZXJ5WzBdO1xuICB9XG4gIGlmIChxdWVyeSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgcmV0dXJuIHF1ZXJ5O1xuICB9XG4gIGlmIChpc0h0bWxTdHJpbmcocXVlcnkpKSB7XG4gICAgdmFyIHRwbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgdHBsLmlubmVySFRNTCA9IHF1ZXJ5LnRyaW0oKTsgLy8gTmV2ZXIgcmV0dXJuIGEgdGV4dCBub2RlIG9mIHdoaXRlc3BhY2UgYXMgdGhlIHJlc3VsdFxuICAgIHJldHVybiB0cGwuY29udGVudC5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHF1ZXJ5KTtcbn07XG5jb25zdCBpc0h0bWxTdHJpbmcgPSBhcmcgPT4ge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgJiYgYXJnLmluZGV4T2YoJzwnKSA+IC0xKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBBZGQgY3NzIGNsYXNzZXNcbiAqXG4gKi9cbmNvbnN0IGFkZENsYXNzZXMgPSAoZWxtdHMsIC4uLmNsYXNzZXMpID0+IHtcbiAgdmFyIG5vcm1fY2xhc3NlcyA9IGNsYXNzZXNBcnJheShjbGFzc2VzKTtcbiAgZWxtdHMgPSBjYXN0QXNBcnJheShlbG10cyk7XG4gIGVsbXRzLm1hcChlbCA9PiB7XG4gICAgbm9ybV9jbGFzc2VzLm1hcChjbHMgPT4ge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGFyZ3VtZW50c1xuICpcbiAqL1xuY29uc3QgY2xhc3Nlc0FycmF5ID0gYXJncyA9PiB7XG4gIHZhciBjbGFzc2VzID0gW107XG4gIGl0ZXJhdGUoYXJncywgX2NsYXNzZXMgPT4ge1xuICAgIGlmICh0eXBlb2YgX2NsYXNzZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBfY2xhc3NlcyA9IF9jbGFzc2VzLnRyaW0oKS5zcGxpdCgvW1xcdFxcblxcZlxcclxcc10vKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoX2NsYXNzZXMpKSB7XG4gICAgICBjbGFzc2VzID0gY2xhc3Nlcy5jb25jYXQoX2NsYXNzZXMpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjbGFzc2VzLmZpbHRlcihCb29sZWFuKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuIGFycmF5IGZyb20gYXJnIGlmIGl0J3Mgbm90IGFscmVhZHkgYW4gYXJyYXlcbiAqXG4gKi9cbmNvbnN0IGNhc3RBc0FycmF5ID0gYXJnID0+IHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICBhcmcgPSBbYXJnXTtcbiAgfVxuICByZXR1cm4gYXJnO1xufTtcblxuLyoqXG4gKiBQbHVnaW46IFwiZHJvcGRvd25faW5wdXRcIiAoVG9tIFNlbGVjdClcbiAqIENvcHlyaWdodCAoYykgY29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcbiAqIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBwbHVnaW4gKCkge1xuICBjb25zdCBzZWxmID0gdGhpcztcbiAgc2VsZi5zZXR0aW5ncy5zaG91bGRPcGVuID0gdHJ1ZTsgLy8gbWFrZSBzdXJlIHRoZSBpbnB1dCBpcyBzaG93biBldmVuIGlmIHRoZXJlIGFyZSBubyBvcHRpb25zIHRvIGRpc3BsYXkgaW4gdGhlIGRyb3Bkb3duXG5cbiAgc2VsZi5ob29rKCdiZWZvcmUnLCAnc2V0dXAnLCAoKSA9PiB7XG4gICAgc2VsZi5mb2N1c19ub2RlID0gc2VsZi5jb250cm9sO1xuICAgIGFkZENsYXNzZXMoc2VsZi5jb250cm9sX2lucHV0LCAnZHJvcGRvd24taW5wdXQnKTtcbiAgICBjb25zdCBkaXYgPSBnZXREb20oJzxkaXYgY2xhc3M9XCJkcm9wZG93bi1pbnB1dC13cmFwXCI+Jyk7XG4gICAgZGl2LmFwcGVuZChzZWxmLmNvbnRyb2xfaW5wdXQpO1xuICAgIHNlbGYuZHJvcGRvd24uaW5zZXJ0QmVmb3JlKGRpdiwgc2VsZi5kcm9wZG93bi5maXJzdENoaWxkKTtcblxuICAgIC8vIHNldCBhIHBsYWNlaG9sZGVyIGluIHRoZSBzZWxlY3QgY29udHJvbFxuICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gZ2V0RG9tKCc8aW5wdXQgY2xhc3M9XCJpdGVtcy1wbGFjZWhvbGRlclwiIHRhYmluZGV4PVwiLTFcIiAvPicpO1xuICAgIHBsYWNlaG9sZGVyLnBsYWNlaG9sZGVyID0gc2VsZi5zZXR0aW5ncy5wbGFjZWhvbGRlciB8fCAnJztcbiAgICBzZWxmLmNvbnRyb2wuYXBwZW5kKHBsYWNlaG9sZGVyKTtcbiAgfSk7XG4gIHNlbGYub24oJ2luaXRpYWxpemUnLCAoKSA9PiB7XG4gICAgLy8gc2V0IHRhYkluZGV4IG9uIGNvbnRyb2wgdG8gLTEsIG90aGVyd2lzZSBbc2hpZnQrdGFiXSB3aWxsIHB1dCBmb2N1cyByaWdodCBiYWNrIG9uIGNvbnRyb2xfaW5wdXRcbiAgICBzZWxmLmNvbnRyb2xfaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGV2dCA9PiB7XG4gICAgICAvL2FkZEV2ZW50KHNlbGYuY29udHJvbF9pbnB1dCwna2V5ZG93bicgYXMgY29uc3QsKGV2dDpLZXlib2FyZEV2ZW50KSA9PntcbiAgICAgIHN3aXRjaCAoZXZ0LmtleUNvZGUpIHtcbiAgICAgICAgY2FzZSBLRVlfRVNDOlxuICAgICAgICAgIGlmIChzZWxmLmlzT3Blbikge1xuICAgICAgICAgICAgcHJldmVudERlZmF1bHQoZXZ0LCB0cnVlKTtcbiAgICAgICAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5jbGVhckFjdGl2ZUl0ZW1zKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIEtFWV9UQUI6XG4gICAgICAgICAgc2VsZi5mb2N1c19ub2RlLnRhYkluZGV4ID0gLTE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5vbktleURvd24uY2FsbChzZWxmLCBldnQpO1xuICAgIH0pO1xuICAgIHNlbGYub24oJ2JsdXInLCAoKSA9PiB7XG4gICAgICBzZWxmLmZvY3VzX25vZGUudGFiSW5kZXggPSBzZWxmLmlzRGlzYWJsZWQgPyAtMSA6IHNlbGYudGFiSW5kZXg7XG4gICAgfSk7XG5cbiAgICAvLyBnaXZlIHRoZSBjb250cm9sX2lucHV0IGZvY3VzIHdoZW4gdGhlIGRyb3Bkb3duIGlzIG9wZW5cbiAgICBzZWxmLm9uKCdkcm9wZG93bl9vcGVuJywgKCkgPT4ge1xuICAgICAgc2VsZi5jb250cm9sX2lucHV0LmZvY3VzKCk7XG4gICAgfSk7XG5cbiAgICAvLyBwcmV2ZW50IG9uQmx1ciBmcm9tIGNsb3Npbmcgd2hlbiBmb2N1cyBpcyBvbiB0aGUgY29udHJvbF9pbnB1dFxuICAgIGNvbnN0IG9yaWdfb25CbHVyID0gc2VsZi5vbkJsdXI7XG4gICAgc2VsZi5ob29rKCdpbnN0ZWFkJywgJ29uQmx1cicsIGV2dCA9PiB7XG4gICAgICBpZiAoZXZ0ICYmIGV2dC5yZWxhdGVkVGFyZ2V0ID09IHNlbGYuY29udHJvbF9pbnB1dCkgcmV0dXJuO1xuICAgICAgcmV0dXJuIG9yaWdfb25CbHVyLmNhbGwoc2VsZik7XG4gICAgfSk7XG4gICAgYWRkRXZlbnQoc2VsZi5jb250cm9sX2lucHV0LCAnYmx1cicsICgpID0+IHNlbGYub25CbHVyKCkpO1xuXG4gICAgLy8gcmV0dXJuIGZvY3VzIHRvIGNvbnRyb2wgdG8gYWxsb3cgZnVydGhlciBrZXlib2FyZCBpbnB1dFxuICAgIHNlbGYuaG9vaygnYmVmb3JlJywgJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgaWYgKCFzZWxmLmlzT3BlbikgcmV0dXJuO1xuICAgICAgc2VsZi5mb2N1c19ub2RlLmZvY3VzKHtcbiAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnQgeyBwbHVnaW4gYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGx1Z2luLmpzLm1hcFxuIiwiLyoqXG4qIFRvbSBTZWxlY3QgdjIuNC4zXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qL1xuXG4vKipcbiAqIENvbnZlcnRzIGEgc2NhbGFyIHRvIGl0cyBiZXN0IHN0cmluZyByZXByZXNlbnRhdGlvblxuICogZm9yIGhhc2gga2V5cyBhbmQgSFRNTCBhdHRyaWJ1dGUgdmFsdWVzLlxuICpcbiAqIFRyYW5zZm9ybWF0aW9uczpcbiAqICAgJ3N0cicgICAgIC0+ICdzdHInXG4gKiAgIG51bGwgICAgICAtPiAnJ1xuICogICB1bmRlZmluZWQgLT4gJydcbiAqICAgdHJ1ZSAgICAgIC0+ICcxJ1xuICogICBmYWxzZSAgICAgLT4gJzAnXG4gKiAgIDAgICAgICAgICAtPiAnMCdcbiAqICAgMSAgICAgICAgIC0+ICcxJ1xuICpcbiAqL1xuXG4vKipcbiAqIEFkZCBldmVudCBoZWxwZXJcbiAqXG4gKi9cbmNvbnN0IGFkZEV2ZW50ID0gKHRhcmdldCwgdHlwZSwgY2FsbGJhY2ssIG9wdGlvbnMpID0+IHtcbiAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2ssIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBQbHVnaW46IFwiaW5wdXRfYXV0b2dyb3dcIiAoVG9tIFNlbGVjdClcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuICogZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GXG4gKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbmZ1bmN0aW9uIHBsdWdpbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5vbignaW5pdGlhbGl6ZScsICgpID0+IHtcbiAgICB2YXIgdGVzdF9pbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICB2YXIgY29udHJvbCA9IHNlbGYuY29udHJvbF9pbnB1dDtcbiAgICB0ZXN0X2lucHV0LnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246YWJzb2x1dGU7IHRvcDotOTk5OTlweDsgbGVmdDotOTk5OTlweDsgd2lkdGg6YXV0bzsgcGFkZGluZzowOyB3aGl0ZS1zcGFjZTpwcmU7ICc7XG4gICAgc2VsZi53cmFwcGVyLmFwcGVuZENoaWxkKHRlc3RfaW5wdXQpO1xuICAgIHZhciB0cmFuc2Zlcl9zdHlsZXMgPSBbJ2xldHRlclNwYWNpbmcnLCAnZm9udFNpemUnLCAnZm9udEZhbWlseScsICdmb250V2VpZ2h0JywgJ3RleHRUcmFuc2Zvcm0nXTtcbiAgICBmb3IgKGNvbnN0IHN0eWxlX25hbWUgb2YgdHJhbnNmZXJfc3R5bGVzKSB7XG4gICAgICAvLyBAdHMtaWdub3JlIFRTNzAxNSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTA1MDYxNTQvNjk3NTc2XG4gICAgICB0ZXN0X2lucHV0LnN0eWxlW3N0eWxlX25hbWVdID0gY29udHJvbC5zdHlsZVtzdHlsZV9uYW1lXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGNvbnRyb2wgd2lkdGhcbiAgICAgKlxuICAgICAqL1xuICAgIHZhciByZXNpemUgPSAoKSA9PiB7XG4gICAgICB0ZXN0X2lucHV0LnRleHRDb250ZW50ID0gY29udHJvbC52YWx1ZTtcbiAgICAgIGNvbnRyb2wuc3R5bGUud2lkdGggPSB0ZXN0X2lucHV0LmNsaWVudFdpZHRoICsgJ3B4JztcbiAgICB9O1xuICAgIHJlc2l6ZSgpO1xuICAgIHNlbGYub24oJ3VwZGF0ZSBpdGVtX2FkZCBpdGVtX3JlbW92ZScsIHJlc2l6ZSk7XG4gICAgYWRkRXZlbnQoY29udHJvbCwgJ2lucHV0JywgcmVzaXplKTtcbiAgICBhZGRFdmVudChjb250cm9sLCAna2V5dXAnLCByZXNpemUpO1xuICAgIGFkZEV2ZW50KGNvbnRyb2wsICdibHVyJywgcmVzaXplKTtcbiAgICBhZGRFdmVudChjb250cm9sLCAndXBkYXRlJywgcmVzaXplKTtcbiAgfSk7XG59XG5cbmV4cG9ydCB7IHBsdWdpbiBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbHVnaW4uanMubWFwXG4iLCIvKipcbiogVG9tIFNlbGVjdCB2Mi40LjNcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiovXG5cbi8qKlxuICogUGx1Z2luOiBcIm5vX2FjdGl2ZV9pdGVtc1wiIChUb20gU2VsZWN0KVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gcGx1Z2luICgpIHtcbiAgdGhpcy5ob29rKCdpbnN0ZWFkJywgJ3NldEFjdGl2ZUl0ZW0nLCAoKSA9PiB7fSk7XG4gIHRoaXMuaG9vaygnaW5zdGVhZCcsICdzZWxlY3RBbGwnLCAoKSA9PiB7fSk7XG59XG5cbmV4cG9ydCB7IHBsdWdpbiBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbHVnaW4uanMubWFwXG4iLCIvKipcbiogVG9tIFNlbGVjdCB2Mi40LjNcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiovXG5cbi8qKlxuICogUGx1Z2luOiBcImlucHV0X2F1dG9ncm93XCIgKFRvbSBTZWxlY3QpXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcbiAqIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBwbHVnaW4gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBvcmlnX2RlbGV0ZVNlbGVjdGlvbiA9IHNlbGYuZGVsZXRlU2VsZWN0aW9uO1xuICB0aGlzLmhvb2soJ2luc3RlYWQnLCAnZGVsZXRlU2VsZWN0aW9uJywgZXZ0ID0+IHtcbiAgICBpZiAoc2VsZi5hY3RpdmVJdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBvcmlnX2RlbGV0ZVNlbGVjdGlvbi5jYWxsKHNlbGYsIGV2dCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG59XG5cbmV4cG9ydCB7IHBsdWdpbiBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbHVnaW4uanMubWFwXG4iLCIvKipcbiogVG9tIFNlbGVjdCB2Mi40LjNcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiovXG5cbmNvbnN0IEtFWV9MRUZUID0gMzc7XG5jb25zdCBLRVlfUklHSFQgPSAzOTtcbiAvLyBjdHJsIGtleSBvciBhcHBsZSBrZXkgZm9yIG1hXG5cbi8qKlxuICogR2V0IHRoZSBjbG9zZXN0IG5vZGUgdG8gdGhlIGV2dC50YXJnZXQgbWF0Y2hpbmcgdGhlIHNlbGVjdG9yXG4gKiBTdG9wcyBhdCB3cmFwcGVyXG4gKlxuICovXG5jb25zdCBwYXJlbnRNYXRjaCA9ICh0YXJnZXQsIHNlbGVjdG9yLCB3cmFwcGVyKSA9PiB7XG4gIHdoaWxlICh0YXJnZXQgJiYgdGFyZ2V0Lm1hdGNoZXMpIHtcbiAgICBpZiAodGFyZ2V0Lm1hdGNoZXMoc2VsZWN0b3IpKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIGluZGV4IG9mIGFuIGVsZW1lbnQgYW1vbmdzdCBzaWJsaW5nIG5vZGVzIG9mIHRoZSBzYW1lIHR5cGVcbiAqXG4gKi9cbmNvbnN0IG5vZGVJbmRleCA9IChlbCwgYW1vbmdzdCkgPT4ge1xuICBpZiAoIWVsKSByZXR1cm4gLTE7XG4gIGFtb25nc3QgPSBhbW9uZ3N0IHx8IGVsLm5vZGVOYW1lO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChlbCA9IGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpIHtcbiAgICBpZiAoZWwubWF0Y2hlcyhhbW9uZ3N0KSkge1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaTtcbn07XG5cbi8qKlxuICogUGx1Z2luOiBcIm9wdGdyb3VwX2NvbHVtbnNcIiAoVG9tIFNlbGVjdC5qcylcbiAqIENvcHlyaWdodCAoYykgY29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcbiAqIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBwbHVnaW4gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBvcmlnX2tleWRvd24gPSBzZWxmLm9uS2V5RG93bjtcbiAgc2VsZi5ob29rKCdpbnN0ZWFkJywgJ29uS2V5RG93bicsIGV2dCA9PiB7XG4gICAgdmFyIGluZGV4LCBvcHRpb24sIG9wdGlvbnMsIG9wdGdyb3VwO1xuICAgIGlmICghc2VsZi5pc09wZW4gfHwgIShldnQua2V5Q29kZSA9PT0gS0VZX0xFRlQgfHwgZXZ0LmtleUNvZGUgPT09IEtFWV9SSUdIVCkpIHtcbiAgICAgIHJldHVybiBvcmlnX2tleWRvd24uY2FsbChzZWxmLCBldnQpO1xuICAgIH1cbiAgICBzZWxmLmlnbm9yZUhvdmVyID0gdHJ1ZTtcbiAgICBvcHRncm91cCA9IHBhcmVudE1hdGNoKHNlbGYuYWN0aXZlT3B0aW9uLCAnW2RhdGEtZ3JvdXBdJyk7XG4gICAgaW5kZXggPSBub2RlSW5kZXgoc2VsZi5hY3RpdmVPcHRpb24sICdbZGF0YS1zZWxlY3RhYmxlXScpO1xuICAgIGlmICghb3B0Z3JvdXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2dC5rZXlDb2RlID09PSBLRVlfTEVGVCkge1xuICAgICAgb3B0Z3JvdXAgPSBvcHRncm91cC5wcmV2aW91c1NpYmxpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGdyb3VwID0gb3B0Z3JvdXAubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIGlmICghb3B0Z3JvdXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGdyb3VwLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNlbGVjdGFibGVdJyk7XG4gICAgb3B0aW9uID0gb3B0aW9uc1tNYXRoLm1pbihvcHRpb25zLmxlbmd0aCAtIDEsIGluZGV4KV07XG4gICAgaWYgKG9wdGlvbikge1xuICAgICAgc2VsZi5zZXRBY3RpdmVPcHRpb24ob3B0aW9uKTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgeyBwbHVnaW4gYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGx1Z2luLmpzLm1hcFxuIiwiLyoqXG4qIFRvbSBTZWxlY3QgdjIuNC4zXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qL1xuXG4vKipcbiAqIENvbnZlcnRzIGEgc2NhbGFyIHRvIGl0cyBiZXN0IHN0cmluZyByZXByZXNlbnRhdGlvblxuICogZm9yIGhhc2gga2V5cyBhbmQgSFRNTCBhdHRyaWJ1dGUgdmFsdWVzLlxuICpcbiAqIFRyYW5zZm9ybWF0aW9uczpcbiAqICAgJ3N0cicgICAgIC0+ICdzdHInXG4gKiAgIG51bGwgICAgICAtPiAnJ1xuICogICB1bmRlZmluZWQgLT4gJydcbiAqICAgdHJ1ZSAgICAgIC0+ICcxJ1xuICogICBmYWxzZSAgICAgLT4gJzAnXG4gKiAgIDAgICAgICAgICAtPiAnMCdcbiAqICAgMSAgICAgICAgIC0+ICcxJ1xuICpcbiAqL1xuXG4vKipcbiAqIEVzY2FwZXMgYSBzdHJpbmcgZm9yIHVzZSB3aXRoaW4gSFRNTC5cbiAqXG4gKi9cbmNvbnN0IGVzY2FwZV9odG1sID0gc3RyID0+IHtcbiAgcmV0dXJuIChzdHIgKyAnJykucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvPi9nLCAnJmd0OycpLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbn07XG5cbi8qKlxuICogUHJldmVudCBkZWZhdWx0XG4gKlxuICovXG5jb25zdCBwcmV2ZW50RGVmYXVsdCA9IChldnQsIHN0b3AgPSBmYWxzZSkgPT4ge1xuICBpZiAoZXZ0KSB7XG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKHN0b3ApIHtcbiAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQWRkIGV2ZW50IGhlbHBlclxuICpcbiAqL1xuY29uc3QgYWRkRXZlbnQgPSAodGFyZ2V0LCB0eXBlLCBjYWxsYmFjaywgb3B0aW9ucykgPT4ge1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFJldHVybiBhIGRvbSBlbGVtZW50IGZyb20gZWl0aGVyIGEgZG9tIHF1ZXJ5IHN0cmluZywgalF1ZXJ5IG9iamVjdCwgYSBkb20gZWxlbWVudCBvciBodG1sIHN0cmluZ1xuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDk0MTQzL2NyZWF0aW5nLWEtbmV3LWRvbS1lbGVtZW50LWZyb20tYW4taHRtbC1zdHJpbmctdXNpbmctYnVpbHQtaW4tZG9tLW1ldGhvZHMtb3ItcHJvLzM1Mzg1NTE4IzM1Mzg1NTE4XG4gKlxuICogcGFyYW0gcXVlcnkgc2hvdWxkIGJlIHt9XG4gKi9cbmNvbnN0IGdldERvbSA9IHF1ZXJ5ID0+IHtcbiAgaWYgKHF1ZXJ5LmpxdWVyeSkge1xuICAgIHJldHVybiBxdWVyeVswXTtcbiAgfVxuICBpZiAocXVlcnkgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgIHJldHVybiBxdWVyeTtcbiAgfVxuICBpZiAoaXNIdG1sU3RyaW5nKHF1ZXJ5KSkge1xuICAgIHZhciB0cGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgIHRwbC5pbm5lckhUTUwgPSBxdWVyeS50cmltKCk7IC8vIE5ldmVyIHJldHVybiBhIHRleHQgbm9kZSBvZiB3aGl0ZXNwYWNlIGFzIHRoZSByZXN1bHRcbiAgICByZXR1cm4gdHBsLmNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgfVxuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihxdWVyeSk7XG59O1xuY29uc3QgaXNIdG1sU3RyaW5nID0gYXJnID0+IHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnICYmIGFyZy5pbmRleE9mKCc8JykgPiAtMSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUGx1Z2luOiBcInJlbW92ZV9idXR0b25cIiAoVG9tIFNlbGVjdClcbiAqIENvcHlyaWdodCAoYykgY29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcbiAqIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBwbHVnaW4gKHVzZXJPcHRpb25zKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBsYWJlbDogJyZ0aW1lczsnLFxuICAgIHRpdGxlOiAnUmVtb3ZlJyxcbiAgICBjbGFzc05hbWU6ICdyZW1vdmUnLFxuICAgIGFwcGVuZDogdHJ1ZVxuICB9LCB1c2VyT3B0aW9ucyk7XG5cbiAgLy9vcHRpb25zLmNsYXNzTmFtZSA9ICdyZW1vdmUtc2luZ2xlJztcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIG92ZXJyaWRlIHRoZSByZW5kZXIgbWV0aG9kIHRvIGFkZCByZW1vdmUgYnV0dG9uIHRvIGVhY2ggaXRlbVxuICBpZiAoIW9wdGlvbnMuYXBwZW5kKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBodG1sID0gJzxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIiBjbGFzcz1cIicgKyBvcHRpb25zLmNsYXNzTmFtZSArICdcIiB0YWJpbmRleD1cIi0xXCIgdGl0bGU9XCInICsgZXNjYXBlX2h0bWwob3B0aW9ucy50aXRsZSkgKyAnXCI+JyArIG9wdGlvbnMubGFiZWwgKyAnPC9hPic7XG4gIHNlbGYuaG9vaygnYWZ0ZXInLCAnc2V0dXBUZW1wbGF0ZXMnLCAoKSA9PiB7XG4gICAgdmFyIG9yaWdfcmVuZGVyX2l0ZW0gPSBzZWxmLnNldHRpbmdzLnJlbmRlci5pdGVtO1xuICAgIHNlbGYuc2V0dGluZ3MucmVuZGVyLml0ZW0gPSAoZGF0YSwgZXNjYXBlKSA9PiB7XG4gICAgICB2YXIgaXRlbSA9IGdldERvbShvcmlnX3JlbmRlcl9pdGVtLmNhbGwoc2VsZiwgZGF0YSwgZXNjYXBlKSk7XG4gICAgICB2YXIgY2xvc2VfYnV0dG9uID0gZ2V0RG9tKGh0bWwpO1xuICAgICAgaXRlbS5hcHBlbmRDaGlsZChjbG9zZV9idXR0b24pO1xuICAgICAgYWRkRXZlbnQoY2xvc2VfYnV0dG9uLCAnbW91c2Vkb3duJywgZXZ0ID0+IHtcbiAgICAgICAgcHJldmVudERlZmF1bHQoZXZ0LCB0cnVlKTtcbiAgICAgIH0pO1xuICAgICAgYWRkRXZlbnQoY2xvc2VfYnV0dG9uLCAnY2xpY2snLCBldnQgPT4ge1xuICAgICAgICBpZiAoc2VsZi5pc0xvY2tlZCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIHByb3BhZ2F0aW5nIHdpbGwgdHJpZ2dlciB0aGUgZHJvcGRvd24gdG8gc2hvdyBmb3Igc2luZ2xlIG1vZGVcbiAgICAgICAgcHJldmVudERlZmF1bHQoZXZ0LCB0cnVlKTtcbiAgICAgICAgaWYgKHNlbGYuaXNMb2NrZWQpIHJldHVybjtcbiAgICAgICAgaWYgKCFzZWxmLnNob3VsZERlbGV0ZShbaXRlbV0sIGV2dCkpIHJldHVybjtcbiAgICAgICAgc2VsZi5yZW1vdmVJdGVtKGl0ZW0pO1xuICAgICAgICBzZWxmLnJlZnJlc2hPcHRpb25zKGZhbHNlKTtcbiAgICAgICAgc2VsZi5pbnB1dFN0YXRlKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH07XG4gIH0pO1xufVxuXG5leHBvcnQgeyBwbHVnaW4gYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGx1Z2luLmpzLm1hcFxuIiwiLyoqXG4qIFRvbSBTZWxlY3QgdjIuNC4zXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qL1xuXG4vKipcbiAqIFBsdWdpbjogXCJyZXN0b3JlX29uX2JhY2tzcGFjZVwiIChUb20gU2VsZWN0KVxuICogQ29weXJpZ2h0IChjKSBjb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuICogZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GXG4gKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbmZ1bmN0aW9uIHBsdWdpbiAodXNlck9wdGlvbnMpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICB0ZXh0OiBvcHRpb24gPT4ge1xuICAgICAgcmV0dXJuIG9wdGlvbltzZWxmLnNldHRpbmdzLmxhYmVsRmllbGRdO1xuICAgIH1cbiAgfSwgdXNlck9wdGlvbnMpO1xuICBzZWxmLm9uKCdpdGVtX3JlbW92ZScsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICghc2VsZi5pc0ZvY3VzZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNlbGYuY29udHJvbF9pbnB1dC52YWx1ZS50cmltKCkgPT09ICcnKSB7XG4gICAgICB2YXIgb3B0aW9uID0gc2VsZi5vcHRpb25zW3ZhbHVlXTtcbiAgICAgIGlmIChvcHRpb24pIHtcbiAgICAgICAgc2VsZi5zZXRUZXh0Ym94VmFsdWUob3B0aW9ucy50ZXh0LmNhbGwoc2VsZiwgb3B0aW9uKSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IHsgcGx1Z2luIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsdWdpbi5qcy5tYXBcbiIsIi8qKlxuKiBUb20gU2VsZWN0IHYyLjQuM1xuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKi9cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHNjYWxhciB0byBpdHMgYmVzdCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAqIGZvciBoYXNoIGtleXMgYW5kIEhUTUwgYXR0cmlidXRlIHZhbHVlcy5cbiAqXG4gKiBUcmFuc2Zvcm1hdGlvbnM6XG4gKiAgICdzdHInICAgICAtPiAnc3RyJ1xuICogICBudWxsICAgICAgLT4gJydcbiAqICAgdW5kZWZpbmVkIC0+ICcnXG4gKiAgIHRydWUgICAgICAtPiAnMSdcbiAqICAgZmFsc2UgICAgIC0+ICcwJ1xuICogICAwICAgICAgICAgLT4gJzAnXG4gKiAgIDEgICAgICAgICAtPiAnMSdcbiAqXG4gKi9cblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGFycmF5cyBhbmQgaGFzaGVzLlxuICpcbiAqIGBgYFxuICogaXRlcmF0ZSh0aGlzLml0ZW1zLCBmdW5jdGlvbihpdGVtLCBpZCkge1xuICogICAgLy8gaW52b2tlZCBmb3IgZWFjaCBpdGVtXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqL1xuY29uc3QgaXRlcmF0ZSA9IChvYmplY3QsIGNhbGxiYWNrKSA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICBvYmplY3QuZm9yRWFjaChjYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGNhbGxiYWNrKG9iamVjdFtrZXldLCBrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBBZGQgY3NzIGNsYXNzZXNcbiAqXG4gKi9cbmNvbnN0IGFkZENsYXNzZXMgPSAoZWxtdHMsIC4uLmNsYXNzZXMpID0+IHtcbiAgdmFyIG5vcm1fY2xhc3NlcyA9IGNsYXNzZXNBcnJheShjbGFzc2VzKTtcbiAgZWxtdHMgPSBjYXN0QXNBcnJheShlbG10cyk7XG4gIGVsbXRzLm1hcChlbCA9PiB7XG4gICAgbm9ybV9jbGFzc2VzLm1hcChjbHMgPT4ge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGFyZ3VtZW50c1xuICpcbiAqL1xuY29uc3QgY2xhc3Nlc0FycmF5ID0gYXJncyA9PiB7XG4gIHZhciBjbGFzc2VzID0gW107XG4gIGl0ZXJhdGUoYXJncywgX2NsYXNzZXMgPT4ge1xuICAgIGlmICh0eXBlb2YgX2NsYXNzZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBfY2xhc3NlcyA9IF9jbGFzc2VzLnRyaW0oKS5zcGxpdCgvW1xcdFxcblxcZlxcclxcc10vKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoX2NsYXNzZXMpKSB7XG4gICAgICBjbGFzc2VzID0gY2xhc3Nlcy5jb25jYXQoX2NsYXNzZXMpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjbGFzc2VzLmZpbHRlcihCb29sZWFuKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuIGFycmF5IGZyb20gYXJnIGlmIGl0J3Mgbm90IGFscmVhZHkgYW4gYXJyYXlcbiAqXG4gKi9cbmNvbnN0IGNhc3RBc0FycmF5ID0gYXJnID0+IHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICBhcmcgPSBbYXJnXTtcbiAgfVxuICByZXR1cm4gYXJnO1xufTtcblxuLyoqXG4gKiBQbHVnaW46IFwicmVzdG9yZV9vbl9iYWNrc3BhY2VcIiAoVG9tIFNlbGVjdClcbiAqIENvcHlyaWdodCAoYykgY29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcbiAqIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBwbHVnaW4gKCkge1xuICBjb25zdCBzZWxmID0gdGhpcztcbiAgY29uc3Qgb3JpZ19jYW5Mb2FkID0gc2VsZi5jYW5Mb2FkO1xuICBjb25zdCBvcmlnX2NsZWFyQWN0aXZlT3B0aW9uID0gc2VsZi5jbGVhckFjdGl2ZU9wdGlvbjtcbiAgY29uc3Qgb3JpZ19sb2FkQ2FsbGJhY2sgPSBzZWxmLmxvYWRDYWxsYmFjaztcbiAgdmFyIHBhZ2luYXRpb24gPSB7fTtcbiAgdmFyIGRyb3Bkb3duX2NvbnRlbnQ7XG4gIHZhciBsb2FkaW5nX21vcmUgPSBmYWxzZTtcbiAgdmFyIGxvYWRfbW9yZV9vcHQ7XG4gIHZhciBkZWZhdWx0X3ZhbHVlcyA9IFtdO1xuICBpZiAoIXNlbGYuc2V0dGluZ3Muc2hvdWxkTG9hZE1vcmUpIHtcbiAgICAvLyByZXR1cm4gdHJ1ZSBpZiBhZGRpdGlvbmFsIHJlc3VsdHMgc2hvdWxkIGJlIGxvYWRlZFxuICAgIHNlbGYuc2V0dGluZ3Muc2hvdWxkTG9hZE1vcmUgPSAoKSA9PiB7XG4gICAgICBjb25zdCBzY3JvbGxfcGVyY2VudCA9IGRyb3Bkb3duX2NvbnRlbnQuY2xpZW50SGVpZ2h0IC8gKGRyb3Bkb3duX2NvbnRlbnQuc2Nyb2xsSGVpZ2h0IC0gZHJvcGRvd25fY29udGVudC5zY3JvbGxUb3ApO1xuICAgICAgaWYgKHNjcm9sbF9wZXJjZW50ID4gMC45KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGYuYWN0aXZlT3B0aW9uKSB7XG4gICAgICAgIHZhciBzZWxlY3RhYmxlID0gc2VsZi5zZWxlY3RhYmxlKCk7XG4gICAgICAgIHZhciBpbmRleCA9IEFycmF5LmZyb20oc2VsZWN0YWJsZSkuaW5kZXhPZihzZWxmLmFjdGl2ZU9wdGlvbik7XG4gICAgICAgIGlmIChpbmRleCA+PSBzZWxlY3RhYmxlLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH1cbiAgaWYgKCFzZWxmLnNldHRpbmdzLmZpcnN0VXJsKSB7XG4gICAgdGhyb3cgJ3ZpcnR1YWxfc2Nyb2xsIHBsdWdpbiByZXF1aXJlcyBhIGZpcnN0VXJsKCkgbWV0aG9kJztcbiAgfVxuXG4gIC8vIGluIG9yZGVyIGZvciB2aXJ0dWFsIHNjcm9sbGluZyB0byB3b3JrLFxuICAvLyBvcHRpb25zIG5lZWQgdG8gYmUgb3JkZXJlZCB0aGUgc2FtZSB3YXkgdGhleSdyZSByZXR1cm5lZCBmcm9tIHRoZSByZW1vdGUgZGF0YSBzb3VyY2VcbiAgc2VsZi5zZXR0aW5ncy5zb3J0RmllbGQgPSBbe1xuICAgIGZpZWxkOiAnJG9yZGVyJ1xuICB9LCB7XG4gICAgZmllbGQ6ICckc2NvcmUnXG4gIH1dO1xuXG4gIC8vIGNhbiB3ZSBsb2FkIG1vcmUgcmVzdWx0cyBmb3IgZ2l2ZW4gcXVlcnk/XG4gIGNvbnN0IGNhbkxvYWRNb3JlID0gcXVlcnkgPT4ge1xuICAgIGlmICh0eXBlb2Ygc2VsZi5zZXR0aW5ncy5tYXhPcHRpb25zID09PSAnbnVtYmVyJyAmJiBkcm9wZG93bl9jb250ZW50LmNoaWxkcmVuLmxlbmd0aCA+PSBzZWxmLnNldHRpbmdzLm1heE9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5IGluIHBhZ2luYXRpb24gJiYgcGFnaW5hdGlvbltxdWVyeV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIGNvbnN0IGNsZWFyRmlsdGVyID0gKG9wdGlvbiwgdmFsdWUpID0+IHtcbiAgICBpZiAoc2VsZi5pdGVtcy5pbmRleE9mKHZhbHVlKSA+PSAwIHx8IGRlZmF1bHRfdmFsdWVzLmluZGV4T2YodmFsdWUpID49IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLy8gc2V0IHRoZSBuZXh0IHVybCB0aGF0IHdpbGwgYmVcbiAgc2VsZi5zZXROZXh0VXJsID0gKHZhbHVlLCBuZXh0X3VybCkgPT4ge1xuICAgIHBhZ2luYXRpb25bdmFsdWVdID0gbmV4dF91cmw7XG4gIH07XG5cbiAgLy8gZ2V0VXJsKCkgdG8gYmUgdXNlZCBpbiBzZXR0aW5ncy5sb2FkKClcbiAgc2VsZi5nZXRVcmwgPSBxdWVyeSA9PiB7XG4gICAgaWYgKHF1ZXJ5IGluIHBhZ2luYXRpb24pIHtcbiAgICAgIGNvbnN0IG5leHRfdXJsID0gcGFnaW5hdGlvbltxdWVyeV07XG4gICAgICBwYWdpbmF0aW9uW3F1ZXJ5XSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIG5leHRfdXJsO1xuICAgIH1cblxuICAgIC8vIGlmIHRoZSB1c2VyIGdvZXMgYmFjayB0byBhIHByZXZpb3VzIHF1ZXJ5XG4gICAgLy8gd2UgbmVlZCB0byBsb2FkIHRoZSBmaXJzdCBwYWdlIGFnYWluXG4gICAgc2VsZi5jbGVhclBhZ2luYXRpb24oKTtcbiAgICByZXR1cm4gc2VsZi5zZXR0aW5ncy5maXJzdFVybC5jYWxsKHNlbGYsIHF1ZXJ5KTtcbiAgfTtcblxuICAvLyBjbGVhciBwYWdpbmF0aW9uXG4gIHNlbGYuY2xlYXJQYWdpbmF0aW9uID0gKCkgPT4ge1xuICAgIHBhZ2luYXRpb24gPSB7fTtcbiAgfTtcblxuICAvLyBkb24ndCBjbGVhciB0aGUgYWN0aXZlIG9wdGlvbiAoYW5kIGNhdXNlIHVud2FudGVkIGRyb3Bkb3duIHNjcm9sbClcbiAgLy8gd2hpbGUgbG9hZGluZyBtb3JlIHJlc3VsdHNcbiAgc2VsZi5ob29rKCdpbnN0ZWFkJywgJ2NsZWFyQWN0aXZlT3B0aW9uJywgKCkgPT4ge1xuICAgIGlmIChsb2FkaW5nX21vcmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIG9yaWdfY2xlYXJBY3RpdmVPcHRpb24uY2FsbChzZWxmKTtcbiAgfSk7XG5cbiAgLy8gb3ZlcnJpZGUgdGhlIGNhbkxvYWQgbWV0aG9kXG4gIHNlbGYuaG9vaygnaW5zdGVhZCcsICdjYW5Mb2FkJywgcXVlcnkgPT4ge1xuICAgIC8vIGZpcnN0IHRpbWUgdGhlIHF1ZXJ5IGhhcyBiZWVuIHNlZW5cbiAgICBpZiAoIShxdWVyeSBpbiBwYWdpbmF0aW9uKSkge1xuICAgICAgcmV0dXJuIG9yaWdfY2FuTG9hZC5jYWxsKHNlbGYsIHF1ZXJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbkxvYWRNb3JlKHF1ZXJ5KTtcbiAgfSk7XG5cbiAgLy8gd3JhcCB0aGUgbG9hZFxuICBzZWxmLmhvb2soJ2luc3RlYWQnLCAnbG9hZENhbGxiYWNrJywgKG9wdGlvbnMsIG9wdGdyb3VwcykgPT4ge1xuICAgIGlmICghbG9hZGluZ19tb3JlKSB7XG4gICAgICBzZWxmLmNsZWFyT3B0aW9ucyhjbGVhckZpbHRlcik7XG4gICAgfSBlbHNlIGlmIChsb2FkX21vcmVfb3B0KSB7XG4gICAgICBjb25zdCBmaXJzdF9vcHRpb24gPSBvcHRpb25zWzBdO1xuICAgICAgaWYgKGZpcnN0X29wdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvYWRfbW9yZV9vcHQuZGF0YXNldC52YWx1ZSA9IGZpcnN0X29wdGlvbltzZWxmLnNldHRpbmdzLnZhbHVlRmllbGRdO1xuICAgICAgfVxuICAgIH1cbiAgICBvcmlnX2xvYWRDYWxsYmFjay5jYWxsKHNlbGYsIG9wdGlvbnMsIG9wdGdyb3Vwcyk7XG4gICAgbG9hZGluZ19tb3JlID0gZmFsc2U7XG4gIH0pO1xuXG4gIC8vIGFkZCB0ZW1wbGF0ZXMgdG8gZHJvcGRvd25cbiAgLy9cdGxvYWRpbmdfbW9yZSBpZiB3ZSBoYXZlIGFub3RoZXIgdXJsIGluIHRoZSBxdWV1ZVxuICAvL1x0bm9fbW9yZV9yZXN1bHRzIGlmIHdlIGRvbid0IGhhdmUgYW5vdGhlciB1cmwgaW4gdGhlIHF1ZXVlXG4gIHNlbGYuaG9vaygnYWZ0ZXInLCAncmVmcmVzaE9wdGlvbnMnLCAoKSA9PiB7XG4gICAgY29uc3QgcXVlcnkgPSBzZWxmLmxhc3RWYWx1ZTtcbiAgICB2YXIgb3B0aW9uO1xuICAgIGlmIChjYW5Mb2FkTW9yZShxdWVyeSkpIHtcbiAgICAgIG9wdGlvbiA9IHNlbGYucmVuZGVyKCdsb2FkaW5nX21vcmUnLCB7XG4gICAgICAgIHF1ZXJ5OiBxdWVyeVxuICAgICAgfSk7XG4gICAgICBpZiAob3B0aW9uKSB7XG4gICAgICAgIG9wdGlvbi5zZXRBdHRyaWJ1dGUoJ2RhdGEtc2VsZWN0YWJsZScsICcnKTsgLy8gc28gdGhhdCBuYXZpZ2F0aW5nIGRyb3Bkb3duIHdpdGggW2Rvd25dIGtleXByZXNzZXMgY2FuIG5hdmlnYXRlIHRvIHRoaXMgbm9kZVxuICAgICAgICBsb2FkX21vcmVfb3B0ID0gb3B0aW9uO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocXVlcnkgaW4gcGFnaW5hdGlvbiAmJiAhZHJvcGRvd25fY29udGVudC5xdWVyeVNlbGVjdG9yKCcubm8tcmVzdWx0cycpKSB7XG4gICAgICBvcHRpb24gPSBzZWxmLnJlbmRlcignbm9fbW9yZV9yZXN1bHRzJywge1xuICAgICAgICBxdWVyeTogcXVlcnlcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAob3B0aW9uKSB7XG4gICAgICBhZGRDbGFzc2VzKG9wdGlvbiwgc2VsZi5zZXR0aW5ncy5vcHRpb25DbGFzcyk7XG4gICAgICBkcm9wZG93bl9jb250ZW50LmFwcGVuZChvcHRpb24pO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gYWRkIHNjcm9sbCBsaXN0ZW5lciBhbmQgZGVmYXVsdCB0ZW1wbGF0ZXNcbiAgc2VsZi5vbignaW5pdGlhbGl6ZScsICgpID0+IHtcbiAgICBkZWZhdWx0X3ZhbHVlcyA9IE9iamVjdC5rZXlzKHNlbGYub3B0aW9ucyk7XG4gICAgZHJvcGRvd25fY29udGVudCA9IHNlbGYuZHJvcGRvd25fY29udGVudDtcblxuICAgIC8vIGRlZmF1bHQgdGVtcGxhdGVzXG4gICAgc2VsZi5zZXR0aW5ncy5yZW5kZXIgPSBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgICBsb2FkaW5nX21vcmU6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGA8ZGl2IGNsYXNzPVwibG9hZGluZy1tb3JlLXJlc3VsdHNcIj5Mb2FkaW5nIG1vcmUgcmVzdWx0cyAuLi4gPC9kaXY+YDtcbiAgICAgIH0sXG4gICAgICBub19tb3JlX3Jlc3VsdHM6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGA8ZGl2IGNsYXNzPVwibm8tbW9yZS1yZXN1bHRzXCI+Tm8gbW9yZSByZXN1bHRzPC9kaXY+YDtcbiAgICAgIH1cbiAgICB9LCBzZWxmLnNldHRpbmdzLnJlbmRlcik7XG5cbiAgICAvLyB3YXRjaCBkcm9wZG93biBjb250ZW50IHNjcm9sbCBwb3NpdGlvblxuICAgIGRyb3Bkb3duX2NvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgKCkgPT4ge1xuICAgICAgaWYgKCFzZWxmLnNldHRpbmdzLnNob3VsZExvYWRNb3JlLmNhbGwoc2VsZikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyAhaW1wb3J0YW50OiB0aGlzIHdpbGwgZ2V0IGNoZWNrZWQgYWdhaW4gaW4gbG9hZCgpIGJ1dCB3ZSBzdGlsbCBuZWVkIHRvIGNoZWNrIGhlcmUgb3RoZXJ3aXNlIGxvYWRpbmdfbW9yZSB3aWxsIGJlIHNldCB0byB0cnVlXG4gICAgICBpZiAoIWNhbkxvYWRNb3JlKHNlbGYubGFzdFZhbHVlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGRvbid0IGNhbGwgbG9hZCgpIHRvbyBtdWNoXG4gICAgICBpZiAobG9hZGluZ19tb3JlKSByZXR1cm47XG4gICAgICBsb2FkaW5nX21vcmUgPSB0cnVlO1xuICAgICAgc2VsZi5sb2FkLmNhbGwoc2VsZiwgc2VsZi5sYXN0VmFsdWUpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0IHsgcGx1Z2luIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsdWdpbi5qcy5tYXBcbiIsImltcG9ydCBUb21TZWxlY3QgZnJvbSBcIi4vdG9tLXNlbGVjdC5qc1wiO1xuaW1wb3J0IGNoYW5nZV9saXN0ZW5lciBmcm9tIFwiLi9wbHVnaW5zL2NoYW5nZV9saXN0ZW5lci9wbHVnaW4uanNcIjtcbmltcG9ydCBjaGVja2JveF9vcHRpb25zIGZyb20gXCIuL3BsdWdpbnMvY2hlY2tib3hfb3B0aW9ucy9wbHVnaW4uanNcIjtcbmltcG9ydCBjbGVhcl9idXR0b24gZnJvbSBcIi4vcGx1Z2lucy9jbGVhcl9idXR0b24vcGx1Z2luLmpzXCI7XG5pbXBvcnQgZHJhZ19kcm9wIGZyb20gXCIuL3BsdWdpbnMvZHJhZ19kcm9wL3BsdWdpbi5qc1wiO1xuaW1wb3J0IGRyb3Bkb3duX2hlYWRlciBmcm9tIFwiLi9wbHVnaW5zL2Ryb3Bkb3duX2hlYWRlci9wbHVnaW4uanNcIjtcbmltcG9ydCBjYXJldF9wb3NpdGlvbiBmcm9tIFwiLi9wbHVnaW5zL2NhcmV0X3Bvc2l0aW9uL3BsdWdpbi5qc1wiO1xuaW1wb3J0IGRyb3Bkb3duX2lucHV0IGZyb20gXCIuL3BsdWdpbnMvZHJvcGRvd25faW5wdXQvcGx1Z2luLmpzXCI7XG5pbXBvcnQgaW5wdXRfYXV0b2dyb3cgZnJvbSBcIi4vcGx1Z2lucy9pbnB1dF9hdXRvZ3Jvdy9wbHVnaW4uanNcIjtcbmltcG9ydCBub19iYWNrc3BhY2VfZGVsZXRlIGZyb20gXCIuL3BsdWdpbnMvbm9fYmFja3NwYWNlX2RlbGV0ZS9wbHVnaW4uanNcIjtcbmltcG9ydCBub19hY3RpdmVfaXRlbXMgZnJvbSBcIi4vcGx1Z2lucy9ub19hY3RpdmVfaXRlbXMvcGx1Z2luLmpzXCI7XG5pbXBvcnQgb3B0Z3JvdXBfY29sdW1ucyBmcm9tIFwiLi9wbHVnaW5zL29wdGdyb3VwX2NvbHVtbnMvcGx1Z2luLmpzXCI7XG5pbXBvcnQgcmVtb3ZlX2J1dHRvbiBmcm9tIFwiLi9wbHVnaW5zL3JlbW92ZV9idXR0b24vcGx1Z2luLmpzXCI7XG5pbXBvcnQgcmVzdG9yZV9vbl9iYWNrc3BhY2UgZnJvbSBcIi4vcGx1Z2lucy9yZXN0b3JlX29uX2JhY2tzcGFjZS9wbHVnaW4uanNcIjtcbmltcG9ydCB2aXJ0dWFsX3Njcm9sbCBmcm9tIFwiLi9wbHVnaW5zL3ZpcnR1YWxfc2Nyb2xsL3BsdWdpbi5qc1wiO1xuVG9tU2VsZWN0LmRlZmluZSgnY2hhbmdlX2xpc3RlbmVyJywgY2hhbmdlX2xpc3RlbmVyKTtcblRvbVNlbGVjdC5kZWZpbmUoJ2NoZWNrYm94X29wdGlvbnMnLCBjaGVja2JveF9vcHRpb25zKTtcblRvbVNlbGVjdC5kZWZpbmUoJ2NsZWFyX2J1dHRvbicsIGNsZWFyX2J1dHRvbik7XG5Ub21TZWxlY3QuZGVmaW5lKCdkcmFnX2Ryb3AnLCBkcmFnX2Ryb3ApO1xuVG9tU2VsZWN0LmRlZmluZSgnZHJvcGRvd25faGVhZGVyJywgZHJvcGRvd25faGVhZGVyKTtcblRvbVNlbGVjdC5kZWZpbmUoJ2NhcmV0X3Bvc2l0aW9uJywgY2FyZXRfcG9zaXRpb24pO1xuVG9tU2VsZWN0LmRlZmluZSgnZHJvcGRvd25faW5wdXQnLCBkcm9wZG93bl9pbnB1dCk7XG5Ub21TZWxlY3QuZGVmaW5lKCdpbnB1dF9hdXRvZ3JvdycsIGlucHV0X2F1dG9ncm93KTtcblRvbVNlbGVjdC5kZWZpbmUoJ25vX2JhY2tzcGFjZV9kZWxldGUnLCBub19iYWNrc3BhY2VfZGVsZXRlKTtcblRvbVNlbGVjdC5kZWZpbmUoJ25vX2FjdGl2ZV9pdGVtcycsIG5vX2FjdGl2ZV9pdGVtcyk7XG5Ub21TZWxlY3QuZGVmaW5lKCdvcHRncm91cF9jb2x1bW5zJywgb3B0Z3JvdXBfY29sdW1ucyk7XG5Ub21TZWxlY3QuZGVmaW5lKCdyZW1vdmVfYnV0dG9uJywgcmVtb3ZlX2J1dHRvbik7XG5Ub21TZWxlY3QuZGVmaW5lKCdyZXN0b3JlX29uX2JhY2tzcGFjZScsIHJlc3RvcmVfb25fYmFja3NwYWNlKTtcblRvbVNlbGVjdC5kZWZpbmUoJ3ZpcnR1YWxfc2Nyb2xsJywgdmlydHVhbF9zY3JvbGwpO1xuZXhwb3J0IGRlZmF1bHQgVG9tU2VsZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9tLXNlbGVjdC5jb21wbGV0ZS5qcy5tYXAiLCJpbXBvcnQgTWljcm9FdmVudCBmcm9tIFwiLi9jb250cmliL21pY3JvZXZlbnQuanNcIjtcbmltcG9ydCBNaWNyb1BsdWdpbiBmcm9tIFwiLi9jb250cmliL21pY3JvcGx1Z2luLmpzXCI7XG5pbXBvcnQgeyBTaWZ0ZXIgfSBmcm9tICdAb3JjaGlkanMvc2lmdGVyJztcbmltcG9ydCB7IGVzY2FwZV9yZWdleCB9IGZyb20gJ0BvcmNoaWRqcy91bmljb2RlLXZhcmlhbnRzJztcbmltcG9ydCB7IGhpZ2hsaWdodCwgcmVtb3ZlSGlnaGxpZ2h0IH0gZnJvbSBcIi4vY29udHJpYi9oaWdobGlnaHQuanNcIjtcbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tIFwiLi9jb25zdGFudHMuanNcIjtcbmltcG9ydCBnZXRTZXR0aW5ncyBmcm9tIFwiLi9nZXRTZXR0aW5ncy5qc1wiO1xuaW1wb3J0IHsgaGFzaF9rZXksIGdldF9oYXNoLCBlc2NhcGVfaHRtbCwgZGVib3VuY2VfZXZlbnRzLCBnZXRTZWxlY3Rpb24sIHByZXZlbnREZWZhdWx0LCBhZGRFdmVudCwgbG9hZERlYm91bmNlLCB0aW1lb3V0LCBpc0tleURvd24sIGdldElkLCBhZGRTbGFzaGVzLCBhcHBlbmQsIGl0ZXJhdGUgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuaW1wb3J0IHsgZ2V0RG9tLCBpc0h0bWxTdHJpbmcsIGVzY2FwZVF1ZXJ5LCB0cmlnZ2VyRXZlbnQsIGFwcGx5Q1NTLCBhZGRDbGFzc2VzLCByZW1vdmVDbGFzc2VzLCBwYXJlbnRNYXRjaCwgZ2V0VGFpbCwgaXNFbXB0eU9iamVjdCwgbm9kZUluZGV4LCBzZXRBdHRyLCByZXBsYWNlTm9kZSB9IGZyb20gXCIuL3ZhbmlsbGEuanNcIjtcbnZhciBpbnN0YW5jZV9pID0gMDtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvbVNlbGVjdCBleHRlbmRzIE1pY3JvUGx1Z2luKE1pY3JvRXZlbnQpIHtcbiAgICBjb25zdHJ1Y3RvcihpbnB1dF9hcmcsIHVzZXJfc2V0dGluZ3MpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5vcmRlciA9IDA7XG4gICAgICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNEaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzUmVhZE9ubHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0ludmFsaWQgPSBmYWxzZTsgLy8gQGRlcHJlY2F0ZWQgMS44XG4gICAgICAgIHRoaXMuaXNWYWxpZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNMb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0lucHV0SGlkZGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNTZXR1cCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlnbm9yZUZvY3VzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaWdub3JlSG92ZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNPcHRpb25zID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFzdFZhbHVlID0gJyc7XG4gICAgICAgIHRoaXMuY2FyZXRQb3MgPSAwO1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSAwO1xuICAgICAgICB0aGlzLmxvYWRlZFNlYXJjaGVzID0ge307XG4gICAgICAgIHRoaXMuYWN0aXZlT3B0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5hY3RpdmVJdGVtcyA9IFtdO1xuICAgICAgICB0aGlzLm9wdGdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy51c2VyT3B0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLml0ZW1zID0gW107XG4gICAgICAgIHRoaXMucmVmcmVzaFRpbWVvdXQgPSBudWxsO1xuICAgICAgICBpbnN0YW5jZV9pKys7XG4gICAgICAgIHZhciBkaXI7XG4gICAgICAgIHZhciBpbnB1dCA9IGdldERvbShpbnB1dF9hcmcpO1xuICAgICAgICBpZiAoaW5wdXQudG9tc2VsZWN0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbSBTZWxlY3QgYWxyZWFkeSBpbml0aWFsaXplZCBvbiB0aGlzIGVsZW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dC50b21zZWxlY3QgPSB0aGlzO1xuICAgICAgICAvLyBkZXRlY3QgcnRsIGVudmlyb25tZW50XG4gICAgICAgIHZhciBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgJiYgd2luZG93LmdldENvbXB1dGVkU3R5bGUoaW5wdXQsIG51bGwpO1xuICAgICAgICBkaXIgPSBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpO1xuICAgICAgICAvLyBzZXR1cCBkZWZhdWx0IHN0YXRlXG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gZ2V0U2V0dGluZ3MoaW5wdXQsIHVzZXJfc2V0dGluZ3MpO1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy50YWJJbmRleCA9IGlucHV0LnRhYkluZGV4IHx8IDA7XG4gICAgICAgIHRoaXMuaXNfc2VsZWN0X3RhZyA9IGlucHV0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3NlbGVjdCc7XG4gICAgICAgIHRoaXMucnRsID0gL3J0bC9pLnRlc3QoZGlyKTtcbiAgICAgICAgdGhpcy5pbnB1dElkID0gZ2V0SWQoaW5wdXQsICd0b21zZWxlY3QtJyArIGluc3RhbmNlX2kpO1xuICAgICAgICB0aGlzLmlzUmVxdWlyZWQgPSBpbnB1dC5yZXF1aXJlZDtcbiAgICAgICAgLy8gc2VhcmNoIHN5c3RlbVxuICAgICAgICB0aGlzLnNpZnRlciA9IG5ldyBTaWZ0ZXIodGhpcy5vcHRpb25zLCB7IGRpYWNyaXRpY3M6IHNldHRpbmdzLmRpYWNyaXRpY3MgfSk7XG4gICAgICAgIC8vIG9wdGlvbi1kZXBlbmRlbnQgZGVmYXVsdHNcbiAgICAgICAgc2V0dGluZ3MubW9kZSA9IHNldHRpbmdzLm1vZGUgfHwgKHNldHRpbmdzLm1heEl0ZW1zID09PSAxID8gJ3NpbmdsZScgOiAnbXVsdGknKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5oaWRlU2VsZWN0ZWQgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgc2V0dGluZ3MuaGlkZVNlbGVjdGVkID0gc2V0dGluZ3MubW9kZSA9PT0gJ211bHRpJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLmhpZGVQbGFjZWhvbGRlciAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5oaWRlUGxhY2Vob2xkZXIgPSBzZXR0aW5ncy5tb2RlICE9PSAnbXVsdGknO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCB1cCBjcmVhdGVGaWx0ZXIgY2FsbGJhY2tcbiAgICAgICAgdmFyIGZpbHRlciA9IHNldHRpbmdzLmNyZWF0ZUZpbHRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGZpbHRlciA9IG5ldyBSZWdFeHAoZmlsdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5jcmVhdGVGaWx0ZXIgPSAoaW5wdXQpID0+IGZpbHRlci50ZXN0KGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmNyZWF0ZUZpbHRlciA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5kdXBsaWNhdGVzIHx8ICF0aGlzLm9wdGlvbnNbdmFsdWVdO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0aWFsaXplUGx1Z2lucyhzZXR0aW5ncy5wbHVnaW5zKTtcbiAgICAgICAgdGhpcy5zZXR1cENhbGxiYWNrcygpO1xuICAgICAgICB0aGlzLnNldHVwVGVtcGxhdGVzKCk7XG4gICAgICAgIC8vIENyZWF0ZSBhbGwgZWxlbWVudHNcbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IGdldERvbSgnPGRpdj4nKTtcbiAgICAgICAgY29uc3QgY29udHJvbCA9IGdldERvbSgnPGRpdj4nKTtcbiAgICAgICAgY29uc3QgZHJvcGRvd24gPSB0aGlzLl9yZW5kZXIoJ2Ryb3Bkb3duJyk7XG4gICAgICAgIGNvbnN0IGRyb3Bkb3duX2NvbnRlbnQgPSBnZXREb20oYDxkaXYgcm9sZT1cImxpc3Rib3hcIiB0YWJpbmRleD1cIi0xXCI+YCk7XG4gICAgICAgIGNvbnN0IGNsYXNzZXMgPSB0aGlzLmlucHV0LmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJztcbiAgICAgICAgY29uc3QgaW5wdXRNb2RlID0gc2V0dGluZ3MubW9kZTtcbiAgICAgICAgdmFyIGNvbnRyb2xfaW5wdXQ7XG4gICAgICAgIGFkZENsYXNzZXMod3JhcHBlciwgc2V0dGluZ3Mud3JhcHBlckNsYXNzLCBjbGFzc2VzLCBpbnB1dE1vZGUpO1xuICAgICAgICBhZGRDbGFzc2VzKGNvbnRyb2wsIHNldHRpbmdzLmNvbnRyb2xDbGFzcyk7XG4gICAgICAgIGFwcGVuZCh3cmFwcGVyLCBjb250cm9sKTtcbiAgICAgICAgYWRkQ2xhc3Nlcyhkcm9wZG93biwgc2V0dGluZ3MuZHJvcGRvd25DbGFzcywgaW5wdXRNb2RlKTtcbiAgICAgICAgaWYgKHNldHRpbmdzLmNvcHlDbGFzc2VzVG9Ecm9wZG93bikge1xuICAgICAgICAgICAgYWRkQ2xhc3Nlcyhkcm9wZG93biwgY2xhc3Nlcyk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkQ2xhc3Nlcyhkcm9wZG93bl9jb250ZW50LCBzZXR0aW5ncy5kcm9wZG93bkNvbnRlbnRDbGFzcyk7XG4gICAgICAgIGFwcGVuZChkcm9wZG93biwgZHJvcGRvd25fY29udGVudCk7XG4gICAgICAgIGdldERvbShzZXR0aW5ncy5kcm9wZG93blBhcmVudCB8fCB3cmFwcGVyKS5hcHBlbmRDaGlsZChkcm9wZG93bik7XG4gICAgICAgIC8vIGRlZmF1bHQgY29udHJvbElucHV0XG4gICAgICAgIGlmIChpc0h0bWxTdHJpbmcoc2V0dGluZ3MuY29udHJvbElucHV0KSkge1xuICAgICAgICAgICAgY29udHJvbF9pbnB1dCA9IGdldERvbShzZXR0aW5ncy5jb250cm9sSW5wdXQpO1xuICAgICAgICAgICAgLy8gc2V0IGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIHZhciBhdHRycyA9IFsnYXV0b2NvcnJlY3QnLCAnYXV0b2NhcGl0YWxpemUnLCAnYXV0b2NvbXBsZXRlJywgJ3NwZWxsY2hlY2snXTtcbiAgICAgICAgICAgIGl0ZXJhdGUoYXR0cnMsIChhdHRyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmdldEF0dHJpYnV0ZShhdHRyKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRBdHRyKGNvbnRyb2xfaW5wdXQsIHsgW2F0dHJdOiBpbnB1dC5nZXRBdHRyaWJ1dGUoYXR0cikgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250cm9sX2lucHV0LnRhYkluZGV4ID0gLTE7XG4gICAgICAgICAgICBjb250cm9sLmFwcGVuZENoaWxkKGNvbnRyb2xfaW5wdXQpO1xuICAgICAgICAgICAgdGhpcy5mb2N1c19ub2RlID0gY29udHJvbF9pbnB1dDtcbiAgICAgICAgICAgIC8vIGRvbSBlbGVtZW50XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2V0dGluZ3MuY29udHJvbElucHV0KSB7XG4gICAgICAgICAgICBjb250cm9sX2lucHV0ID0gZ2V0RG9tKHNldHRpbmdzLmNvbnRyb2xJbnB1dCk7XG4gICAgICAgICAgICB0aGlzLmZvY3VzX25vZGUgPSBjb250cm9sX2lucHV0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udHJvbF9pbnB1dCA9IGdldERvbSgnPGlucHV0Lz4nKTtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNfbm9kZSA9IGNvbnRyb2w7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cmFwcGVyID0gd3JhcHBlcjtcbiAgICAgICAgdGhpcy5kcm9wZG93biA9IGRyb3Bkb3duO1xuICAgICAgICB0aGlzLmRyb3Bkb3duX2NvbnRlbnQgPSBkcm9wZG93bl9jb250ZW50O1xuICAgICAgICB0aGlzLmNvbnRyb2wgPSBjb250cm9sO1xuICAgICAgICB0aGlzLmNvbnRyb2xfaW5wdXQgPSBjb250cm9sX2lucHV0O1xuICAgICAgICB0aGlzLnNldHVwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNldCB1cCBldmVudCBiaW5kaW5ncy5cbiAgICAgKlxuICAgICAqL1xuICAgIHNldHVwKCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBzZWxmLnNldHRpbmdzO1xuICAgICAgICBjb25zdCBjb250cm9sX2lucHV0ID0gc2VsZi5jb250cm9sX2lucHV0O1xuICAgICAgICBjb25zdCBkcm9wZG93biA9IHNlbGYuZHJvcGRvd247XG4gICAgICAgIGNvbnN0IGRyb3Bkb3duX2NvbnRlbnQgPSBzZWxmLmRyb3Bkb3duX2NvbnRlbnQ7XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSBzZWxmLndyYXBwZXI7XG4gICAgICAgIGNvbnN0IGNvbnRyb2wgPSBzZWxmLmNvbnRyb2w7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gc2VsZi5pbnB1dDtcbiAgICAgICAgY29uc3QgZm9jdXNfbm9kZSA9IHNlbGYuZm9jdXNfbm9kZTtcbiAgICAgICAgY29uc3QgcGFzc2l2ZV9ldmVudCA9IHsgcGFzc2l2ZTogdHJ1ZSB9O1xuICAgICAgICBjb25zdCBsaXN0Ym94SWQgPSBzZWxmLmlucHV0SWQgKyAnLXRzLWRyb3Bkb3duJztcbiAgICAgICAgc2V0QXR0cihkcm9wZG93bl9jb250ZW50LCB7XG4gICAgICAgICAgICBpZDogbGlzdGJveElkXG4gICAgICAgIH0pO1xuICAgICAgICBzZXRBdHRyKGZvY3VzX25vZGUsIHtcbiAgICAgICAgICAgIHJvbGU6ICdjb21ib2JveCcsXG4gICAgICAgICAgICAnYXJpYS1oYXNwb3B1cCc6ICdsaXN0Ym94JyxcbiAgICAgICAgICAgICdhcmlhLWV4cGFuZGVkJzogJ2ZhbHNlJyxcbiAgICAgICAgICAgICdhcmlhLWNvbnRyb2xzJzogbGlzdGJveElkXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjb250cm9sX2lkID0gZ2V0SWQoZm9jdXNfbm9kZSwgc2VsZi5pbnB1dElkICsgJy10cy1jb250cm9sJyk7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gXCJsYWJlbFtmb3I9J1wiICsgZXNjYXBlUXVlcnkoc2VsZi5pbnB1dElkKSArIFwiJ11cIjtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHF1ZXJ5KTtcbiAgICAgICAgY29uc3QgbGFiZWxfY2xpY2sgPSBzZWxmLmZvY3VzLmJpbmQoc2VsZik7XG4gICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgICAgYWRkRXZlbnQobGFiZWwsICdjbGljaycsIGxhYmVsX2NsaWNrKTtcbiAgICAgICAgICAgIHNldEF0dHIobGFiZWwsIHsgZm9yOiBjb250cm9sX2lkIH0pO1xuICAgICAgICAgICAgY29uc3QgbGFiZWxfaWQgPSBnZXRJZChsYWJlbCwgc2VsZi5pbnB1dElkICsgJy10cy1sYWJlbCcpO1xuICAgICAgICAgICAgc2V0QXR0cihmb2N1c19ub2RlLCB7ICdhcmlhLWxhYmVsbGVkYnknOiBsYWJlbF9pZCB9KTtcbiAgICAgICAgICAgIHNldEF0dHIoZHJvcGRvd25fY29udGVudCwgeyAnYXJpYS1sYWJlbGxlZGJ5JzogbGFiZWxfaWQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgd3JhcHBlci5zdHlsZS53aWR0aCA9IGlucHV0LnN0eWxlLndpZHRoO1xuICAgICAgICBpZiAoc2VsZi5wbHVnaW5zLm5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgY2xhc3Nlc19wbHVnaW5zID0gJ3BsdWdpbi0nICsgc2VsZi5wbHVnaW5zLm5hbWVzLmpvaW4oJyBwbHVnaW4tJyk7XG4gICAgICAgICAgICBhZGRDbGFzc2VzKFt3cmFwcGVyLCBkcm9wZG93bl0sIGNsYXNzZXNfcGx1Z2lucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzZXR0aW5ncy5tYXhJdGVtcyA9PT0gbnVsbCB8fCBzZXR0aW5ncy5tYXhJdGVtcyA+IDEpICYmIHNlbGYuaXNfc2VsZWN0X3RhZykge1xuICAgICAgICAgICAgc2V0QXR0cihpbnB1dCwgeyBtdWx0aXBsZTogJ211bHRpcGxlJyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MucGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgIHNldEF0dHIoY29udHJvbF9pbnB1dCwgeyBwbGFjZWhvbGRlcjogc2V0dGluZ3MucGxhY2Vob2xkZXIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgc3BsaXRPbiB3YXMgbm90IHBhc3NlZCBpbiwgY29uc3RydWN0IGl0IGZyb20gdGhlIGRlbGltaXRlciB0byBhbGxvdyBwYXN0aW5nIHVuaXZlcnNhbGx5XG4gICAgICAgIGlmICghc2V0dGluZ3Muc3BsaXRPbiAmJiBzZXR0aW5ncy5kZWxpbWl0ZXIpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnNwbGl0T24gPSBuZXcgUmVnRXhwKCdcXFxccyonICsgZXNjYXBlX3JlZ2V4KHNldHRpbmdzLmRlbGltaXRlcikgKyAnK1xcXFxzKicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRlYm91bmNlIHVzZXIgZGVmaW5lZCBsb2FkKCkgaWYgbG9hZFRocm90dGxlID4gMFxuICAgICAgICAvLyBhZnRlciBpbml0aWFsaXplUGx1Z2lucygpIHNvIHBsdWdpbnMgY2FuIGNyZWF0ZS9tb2RpZnkgdXNlciBkZWZpbmVkIGxvYWRlcnNcbiAgICAgICAgaWYgKHNldHRpbmdzLmxvYWQgJiYgc2V0dGluZ3MubG9hZFRocm90dGxlKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5sb2FkID0gbG9hZERlYm91bmNlKHNldHRpbmdzLmxvYWQsIHNldHRpbmdzLmxvYWRUaHJvdHRsZSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkRXZlbnQoZHJvcGRvd24sICdtb3VzZW1vdmUnLCAoKSA9PiB7XG4gICAgICAgICAgICBzZWxmLmlnbm9yZUhvdmVyID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBhZGRFdmVudChkcm9wZG93biwgJ21vdXNlZW50ZXInLCAoZSkgPT4ge1xuICAgICAgICAgICAgdmFyIHRhcmdldF9tYXRjaCA9IHBhcmVudE1hdGNoKGUudGFyZ2V0LCAnW2RhdGEtc2VsZWN0YWJsZV0nLCBkcm9wZG93bik7XG4gICAgICAgICAgICBpZiAodGFyZ2V0X21hdGNoKVxuICAgICAgICAgICAgICAgIHNlbGYub25PcHRpb25Ib3ZlcihlLCB0YXJnZXRfbWF0Y2gpO1xuICAgICAgICB9LCB7IGNhcHR1cmU6IHRydWUgfSk7XG4gICAgICAgIC8vIGNsaWNraW5nIG9uIGFuIG9wdGlvbiBzaG91bGQgc2VsZWN0IGl0XG4gICAgICAgIGFkZEV2ZW50KGRyb3Bkb3duLCAnY2xpY2snLCAoZXZ0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb24gPSBwYXJlbnRNYXRjaChldnQudGFyZ2V0LCAnW2RhdGEtc2VsZWN0YWJsZV0nKTtcbiAgICAgICAgICAgIGlmIChvcHRpb24pIHtcbiAgICAgICAgICAgICAgICBzZWxmLm9uT3B0aW9uU2VsZWN0KGV2dCwgb3B0aW9uKTtcbiAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChldnQsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYWRkRXZlbnQoY29udHJvbCwgJ2NsaWNrJywgKGV2dCkgPT4ge1xuICAgICAgICAgICAgdmFyIHRhcmdldF9tYXRjaCA9IHBhcmVudE1hdGNoKGV2dC50YXJnZXQsICdbZGF0YS10cy1pdGVtXScsIGNvbnRyb2wpO1xuICAgICAgICAgICAgaWYgKHRhcmdldF9tYXRjaCAmJiBzZWxmLm9uSXRlbVNlbGVjdChldnQsIHRhcmdldF9tYXRjaCkpIHtcbiAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChldnQsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJldGFpbiBmb2N1cyAoc2VlIGNvbnRyb2xfaW5wdXQgbW91c2Vkb3duKVxuICAgICAgICAgICAgaWYgKGNvbnRyb2xfaW5wdXQudmFsdWUgIT0gJycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLm9uQ2xpY2soKTtcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGV2dCwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBrZXlkb3duIG9uIGZvY3VzX25vZGUgZm9yIGFycm93X2Rvd24vYXJyb3dfdXBcbiAgICAgICAgYWRkRXZlbnQoZm9jdXNfbm9kZSwgJ2tleWRvd24nLCAoZSkgPT4gc2VsZi5vbktleURvd24oZSkpO1xuICAgICAgICAvLyBrZXlwcmVzcyBhbmQgaW5wdXQva2V5dXBcbiAgICAgICAgYWRkRXZlbnQoY29udHJvbF9pbnB1dCwgJ2tleXByZXNzJywgKGUpID0+IHNlbGYub25LZXlQcmVzcyhlKSk7XG4gICAgICAgIGFkZEV2ZW50KGNvbnRyb2xfaW5wdXQsICdpbnB1dCcsIChlKSA9PiBzZWxmLm9uSW5wdXQoZSkpO1xuICAgICAgICBhZGRFdmVudChmb2N1c19ub2RlLCAnYmx1cicsIChlKSA9PiBzZWxmLm9uQmx1cihlKSk7XG4gICAgICAgIGFkZEV2ZW50KGZvY3VzX25vZGUsICdmb2N1cycsIChlKSA9PiBzZWxmLm9uRm9jdXMoZSkpO1xuICAgICAgICBhZGRFdmVudChjb250cm9sX2lucHV0LCAncGFzdGUnLCAoZSkgPT4gc2VsZi5vblBhc3RlKGUpKTtcbiAgICAgICAgY29uc3QgZG9jX21vdXNlZG93biA9IChldnQpID0+IHtcbiAgICAgICAgICAgIC8vIGJsdXIgaWYgdGFyZ2V0IGlzIG91dHNpZGUgb2YgdGhpcyBpbnN0YW5jZVxuICAgICAgICAgICAgLy8gZHJvcGRvd24gaXMgbm90IGFsd2F5cyBpbnNpZGUgd3JhcHBlclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZ0LmNvbXBvc2VkUGF0aCgpWzBdO1xuICAgICAgICAgICAgaWYgKCF3cmFwcGVyLmNvbnRhaW5zKHRhcmdldCkgJiYgIWRyb3Bkb3duLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5pc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5ibHVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJldGFpbiBmb2N1cyBieSBwcmV2ZW50aW5nIG5hdGl2ZSBoYW5kbGluZy4gaWYgdGhlXG4gICAgICAgICAgICAvLyBldmVudCB0YXJnZXQgaXMgdGhlIGlucHV0IGl0IHNob3VsZCBub3QgYmUgbW9kaWZpZWQuXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UsIHRleHQgc2VsZWN0aW9uIHdpdGhpbiB0aGUgaW5wdXQgd29uJ3Qgd29yay5cbiAgICAgICAgICAgIC8vIEZpeGVzIGJ1ZyAjMjEyIHdoaWNoIGlzIG5vIGNvdmVyZWQgYnkgdGVzdHNcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT0gY29udHJvbF9pbnB1dCAmJiBzZWxmLmlzT3Blbikge1xuICAgICAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAvLyBjbGlja2luZyBhbnl3aGVyZSBpbiB0aGUgY29udHJvbCBzaG91bGQgbm90IGJsdXIgdGhlIGNvbnRyb2xfaW5wdXQgKHdoaWNoIHdvdWxkIGNsb3NlIHRoZSBkcm9wZG93bilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGV2dCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHdpbl9zY3JvbGwgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2VsZi5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICBzZWxmLnBvc2l0aW9uRHJvcGRvd24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYWRkRXZlbnQoZG9jdW1lbnQsICdtb3VzZWRvd24nLCBkb2NfbW91c2Vkb3duKTtcbiAgICAgICAgYWRkRXZlbnQod2luZG93LCAnc2Nyb2xsJywgd2luX3Njcm9sbCwgcGFzc2l2ZV9ldmVudCk7XG4gICAgICAgIGFkZEV2ZW50KHdpbmRvdywgJ3Jlc2l6ZScsIHdpbl9zY3JvbGwsIHBhc3NpdmVfZXZlbnQpO1xuICAgICAgICB0aGlzLl9kZXN0cm95ID0gKCkgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZG9jX21vdXNlZG93bik7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgd2luX3Njcm9sbCk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgd2luX3Njcm9sbCk7XG4gICAgICAgICAgICBpZiAobGFiZWwpXG4gICAgICAgICAgICAgICAgbGFiZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBsYWJlbF9jbGljayk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHN0b3JlIG9yaWdpbmFsIGh0bWwgYW5kIHRhYiBpbmRleCBzbyB0aGF0IHRoZXkgY2FuIGJlXG4gICAgICAgIC8vIHJlc3RvcmVkIHdoZW4gdGhlIGRlc3Ryb3koKSBtZXRob2QgaXMgY2FsbGVkLlxuICAgICAgICB0aGlzLnJldmVydFNldHRpbmdzID0ge1xuICAgICAgICAgICAgaW5uZXJIVE1MOiBpbnB1dC5pbm5lckhUTUwsXG4gICAgICAgICAgICB0YWJJbmRleDogaW5wdXQudGFiSW5kZXhcbiAgICAgICAgfTtcbiAgICAgICAgaW5wdXQudGFiSW5kZXggPSAtMTtcbiAgICAgICAgaW5wdXQuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdhZnRlcmVuZCcsIHNlbGYud3JhcHBlcik7XG4gICAgICAgIHNlbGYuc3luYyhmYWxzZSk7XG4gICAgICAgIHNldHRpbmdzLml0ZW1zID0gW107XG4gICAgICAgIGRlbGV0ZSBzZXR0aW5ncy5vcHRncm91cHM7XG4gICAgICAgIGRlbGV0ZSBzZXR0aW5ncy5vcHRpb25zO1xuICAgICAgICBhZGRFdmVudChpbnB1dCwgJ2ludmFsaWQnLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2VsZi5pc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2VsZi5pc0ludmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNlbGYucmVmcmVzaFN0YXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzZWxmLnVwZGF0ZU9yaWdpbmFsSW5wdXQoKTtcbiAgICAgICAgc2VsZi5yZWZyZXNoSXRlbXMoKTtcbiAgICAgICAgc2VsZi5jbG9zZShmYWxzZSk7XG4gICAgICAgIHNlbGYuaW5wdXRTdGF0ZSgpO1xuICAgICAgICBzZWxmLmlzU2V0dXAgPSB0cnVlO1xuICAgICAgICBpZiAoaW5wdXQuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHNlbGYuZGlzYWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlucHV0LnJlYWRPbmx5KSB7XG4gICAgICAgICAgICBzZWxmLnNldFJlYWRPbmx5KHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5lbmFibGUoKTsgLy9zZXRzIHRhYkluZGV4XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5vbignY2hhbmdlJywgdGhpcy5vbkNoYW5nZSk7XG4gICAgICAgIGFkZENsYXNzZXMoaW5wdXQsICd0b21zZWxlY3RlZCcsICd0cy1oaWRkZW4tYWNjZXNzaWJsZScpO1xuICAgICAgICBzZWxmLnRyaWdnZXIoJ2luaXRpYWxpemUnKTtcbiAgICAgICAgLy8gcHJlbG9hZCBvcHRpb25zXG4gICAgICAgIGlmIChzZXR0aW5ncy5wcmVsb2FkID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzZWxmLnByZWxvYWQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBvcHRpb25zIGFuZCBvcHRncm91cHNcbiAgICAgKlxuICAgICAqL1xuICAgIHNldHVwT3B0aW9ucyhvcHRpb25zID0gW10sIG9wdGdyb3VwcyA9IFtdKSB7XG4gICAgICAgIC8vIGJ1aWxkIG9wdGlvbnMgdGFibGVcbiAgICAgICAgdGhpcy5hZGRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAvLyBidWlsZCBvcHRncm91cCB0YWJsZVxuICAgICAgICBpdGVyYXRlKG9wdGdyb3VwcywgKG9wdGdyb3VwKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyT3B0aW9uR3JvdXAob3B0Z3JvdXApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB1cCBkZWZhdWx0IHJlbmRlcmluZyBmdW5jdGlvbnMuXG4gICAgICovXG4gICAgc2V0dXBUZW1wbGF0ZXMoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGZpZWxkX2xhYmVsID0gc2VsZi5zZXR0aW5ncy5sYWJlbEZpZWxkO1xuICAgICAgICB2YXIgZmllbGRfb3B0Z3JvdXAgPSBzZWxmLnNldHRpbmdzLm9wdGdyb3VwTGFiZWxGaWVsZDtcbiAgICAgICAgdmFyIHRlbXBsYXRlcyA9IHtcbiAgICAgICAgICAgICdvcHRncm91cCc6IChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG9wdGdyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgb3B0Z3JvdXAuY2xhc3NOYW1lID0gJ29wdGdyb3VwJztcbiAgICAgICAgICAgICAgICBvcHRncm91cC5hcHBlbmRDaGlsZChkYXRhLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHRncm91cDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnb3B0Z3JvdXBfaGVhZGVyJzogKGRhdGEsIGVzY2FwZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAnPGRpdiBjbGFzcz1cIm9wdGdyb3VwLWhlYWRlclwiPicgKyBlc2NhcGUoZGF0YVtmaWVsZF9vcHRncm91cF0pICsgJzwvZGl2Pic7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ29wdGlvbic6IChkYXRhLCBlc2NhcGUpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJzxkaXY+JyArIGVzY2FwZShkYXRhW2ZpZWxkX2xhYmVsXSkgKyAnPC9kaXY+JztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnaXRlbSc6IChkYXRhLCBlc2NhcGUpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJzxkaXY+JyArIGVzY2FwZShkYXRhW2ZpZWxkX2xhYmVsXSkgKyAnPC9kaXY+JztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnb3B0aW9uX2NyZWF0ZSc6IChkYXRhLCBlc2NhcGUpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJzxkaXYgY2xhc3M9XCJjcmVhdGVcIj5BZGQgPHN0cm9uZz4nICsgZXNjYXBlKGRhdGEuaW5wdXQpICsgJzwvc3Ryb25nPiZoZWxsaXA7PC9kaXY+JztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbm9fcmVzdWx0cyc6ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJzxkaXYgY2xhc3M9XCJuby1yZXN1bHRzXCI+Tm8gcmVzdWx0cyBmb3VuZDwvZGl2Pic7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2xvYWRpbmcnOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICc8ZGl2IGNsYXNzPVwic3Bpbm5lclwiPjwvZGl2Pic7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ25vdF9sb2FkaW5nJzogKCkgPT4geyB9LFxuICAgICAgICAgICAgJ2Ryb3Bkb3duJzogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAnPGRpdj48L2Rpdj4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzZWxmLnNldHRpbmdzLnJlbmRlciA9IE9iamVjdC5hc3NpZ24oe30sIHRlbXBsYXRlcywgc2VsZi5zZXR0aW5ncy5yZW5kZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXBzIGZpcmVkIGV2ZW50cyB0byBjYWxsYmFja3MgcHJvdmlkZWRcbiAgICAgKiBpbiB0aGUgc2V0dGluZ3MgdXNlZCB3aGVuIGNyZWF0aW5nIHRoZSBjb250cm9sLlxuICAgICAqL1xuICAgIHNldHVwQ2FsbGJhY2tzKCkge1xuICAgICAgICB2YXIga2V5LCBmbjtcbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgICdpbml0aWFsaXplJzogJ29uSW5pdGlhbGl6ZScsXG4gICAgICAgICAgICAnY2hhbmdlJzogJ29uQ2hhbmdlJyxcbiAgICAgICAgICAgICdpdGVtX2FkZCc6ICdvbkl0ZW1BZGQnLFxuICAgICAgICAgICAgJ2l0ZW1fcmVtb3ZlJzogJ29uSXRlbVJlbW92ZScsXG4gICAgICAgICAgICAnaXRlbV9zZWxlY3QnOiAnb25JdGVtU2VsZWN0JyxcbiAgICAgICAgICAgICdjbGVhcic6ICdvbkNsZWFyJyxcbiAgICAgICAgICAgICdvcHRpb25fYWRkJzogJ29uT3B0aW9uQWRkJyxcbiAgICAgICAgICAgICdvcHRpb25fcmVtb3ZlJzogJ29uT3B0aW9uUmVtb3ZlJyxcbiAgICAgICAgICAgICdvcHRpb25fY2xlYXInOiAnb25PcHRpb25DbGVhcicsXG4gICAgICAgICAgICAnb3B0Z3JvdXBfYWRkJzogJ29uT3B0aW9uR3JvdXBBZGQnLFxuICAgICAgICAgICAgJ29wdGdyb3VwX3JlbW92ZSc6ICdvbk9wdGlvbkdyb3VwUmVtb3ZlJyxcbiAgICAgICAgICAgICdvcHRncm91cF9jbGVhcic6ICdvbk9wdGlvbkdyb3VwQ2xlYXInLFxuICAgICAgICAgICAgJ2Ryb3Bkb3duX29wZW4nOiAnb25Ecm9wZG93bk9wZW4nLFxuICAgICAgICAgICAgJ2Ryb3Bkb3duX2Nsb3NlJzogJ29uRHJvcGRvd25DbG9zZScsXG4gICAgICAgICAgICAndHlwZSc6ICdvblR5cGUnLFxuICAgICAgICAgICAgJ2xvYWQnOiAnb25Mb2FkJyxcbiAgICAgICAgICAgICdmb2N1cyc6ICdvbkZvY3VzJyxcbiAgICAgICAgICAgICdibHVyJzogJ29uQmx1cidcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChrZXkgaW4gY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICBmbiA9IHRoaXMuc2V0dGluZ3NbY2FsbGJhY2tzW2tleV1dO1xuICAgICAgICAgICAgaWYgKGZuKVxuICAgICAgICAgICAgICAgIHRoaXMub24oa2V5LCBmbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3luYyB0aGUgVG9tIFNlbGVjdCBpbnN0YW5jZSB3aXRoIHRoZSBvcmlnaW5hbCBpbnB1dCBvciBzZWxlY3RcbiAgICAgKlxuICAgICAqL1xuICAgIHN5bmMoZ2V0X3NldHRpbmdzID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRfc2V0dGluZ3MgPyBnZXRTZXR0aW5ncyhzZWxmLmlucHV0LCB7IGRlbGltaXRlcjogc2VsZi5zZXR0aW5ncy5kZWxpbWl0ZXIgfSkgOiBzZWxmLnNldHRpbmdzO1xuICAgICAgICBzZWxmLnNldHVwT3B0aW9ucyhzZXR0aW5ncy5vcHRpb25zLCBzZXR0aW5ncy5vcHRncm91cHMpO1xuICAgICAgICBzZWxmLnNldFZhbHVlKHNldHRpbmdzLml0ZW1zIHx8IFtdLCB0cnVlKTsgLy8gc2lsZW50IHByZXZlbnRzIHJlY3Vyc2lvblxuICAgICAgICBzZWxmLmxhc3RRdWVyeSA9IG51bGw7IC8vIHNvIHVwZGF0ZWQgb3B0aW9ucyB3aWxsIGJlIGRpc3BsYXllZCBpbiBkcm9wZG93blxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiB0aGUgbWFpbiBjb250cm9sIGVsZW1lbnRcbiAgICAgKiBoYXMgYSBjbGljayBldmVudC5cbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ2xpY2soKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKHNlbGYuYWN0aXZlSXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc2VsZi5jbGVhckFjdGl2ZUl0ZW1zKCk7XG4gICAgICAgICAgICBzZWxmLmZvY3VzKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYuaXNGb2N1c2VkICYmIHNlbGYuaXNPcGVuKSB7XG4gICAgICAgICAgICBzZWxmLmJsdXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCB2MS43XG4gICAgICpcbiAgICAgKi9cbiAgICBvbk1vdXNlRG93bigpIHsgfVxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIHRoZSB2YWx1ZSBvZiB0aGUgY29udHJvbCBoYXMgYmVlbiBjaGFuZ2VkLlxuICAgICAqIFRoaXMgc2hvdWxkIHByb3BhZ2F0ZSB0aGUgZXZlbnQgdG8gdGhlIG9yaWdpbmFsIERPTVxuICAgICAqIGlucHV0IC8gc2VsZWN0IGVsZW1lbnQuXG4gICAgICovXG4gICAgb25DaGFuZ2UoKSB7XG4gICAgICAgIHRyaWdnZXJFdmVudCh0aGlzLmlucHV0LCAnaW5wdXQnKTtcbiAgICAgICAgdHJpZ2dlckV2ZW50KHRoaXMuaW5wdXQsICdjaGFuZ2UnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIG9uIDxpbnB1dD4gcGFzdGUuXG4gICAgICpcbiAgICAgKi9cbiAgICBvblBhc3RlKGUpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoc2VsZi5pc0lucHV0SGlkZGVuIHx8IHNlbGYuaXNMb2NrZWQpIHtcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGEgcmVnZXggb3Igc3RyaW5nIGlzIGluY2x1ZGVkLCB0aGlzIHdpbGwgc3BsaXQgdGhlIHBhc3RlZFxuICAgICAgICAvLyBpbnB1dCBhbmQgY3JlYXRlIEl0ZW1zIGZvciBlYWNoIHNlcGFyYXRlIHZhbHVlXG4gICAgICAgIGlmICghc2VsZi5zZXR0aW5ncy5zcGxpdE9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2FpdCBmb3IgcGFzdGVkIHRleHQgdG8gYmUgcmVjb2duaXplZCBpbiB2YWx1ZVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHZhciBwYXN0ZWRUZXh0ID0gc2VsZi5pbnB1dFZhbHVlKCk7XG4gICAgICAgICAgICBpZiAoIXBhc3RlZFRleHQubWF0Y2goc2VsZi5zZXR0aW5ncy5zcGxpdE9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzcGxpdElucHV0ID0gcGFzdGVkVGV4dC50cmltKCkuc3BsaXQoc2VsZi5zZXR0aW5ncy5zcGxpdE9uKTtcbiAgICAgICAgICAgIGl0ZXJhdGUoc3BsaXRJbnB1dCwgKHBpZWNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzaCA9IGhhc2hfa2V5KHBpZWNlKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zW3BpZWNlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGRJdGVtKHBpZWNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY3JlYXRlSXRlbShwaWVjZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBvbiA8aW5wdXQ+IGtleXByZXNzLlxuICAgICAqXG4gICAgICovXG4gICAgb25LZXlQcmVzcyhlKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKHNlbGYuaXNMb2NrZWQpIHtcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFyYWN0ZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGUua2V5Q29kZSB8fCBlLndoaWNoKTtcbiAgICAgICAgaWYgKHNlbGYuc2V0dGluZ3MuY3JlYXRlICYmIHNlbGYuc2V0dGluZ3MubW9kZSA9PT0gJ211bHRpJyAmJiBjaGFyYWN0ZXIgPT09IHNlbGYuc2V0dGluZ3MuZGVsaW1pdGVyKSB7XG4gICAgICAgICAgICBzZWxmLmNyZWF0ZUl0ZW0oKTtcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBvbiA8aW5wdXQ+IGtleWRvd24uXG4gICAgICpcbiAgICAgKi9cbiAgICBvbktleURvd24oZSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHNlbGYuaWdub3JlSG92ZXIgPSB0cnVlO1xuICAgICAgICBpZiAoc2VsZi5pc0xvY2tlZCkge1xuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSAhPT0gY29uc3RhbnRzLktFWV9UQUIpIHtcbiAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGUua2V5Q29kZSkge1xuICAgICAgICAgICAgLy8gY3RybCtBOiBzZWxlY3QgYWxsXG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50cy5LRVlfQTpcbiAgICAgICAgICAgICAgICBpZiAoaXNLZXlEb3duKGNvbnN0YW50cy5LRVlfU0hPUlRDVVQsIGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbnRyb2xfaW5wdXQudmFsdWUgPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RBbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIGVzYzogY2xvc2UgZHJvcGRvd25cbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzLktFWV9FU0M6XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYuY2xlYXJBY3RpdmVJdGVtcygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIGRvd246IG9wZW4gZHJvcGRvd24gb3IgbW92ZSBzZWxlY3Rpb24gZG93blxuICAgICAgICAgICAgY2FzZSBjb25zdGFudHMuS0VZX0RPV046XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxmLmlzT3BlbiAmJiBzZWxmLmhhc09wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5vcGVuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYuYWN0aXZlT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gc2VsZi5nZXRBZGphY2VudChzZWxmLmFjdGl2ZU9wdGlvbiwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXRBY3RpdmVPcHRpb24obmV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIHVwOiBtb3ZlIHNlbGVjdGlvbiB1cFxuICAgICAgICAgICAgY2FzZSBjb25zdGFudHMuS0VZX1VQOlxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmFjdGl2ZU9wdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJldiA9IHNlbGYuZ2V0QWRqYWNlbnQoc2VsZi5hY3RpdmVPcHRpb24sIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXYpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNldEFjdGl2ZU9wdGlvbihwcmV2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gcmV0dXJuOiBzZWxlY3QgYWN0aXZlIG9wdGlvblxuICAgICAgICAgICAgY2FzZSBjb25zdGFudHMuS0VZX1JFVFVSTjpcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jYW5TZWxlY3Qoc2VsZi5hY3RpdmVPcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYub25PcHRpb25TZWxlY3QoZSwgc2VsZi5hY3RpdmVPcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIG9wdGlvbl9jcmVhdGU9bnVsbCwgdGhlIGRyb3Bkb3duIG1pZ2h0IGJlIGNsb3NlZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWxmLnNldHRpbmdzLmNyZWF0ZSAmJiBzZWxmLmNyZWF0ZUl0ZW0oKSkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3Qgc3VibWl0IGZvcm0gd2hlbiBzZWFyY2hpbmcgZm9yIGEgdmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PSBzZWxmLmNvbnRyb2xfaW5wdXQgJiYgc2VsZi5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIGxlZnQ6IG1vZGlmaXkgaXRlbSBzZWxlY3Rpb24gdG8gdGhlIGxlZnRcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzLktFWV9MRUZUOlxuICAgICAgICAgICAgICAgIHNlbGYuYWR2YW5jZVNlbGVjdGlvbigtMSwgZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gcmlnaHQ6IG1vZGlmaXkgaXRlbSBzZWxlY3Rpb24gdG8gdGhlIHJpZ2h0XG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50cy5LRVlfUklHSFQ6XG4gICAgICAgICAgICAgICAgc2VsZi5hZHZhbmNlU2VsZWN0aW9uKDEsIGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIHRhYjogc2VsZWN0IGFjdGl2ZSBvcHRpb24gYW5kL29yIGNyZWF0ZSBpdGVtXG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50cy5LRVlfVEFCOlxuICAgICAgICAgICAgICAgIGlmIChzZWxmLnNldHRpbmdzLnNlbGVjdE9uVGFiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmNhblNlbGVjdChzZWxmLmFjdGl2ZU9wdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYub25PcHRpb25TZWxlY3QoZSwgc2VsZi5hY3RpdmVPcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJldmVudCBkZWZhdWx0IFt0YWJdIGJlaGF2aW91ciBvZiBqdW1wIHRvIHRoZSBuZXh0IGZpZWxkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBzZWxlY3QgaXNGdWxsLCB0aGVuIHRoZSBkcm9wZG93biB3b24ndCBiZSBvcGVuIGFuZCBbdGFiXSB3aWxsIHdvcmsgbm9ybWFsbHlcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLnNldHRpbmdzLmNyZWF0ZSAmJiBzZWxmLmNyZWF0ZUl0ZW0oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gZGVsZXRlfGJhY2tzcGFjZTogZGVsZXRlIGl0ZW1zXG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50cy5LRVlfQkFDS1NQQUNFOlxuICAgICAgICAgICAgY2FzZSBjb25zdGFudHMuS0VZX0RFTEVURTpcbiAgICAgICAgICAgICAgICBzZWxmLmRlbGV0ZVNlbGVjdGlvbihlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9uJ3QgZW50ZXIgdGV4dCBpbiB0aGUgY29udHJvbF9pbnB1dCB3aGVuIGFjdGl2ZSBpdGVtcyBhcmUgc2VsZWN0ZWRcbiAgICAgICAgaWYgKHNlbGYuaXNJbnB1dEhpZGRlbiAmJiAhaXNLZXlEb3duKGNvbnN0YW50cy5LRVlfU0hPUlRDVVQsIGUpKSB7XG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgb24gPGlucHV0PiBrZXl1cC5cbiAgICAgKlxuICAgICAqL1xuICAgIG9uSW5wdXQoZSkge1xuICAgICAgICBpZiAodGhpcy5pc0xvY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnB1dFZhbHVlKCk7XG4gICAgICAgIGlmICh0aGlzLmxhc3RWYWx1ZSA9PT0gdmFsdWUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMubGFzdFZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSA9PSAnJykge1xuICAgICAgICAgICAgdGhpcy5fb25JbnB1dCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlZnJlc2hUaW1lb3V0KSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmVmcmVzaFRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVmcmVzaFRpbWVvdXQgPSB0aW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaFRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fb25JbnB1dCgpO1xuICAgICAgICB9LCB0aGlzLnNldHRpbmdzLnJlZnJlc2hUaHJvdHRsZSk7XG4gICAgfVxuICAgIF9vbklucHV0KCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMubGFzdFZhbHVlO1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5zaG91bGRMb2FkLmNhbGwodGhpcywgdmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVmcmVzaE9wdGlvbnMoKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCd0eXBlJywgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiB0aGUgdXNlciByb2xscyBvdmVyXG4gICAgICogYW4gb3B0aW9uIGluIHRoZSBhdXRvY29tcGxldGUgZHJvcGRvd24gbWVudS5cbiAgICAgKlxuICAgICAqL1xuICAgIG9uT3B0aW9uSG92ZXIoZXZ0LCBvcHRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuaWdub3JlSG92ZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuc2V0QWN0aXZlT3B0aW9uKG9wdGlvbiwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgb24gPGlucHV0PiBmb2N1cy5cbiAgICAgKlxuICAgICAqL1xuICAgIG9uRm9jdXMoZSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciB3YXNGb2N1c2VkID0gc2VsZi5pc0ZvY3VzZWQ7XG4gICAgICAgIGlmIChzZWxmLmlzRGlzYWJsZWQgfHwgc2VsZi5pc1JlYWRPbmx5KSB7XG4gICAgICAgICAgICBzZWxmLmJsdXIoKTtcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLmlnbm9yZUZvY3VzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzZWxmLmlzRm9jdXNlZCA9IHRydWU7XG4gICAgICAgIGlmIChzZWxmLnNldHRpbmdzLnByZWxvYWQgPT09ICdmb2N1cycpXG4gICAgICAgICAgICBzZWxmLnByZWxvYWQoKTtcbiAgICAgICAgaWYgKCF3YXNGb2N1c2VkKVxuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdmb2N1cycpO1xuICAgICAgICBpZiAoIXNlbGYuYWN0aXZlSXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZWxmLmlucHV0U3RhdGUoKTtcbiAgICAgICAgICAgIHNlbGYucmVmcmVzaE9wdGlvbnMoISFzZWxmLnNldHRpbmdzLm9wZW5PbkZvY3VzKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLnJlZnJlc2hTdGF0ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgb24gPGlucHV0PiBibHVyLlxuICAgICAqXG4gICAgICovXG4gICAgb25CbHVyKGUpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50Lmhhc0ZvY3VzKCkgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICghc2VsZi5pc0ZvY3VzZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHNlbGYuaXNGb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIHNlbGYuaWdub3JlRm9jdXMgPSBmYWxzZTtcbiAgICAgICAgdmFyIGRlYWN0aXZhdGUgPSAoKSA9PiB7XG4gICAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgICBzZWxmLnNldEFjdGl2ZUl0ZW0oKTtcbiAgICAgICAgICAgIHNlbGYuc2V0Q2FyZXQoc2VsZi5pdGVtcy5sZW5ndGgpO1xuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdibHVyJyk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzZWxmLnNldHRpbmdzLmNyZWF0ZSAmJiBzZWxmLnNldHRpbmdzLmNyZWF0ZU9uQmx1cikge1xuICAgICAgICAgICAgc2VsZi5jcmVhdGVJdGVtKG51bGwsIGRlYWN0aXZhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVhY3RpdmF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiBhbiBvcHRpb25cbiAgICAgKiBpbiB0aGUgYXV0b2NvbXBsZXRlIGRyb3Bkb3duIG1lbnUuXG4gICAgICpcbiAgICAgKi9cbiAgICBvbk9wdGlvblNlbGVjdChldnQsIG9wdGlvbikge1xuICAgICAgICB2YXIgdmFsdWUsIHNlbGYgPSB0aGlzO1xuICAgICAgICAvLyBzaG91bGQgbm90IGJlIHBvc3NpYmxlIHRvIHRyaWdnZXIgYSBvcHRpb24gdW5kZXIgYSBkaXNhYmxlZCBvcHRncm91cFxuICAgICAgICBpZiAob3B0aW9uLnBhcmVudEVsZW1lbnQgJiYgb3B0aW9uLnBhcmVudEVsZW1lbnQubWF0Y2hlcygnW2RhdGEtZGlzYWJsZWRdJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9uLmNsYXNzTGlzdC5jb250YWlucygnY3JlYXRlJykpIHtcbiAgICAgICAgICAgIHNlbGYuY3JlYXRlSXRlbShudWxsLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuc2V0dGluZ3MuY2xvc2VBZnRlclNlbGVjdCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG9wdGlvbi5kYXRhc2V0LnZhbHVlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmxhc3RRdWVyeSA9IG51bGw7XG4gICAgICAgICAgICAgICAgc2VsZi5hZGRJdGVtKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5zZXR0aW5ncy5jbG9zZUFmdGVyU2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxmLnNldHRpbmdzLmhpZGVTZWxlY3RlZCAmJiBldnQudHlwZSAmJiAvY2xpY2svLnRlc3QoZXZ0LnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0QWN0aXZlT3B0aW9uKG9wdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSBnaXZlbiBvcHRpb24gY2FuIGJlIHNlbGVjdGVkXG4gICAgICpcbiAgICAgKi9cbiAgICBjYW5TZWxlY3Qob3B0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLmlzT3BlbiAmJiBvcHRpb24gJiYgdGhpcy5kcm9wZG93bl9jb250ZW50LmNvbnRhaW5zKG9wdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIGFuIGl0ZW1cbiAgICAgKiB0aGF0IGhhcyBiZWVuIHNlbGVjdGVkLlxuICAgICAqXG4gICAgICovXG4gICAgb25JdGVtU2VsZWN0KGV2dCwgaXRlbSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICghc2VsZi5pc0xvY2tlZCAmJiBzZWxmLnNldHRpbmdzLm1vZGUgPT09ICdtdWx0aScpIHtcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGV2dCk7XG4gICAgICAgICAgICBzZWxmLnNldEFjdGl2ZUl0ZW0oaXRlbSwgZXZ0KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0byBpbnZva2VcbiAgICAgKiB0aGUgdXNlci1wcm92aWRlZCBvcHRpb24gcHJvdmlkZXIgLyBsb2FkZXJcbiAgICAgKlxuICAgICAqIE5vdGUsIHRoZXJlIGlzIGEgc3VidGxlIGRpZmZlcmVuY2UgYmV0d2VlblxuICAgICAqIHRoaXMuY2FuTG9hZCgpIGFuZCB0aGlzLnNldHRpbmdzLnNob3VsZExvYWQoKTtcbiAgICAgKlxuICAgICAqXHQtIHNldHRpbmdzLnNob3VsZExvYWQoKSBpcyBhIHVzZXItaW5wdXQgdmFsaWRhdG9yLlxuICAgICAqXHRXaGVuIGZhbHNlIGlzIHJldHVybmVkLCB0aGUgbm90X2xvYWRpbmcgdGVtcGxhdGVcbiAgICAgKlx0d2lsbCBiZSBhZGRlZCB0byB0aGUgZHJvcGRvd25cbiAgICAgKlxuICAgICAqXHQtIGNhbkxvYWQoKSBpcyBsb3dlciBsZXZlbCB2YWxpZGF0b3IgdGhhdCBjaGVja3NcbiAgICAgKiBcdHRoZSBUb20gU2VsZWN0IGluc3RhbmNlLiBUaGVyZSBpcyBubyBpbmhlcmVudCB1c2VyXG4gICAgICpcdGZlZWRiYWNrIHdoZW4gY2FuTG9hZCByZXR1cm5zIGZhbHNlXG4gICAgICpcbiAgICAgKi9cbiAgICBjYW5Mb2FkKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5sb2FkKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5sb2FkZWRTZWFyY2hlcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSB1c2VyLXByb3ZpZGVkIG9wdGlvbiBwcm92aWRlciAvIGxvYWRlci5cbiAgICAgKlxuICAgICAqL1xuICAgIGxvYWQodmFsdWUpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICghc2VsZi5jYW5Mb2FkKHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgYWRkQ2xhc3NlcyhzZWxmLndyYXBwZXIsIHNlbGYuc2V0dGluZ3MubG9hZGluZ0NsYXNzKTtcbiAgICAgICAgc2VsZi5sb2FkaW5nKys7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gc2VsZi5sb2FkQ2FsbGJhY2suYmluZChzZWxmKTtcbiAgICAgICAgc2VsZi5zZXR0aW5ncy5sb2FkLmNhbGwoc2VsZiwgdmFsdWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52b2tlZCBieSB0aGUgdXNlci1wcm92aWRlZCBvcHRpb24gcHJvdmlkZXJcbiAgICAgKlxuICAgICAqL1xuICAgIGxvYWRDYWxsYmFjayhvcHRpb25zLCBvcHRncm91cHMpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIHNlbGYubG9hZGluZyA9IE1hdGgubWF4KHNlbGYubG9hZGluZyAtIDEsIDApO1xuICAgICAgICBzZWxmLmxhc3RRdWVyeSA9IG51bGw7XG4gICAgICAgIHNlbGYuY2xlYXJBY3RpdmVPcHRpb24oKTsgLy8gd2hlbiBuZXcgcmVzdWx0cyBsb2FkLCBmb2N1cyBzaG91bGQgYmUgb24gZmlyc3Qgb3B0aW9uXG4gICAgICAgIHNlbGYuc2V0dXBPcHRpb25zKG9wdGlvbnMsIG9wdGdyb3Vwcyk7XG4gICAgICAgIHNlbGYucmVmcmVzaE9wdGlvbnMoc2VsZi5pc0ZvY3VzZWQgJiYgIXNlbGYuaXNJbnB1dEhpZGRlbik7XG4gICAgICAgIGlmICghc2VsZi5sb2FkaW5nKSB7XG4gICAgICAgICAgICByZW1vdmVDbGFzc2VzKHNlbGYud3JhcHBlciwgc2VsZi5zZXR0aW5ncy5sb2FkaW5nQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYudHJpZ2dlcignbG9hZCcsIG9wdGlvbnMsIG9wdGdyb3Vwcyk7XG4gICAgfVxuICAgIHByZWxvYWQoKSB7XG4gICAgICAgIHZhciBjbGFzc0xpc3QgPSB0aGlzLndyYXBwZXIuY2xhc3NMaXN0O1xuICAgICAgICBpZiAoY2xhc3NMaXN0LmNvbnRhaW5zKCdwcmVsb2FkZWQnKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgncHJlbG9hZGVkJyk7XG4gICAgICAgIHRoaXMubG9hZCgnJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGlucHV0IGZpZWxkIG9mIHRoZSBjb250cm9sIHRvIHRoZSBzcGVjaWZpZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKi9cbiAgICBzZXRUZXh0Ym94VmFsdWUodmFsdWUgPSAnJykge1xuICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmNvbnRyb2xfaW5wdXQ7XG4gICAgICAgIHZhciBjaGFuZ2VkID0gaW5wdXQudmFsdWUgIT09IHZhbHVlO1xuICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgaW5wdXQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudChpbnB1dCwgJ3VwZGF0ZScpO1xuICAgICAgICAgICAgdGhpcy5sYXN0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgY29udHJvbC4gSWYgbXVsdGlwbGUgaXRlbXNcbiAgICAgKiBjYW4gYmUgc2VsZWN0ZWQgKGUuZy4gPHNlbGVjdCBtdWx0aXBsZT4pLCB0aGlzIHJldHVybnNcbiAgICAgKiBhbiBhcnJheS4gSWYgb25seSBvbmUgaXRlbSBjYW4gYmUgc2VsZWN0ZWQsIHRoaXNcbiAgICAgKiByZXR1cm5zIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICovXG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzX3NlbGVjdF90YWcgJiYgdGhpcy5pbnB1dC5oYXNBdHRyaWJ1dGUoJ211bHRpcGxlJykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmpvaW4odGhpcy5zZXR0aW5ncy5kZWxpbWl0ZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIHNlbGVjdGVkIGl0ZW1zIHRvIHRoZSBnaXZlbiB2YWx1ZS5cbiAgICAgKlxuICAgICAqL1xuICAgIHNldFZhbHVlKHZhbHVlLCBzaWxlbnQpIHtcbiAgICAgICAgdmFyIGV2ZW50cyA9IHNpbGVudCA/IFtdIDogWydjaGFuZ2UnXTtcbiAgICAgICAgZGVib3VuY2VfZXZlbnRzKHRoaXMsIGV2ZW50cywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jbGVhcihzaWxlbnQpO1xuICAgICAgICAgICAgdGhpcy5hZGRJdGVtcyh2YWx1ZSwgc2lsZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgbnVtYmVyIG9mIG1heCBpdGVtcyB0byB0aGUgZ2l2ZW4gdmFsdWVcbiAgICAgKlxuICAgICAqL1xuICAgIHNldE1heEl0ZW1zKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMClcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbDsgLy9yZXNldCB0byB1bmxpbWl0ZWQgaXRlbXMuXG4gICAgICAgIHRoaXMuc2V0dGluZ3MubWF4SXRlbXMgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5yZWZyZXNoU3RhdGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2VsZWN0ZWQgaXRlbS5cbiAgICAgKlxuICAgICAqL1xuICAgIHNldEFjdGl2ZUl0ZW0oaXRlbSwgZSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBldmVudE5hbWU7XG4gICAgICAgIHZhciBpLCBiZWdpbiwgZW5kLCBzd2FwO1xuICAgICAgICB2YXIgbGFzdDtcbiAgICAgICAgaWYgKHNlbGYuc2V0dGluZ3MubW9kZSA9PT0gJ3NpbmdsZScpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIGNsZWFyIHRoZSBhY3RpdmUgc2VsZWN0aW9uXG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgc2VsZi5jbGVhckFjdGl2ZUl0ZW1zKCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5pc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmlucHV0U3RhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBtb2RpZnkgc2VsZWN0aW9uXG4gICAgICAgIGV2ZW50TmFtZSA9IGUgJiYgZS50eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChldmVudE5hbWUgPT09ICdjbGljaycgJiYgaXNLZXlEb3duKCdzaGlmdEtleScsIGUpICYmIHNlbGYuYWN0aXZlSXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsYXN0ID0gc2VsZi5nZXRMYXN0QWN0aXZlKCk7XG4gICAgICAgICAgICBiZWdpbiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoc2VsZi5jb250cm9sLmNoaWxkcmVuLCBsYXN0KTtcbiAgICAgICAgICAgIGVuZCA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoc2VsZi5jb250cm9sLmNoaWxkcmVuLCBpdGVtKTtcbiAgICAgICAgICAgIGlmIChiZWdpbiA+IGVuZCkge1xuICAgICAgICAgICAgICAgIHN3YXAgPSBiZWdpbjtcbiAgICAgICAgICAgICAgICBiZWdpbiA9IGVuZDtcbiAgICAgICAgICAgICAgICBlbmQgPSBzd2FwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gYmVnaW47IGkgPD0gZW5kOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gc2VsZi5jb250cm9sLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmFjdGl2ZUl0ZW1zLmluZGV4T2YoaXRlbSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0QWN0aXZlSXRlbUNsYXNzKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChldmVudE5hbWUgPT09ICdjbGljaycgJiYgaXNLZXlEb3duKGNvbnN0YW50cy5LRVlfU0hPUlRDVVQsIGUpKSB8fCAoZXZlbnROYW1lID09PSAna2V5ZG93bicgJiYgaXNLZXlEb3duKCdzaGlmdEtleScsIGUpKSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0uY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSkge1xuICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlQWN0aXZlSXRlbShpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0QWN0aXZlSXRlbUNsYXNzKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5jbGVhckFjdGl2ZUl0ZW1zKCk7XG4gICAgICAgICAgICBzZWxmLnNldEFjdGl2ZUl0ZW1DbGFzcyhpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbnN1cmUgY29udHJvbCBoYXMgZm9jdXNcbiAgICAgICAgc2VsZi5pbnB1dFN0YXRlKCk7XG4gICAgICAgIGlmICghc2VsZi5pc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgIHNlbGYuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGFjdGl2ZSBhbmQgbGFzdC1hY3RpdmUgY2xhc3Nlc1xuICAgICAqXG4gICAgICovXG4gICAgc2V0QWN0aXZlSXRlbUNsYXNzKGl0ZW0pIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGxhc3RfYWN0aXZlID0gc2VsZi5jb250cm9sLnF1ZXJ5U2VsZWN0b3IoJy5sYXN0LWFjdGl2ZScpO1xuICAgICAgICBpZiAobGFzdF9hY3RpdmUpXG4gICAgICAgICAgICByZW1vdmVDbGFzc2VzKGxhc3RfYWN0aXZlLCAnbGFzdC1hY3RpdmUnKTtcbiAgICAgICAgYWRkQ2xhc3NlcyhpdGVtLCAnYWN0aXZlIGxhc3QtYWN0aXZlJyk7XG4gICAgICAgIHNlbGYudHJpZ2dlcignaXRlbV9zZWxlY3QnLCBpdGVtKTtcbiAgICAgICAgaWYgKHNlbGYuYWN0aXZlSXRlbXMuaW5kZXhPZihpdGVtKSA9PSAtMSkge1xuICAgICAgICAgICAgc2VsZi5hY3RpdmVJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhY3RpdmUgaXRlbVxuICAgICAqXG4gICAgICovXG4gICAgcmVtb3ZlQWN0aXZlSXRlbShpdGVtKSB7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLmFjdGl2ZUl0ZW1zLmluZGV4T2YoaXRlbSk7XG4gICAgICAgIHRoaXMuYWN0aXZlSXRlbXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIHJlbW92ZUNsYXNzZXMoaXRlbSwgJ2FjdGl2ZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIHRoZSBhY3RpdmUgaXRlbXNcbiAgICAgKlxuICAgICAqL1xuICAgIGNsZWFyQWN0aXZlSXRlbXMoKSB7XG4gICAgICAgIHJlbW92ZUNsYXNzZXModGhpcy5hY3RpdmVJdGVtcywgJ2FjdGl2ZScpO1xuICAgICAgICB0aGlzLmFjdGl2ZUl0ZW1zID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNlbGVjdGVkIGl0ZW0gaW4gdGhlIGRyb3Bkb3duIG1lbnVcbiAgICAgKiBvZiBhdmFpbGFibGUgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqL1xuICAgIHNldEFjdGl2ZU9wdGlvbihvcHRpb24sIHNjcm9sbCA9IHRydWUpIHtcbiAgICAgICAgaWYgKG9wdGlvbiA9PT0gdGhpcy5hY3RpdmVPcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyQWN0aXZlT3B0aW9uKCk7XG4gICAgICAgIGlmICghb3B0aW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmFjdGl2ZU9wdGlvbiA9IG9wdGlvbjtcbiAgICAgICAgc2V0QXR0cih0aGlzLmZvY3VzX25vZGUsIHsgJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6IG9wdGlvbi5nZXRBdHRyaWJ1dGUoJ2lkJykgfSk7XG4gICAgICAgIHNldEF0dHIob3B0aW9uLCB7ICdhcmlhLXNlbGVjdGVkJzogJ3RydWUnIH0pO1xuICAgICAgICBhZGRDbGFzc2VzKG9wdGlvbiwgJ2FjdGl2ZScpO1xuICAgICAgICBpZiAoc2Nyb2xsKVxuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb09wdGlvbihvcHRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkcm9wZG93bl9jb250ZW50IHNjcm9sbFRvcCB0byBkaXNwbGF5IHRoZSBvcHRpb25cbiAgICAgKlxuICAgICAqL1xuICAgIHNjcm9sbFRvT3B0aW9uKG9wdGlvbiwgYmVoYXZpb3IpIHtcbiAgICAgICAgaWYgKCFvcHRpb24pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLmRyb3Bkb3duX2NvbnRlbnQ7XG4gICAgICAgIGNvbnN0IGhlaWdodF9tZW51ID0gY29udGVudC5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGNvbnN0IHNjcm9sbFRvcCA9IGNvbnRlbnQuc2Nyb2xsVG9wIHx8IDA7XG4gICAgICAgIGNvbnN0IGhlaWdodF9pdGVtID0gb3B0aW9uLm9mZnNldEhlaWdodDtcbiAgICAgICAgY29uc3QgeSA9IG9wdGlvbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgLSBjb250ZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIHNjcm9sbFRvcDtcbiAgICAgICAgaWYgKHkgKyBoZWlnaHRfaXRlbSA+IGhlaWdodF9tZW51ICsgc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbCh5IC0gaGVpZ2h0X21lbnUgKyBoZWlnaHRfaXRlbSwgYmVoYXZpb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHkgPCBzY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsKHksIGJlaGF2aW9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY3JvbGwgdGhlIGRyb3Bkb3duIHRvIHRoZSBnaXZlbiBwb3NpdGlvblxuICAgICAqXG4gICAgICovXG4gICAgc2Nyb2xsKHNjcm9sbFRvcCwgYmVoYXZpb3IpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuZHJvcGRvd25fY29udGVudDtcbiAgICAgICAgaWYgKGJlaGF2aW9yKSB7XG4gICAgICAgICAgICBjb250ZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gYmVoYXZpb3I7XG4gICAgICAgIH1cbiAgICAgICAgY29udGVudC5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgIGNvbnRlbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3IgPSAnJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBhY3RpdmUgb3B0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBjbGVhckFjdGl2ZU9wdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlT3B0aW9uKSB7XG4gICAgICAgICAgICByZW1vdmVDbGFzc2VzKHRoaXMuYWN0aXZlT3B0aW9uLCAnYWN0aXZlJyk7XG4gICAgICAgICAgICBzZXRBdHRyKHRoaXMuYWN0aXZlT3B0aW9uLCB7ICdhcmlhLXNlbGVjdGVkJzogbnVsbCB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZU9wdGlvbiA9IG51bGw7XG4gICAgICAgIHNldEF0dHIodGhpcy5mb2N1c19ub2RlLCB7ICdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnOiBudWxsIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIGFsbCBpdGVtcyAoQ1RSTCArIEEpLlxuICAgICAqL1xuICAgIHNlbGVjdEFsbCgpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChzZWxmLnNldHRpbmdzLm1vZGUgPT09ICdzaW5nbGUnKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBhY3RpdmVJdGVtcyA9IHNlbGYuY29udHJvbENoaWxkcmVuKCk7XG4gICAgICAgIGlmICghYWN0aXZlSXRlbXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzZWxmLmlucHV0U3RhdGUoKTtcbiAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgICBzZWxmLmFjdGl2ZUl0ZW1zID0gYWN0aXZlSXRlbXM7XG4gICAgICAgIGl0ZXJhdGUoYWN0aXZlSXRlbXMsIChpdGVtKSA9PiB7XG4gICAgICAgICAgICBzZWxmLnNldEFjdGl2ZUl0ZW1DbGFzcyhpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdGhlIGNvbnRyb2xfaW5wdXQgc2hvdWxkIGJlIGluIGEgaGlkZGVuIG9yIHZpc2libGUgc3RhdGVcbiAgICAgKlxuICAgICAqL1xuICAgIGlucHV0U3RhdGUoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCFzZWxmLmNvbnRyb2wuY29udGFpbnMoc2VsZi5jb250cm9sX2lucHV0KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc2V0QXR0cihzZWxmLmNvbnRyb2xfaW5wdXQsIHsgcGxhY2Vob2xkZXI6IHNlbGYuc2V0dGluZ3MucGxhY2Vob2xkZXIgfSk7XG4gICAgICAgIGlmIChzZWxmLmFjdGl2ZUl0ZW1zLmxlbmd0aCA+IDAgfHwgKCFzZWxmLmlzRm9jdXNlZCAmJiBzZWxmLnNldHRpbmdzLmhpZGVQbGFjZWhvbGRlciAmJiBzZWxmLml0ZW1zLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICBzZWxmLnNldFRleHRib3hWYWx1ZSgpO1xuICAgICAgICAgICAgc2VsZi5pc0lucHV0SGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzZWxmLnNldHRpbmdzLmhpZGVQbGFjZWhvbGRlciAmJiBzZWxmLml0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBzZXRBdHRyKHNlbGYuY29udHJvbF9pbnB1dCwgeyBwbGFjZWhvbGRlcjogJycgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmlzSW5wdXRIaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLndyYXBwZXIuY2xhc3NMaXN0LnRvZ2dsZSgnaW5wdXQtaGlkZGVuJywgc2VsZi5pc0lucHV0SGlkZGVuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpbnB1dCB2YWx1ZVxuICAgICAqL1xuICAgIGlucHV0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xfaW5wdXQudmFsdWUudHJpbSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlcyB0aGUgY29udHJvbCBmb2N1cy5cbiAgICAgKi9cbiAgICBmb2N1cygpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoc2VsZi5pc0Rpc2FibGVkIHx8IHNlbGYuaXNSZWFkT25seSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc2VsZi5pZ25vcmVGb2N1cyA9IHRydWU7XG4gICAgICAgIGlmIChzZWxmLmNvbnRyb2xfaW5wdXQub2Zmc2V0V2lkdGgpIHtcbiAgICAgICAgICAgIHNlbGYuY29udHJvbF9pbnB1dC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5mb2N1c19ub2RlLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBzZWxmLmlnbm9yZUZvY3VzID0gZmFsc2U7XG4gICAgICAgICAgICBzZWxmLm9uRm9jdXMoKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvcmNlcyB0aGUgY29udHJvbCBvdXQgb2YgZm9jdXMuXG4gICAgICpcbiAgICAgKi9cbiAgICBibHVyKCkge1xuICAgICAgICB0aGlzLmZvY3VzX25vZGUuYmx1cigpO1xuICAgICAgICB0aGlzLm9uQmx1cigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBzY29yZXMgYW4gb2JqZWN0XG4gICAgICogdG8gc2hvdyBob3cgZ29vZCBvZiBhIG1hdGNoIGl0IGlzIHRvIHRoZVxuICAgICAqIHByb3ZpZGVkIHF1ZXJ5LlxuICAgICAqXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgZ2V0U2NvcmVGdW5jdGlvbihxdWVyeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWZ0ZXIuZ2V0U2NvcmVGdW5jdGlvbihxdWVyeSwgdGhpcy5nZXRTZWFyY2hPcHRpb25zKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHNlYXJjaCBvcHRpb25zIGZvciBzaWZ0ZXIgKHRoZSBzeXN0ZW1cbiAgICAgKiBmb3Igc2NvcmluZyBhbmQgc29ydGluZyByZXN1bHRzKS5cbiAgICAgKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL29yY2hpZGpzL3NpZnRlci5qc1xuICAgICAqIEByZXR1cm4ge29iamVjdH1cbiAgICAgKi9cbiAgICBnZXRTZWFyY2hPcHRpb25zKCkge1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzO1xuICAgICAgICB2YXIgc29ydCA9IHNldHRpbmdzLnNvcnRGaWVsZDtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5zb3J0RmllbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzb3J0ID0gW3sgZmllbGQ6IHNldHRpbmdzLnNvcnRGaWVsZCB9XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmllbGRzOiBzZXR0aW5ncy5zZWFyY2hGaWVsZCxcbiAgICAgICAgICAgIGNvbmp1bmN0aW9uOiBzZXR0aW5ncy5zZWFyY2hDb25qdW5jdGlvbixcbiAgICAgICAgICAgIHNvcnQ6IHNvcnQsXG4gICAgICAgICAgICBuZXN0aW5nOiBzZXR0aW5ncy5uZXN0aW5nXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlYXJjaGVzIHRocm91Z2ggYXZhaWxhYmxlIG9wdGlvbnMgYW5kIHJldHVybnNcbiAgICAgKiBhIHNvcnRlZCBhcnJheSBvZiBtYXRjaGVzLlxuICAgICAqXG4gICAgICovXG4gICAgc2VhcmNoKHF1ZXJ5KSB7XG4gICAgICAgIHZhciByZXN1bHQsIGNhbGN1bGF0ZVNjb3JlO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5nZXRTZWFyY2hPcHRpb25zKCk7XG4gICAgICAgIC8vIHZhbGlkYXRlIHVzZXItcHJvdmlkZWQgcmVzdWx0IHNjb3JpbmcgZnVuY3Rpb25cbiAgICAgICAgaWYgKHNlbGYuc2V0dGluZ3Muc2NvcmUpIHtcbiAgICAgICAgICAgIGNhbGN1bGF0ZVNjb3JlID0gc2VsZi5zZXR0aW5ncy5zY29yZS5jYWxsKHNlbGYsIHF1ZXJ5KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsY3VsYXRlU2NvcmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbSBTZWxlY3QgXCJzY29yZVwiIHNldHRpbmcgbXVzdCBiZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGVyZm9ybSBzZWFyY2hcbiAgICAgICAgaWYgKHF1ZXJ5ICE9PSBzZWxmLmxhc3RRdWVyeSkge1xuICAgICAgICAgICAgc2VsZi5sYXN0UXVlcnkgPSBxdWVyeTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHNlbGYuc2lmdGVyLnNlYXJjaChxdWVyeSwgT2JqZWN0LmFzc2lnbihvcHRpb25zLCB7IHNjb3JlOiBjYWxjdWxhdGVTY29yZSB9KSk7XG4gICAgICAgICAgICBzZWxmLmN1cnJlbnRSZXN1bHRzID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgc2VsZi5jdXJyZW50UmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmlsdGVyIG91dCBzZWxlY3RlZCBpdGVtc1xuICAgICAgICBpZiAoc2VsZi5zZXR0aW5ncy5oaWRlU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5pdGVtcyA9IHJlc3VsdC5pdGVtcy5maWx0ZXIoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgaGFzaGVkID0gaGFzaF9rZXkoaXRlbS5pZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEoaGFzaGVkICYmIHNlbGYuaXRlbXMuaW5kZXhPZihoYXNoZWQpICE9PSAtMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWZyZXNoZXMgdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIG9wdGlvbnMgc2hvd25cbiAgICAgKiBpbiB0aGUgYXV0b2NvbXBsZXRlIGRyb3Bkb3duIG1lbnUuXG4gICAgICpcbiAgICAgKi9cbiAgICByZWZyZXNoT3B0aW9ucyh0cmlnZ2VyRHJvcGRvd24gPSB0cnVlKSB7XG4gICAgICAgIHZhciBpLCBqLCBrLCBuLCBvcHRncm91cCwgb3B0Z3JvdXBzLCBodG1sLCBoYXNfY3JlYXRlX29wdGlvbiwgYWN0aXZlX2dyb3VwO1xuICAgICAgICB2YXIgY3JlYXRlO1xuICAgICAgICBjb25zdCBncm91cHMgPSB7fTtcbiAgICAgICAgY29uc3QgZ3JvdXBzX29yZGVyID0gW107XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHF1ZXJ5ID0gc2VsZi5pbnB1dFZhbHVlKCk7XG4gICAgICAgIGNvbnN0IHNhbWVfcXVlcnkgPSBxdWVyeSA9PT0gc2VsZi5sYXN0UXVlcnkgfHwgKHF1ZXJ5ID09ICcnICYmIHNlbGYubGFzdFF1ZXJ5ID09IG51bGwpO1xuICAgICAgICB2YXIgcmVzdWx0cyA9IHNlbGYuc2VhcmNoKHF1ZXJ5KTtcbiAgICAgICAgdmFyIGFjdGl2ZV9vcHRpb24gPSBudWxsO1xuICAgICAgICB2YXIgc2hvd19kcm9wZG93biA9IHNlbGYuc2V0dGluZ3Muc2hvdWxkT3BlbiB8fCBmYWxzZTtcbiAgICAgICAgdmFyIGRyb3Bkb3duX2NvbnRlbnQgPSBzZWxmLmRyb3Bkb3duX2NvbnRlbnQ7XG4gICAgICAgIGlmIChzYW1lX3F1ZXJ5KSB7XG4gICAgICAgICAgICBhY3RpdmVfb3B0aW9uID0gc2VsZi5hY3RpdmVPcHRpb247XG4gICAgICAgICAgICBpZiAoYWN0aXZlX29wdGlvbikge1xuICAgICAgICAgICAgICAgIGFjdGl2ZV9ncm91cCA9IGFjdGl2ZV9vcHRpb24uY2xvc2VzdCgnW2RhdGEtZ3JvdXBdJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYnVpbGQgbWFya3VwXG4gICAgICAgIG4gPSByZXN1bHRzLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWxmLnNldHRpbmdzLm1heE9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBuID0gTWF0aC5taW4obiwgc2VsZi5zZXR0aW5ncy5tYXhPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobiA+IDApIHtcbiAgICAgICAgICAgIHNob3dfZHJvcGRvd24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCBmcmFnbWVudCBmb3IgZ3JvdXAgYW5kIHRoZSBwb3NpdGlvbiBvZiB0aGUgZ3JvdXAgaW4gZ3JvdXBfb3JkZXJcbiAgICAgICAgY29uc3QgZ2V0R3JvdXBGcmFnbWVudCA9IChvcHRncm91cCwgb3JkZXIpID0+IHtcbiAgICAgICAgICAgIGxldCBncm91cF9vcmRlcl9pID0gZ3JvdXBzW29wdGdyb3VwXTtcbiAgICAgICAgICAgIGlmIChncm91cF9vcmRlcl9pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgb3JkZXJfZ3JvdXAgPSBncm91cHNfb3JkZXJbZ3JvdXBfb3JkZXJfaV07XG4gICAgICAgICAgICAgICAgaWYgKG9yZGVyX2dyb3VwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtncm91cF9vcmRlcl9pLCBvcmRlcl9ncm91cC5mcmFnbWVudF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGdyb3VwX2ZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICAgICAgZ3JvdXBfb3JkZXJfaSA9IGdyb3Vwc19vcmRlci5sZW5ndGg7XG4gICAgICAgICAgICBncm91cHNfb3JkZXIucHVzaCh7IGZyYWdtZW50OiBncm91cF9mcmFnbWVudCwgb3JkZXIsIG9wdGdyb3VwIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFtncm91cF9vcmRlcl9pLCBncm91cF9mcmFnbWVudF07XG4gICAgICAgIH07XG4gICAgICAgIC8vIHJlbmRlciBhbmQgZ3JvdXAgYXZhaWxhYmxlIG9wdGlvbnMgaW5kaXZpZHVhbGx5XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGdldCBvcHRpb24gZG9tIGVsZW1lbnRcbiAgICAgICAgICAgIGxldCBpdGVtID0gcmVzdWx0cy5pdGVtc1tpXTtcbiAgICAgICAgICAgIGlmICghaXRlbSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBvcHRfdmFsdWUgPSBpdGVtLmlkO1xuICAgICAgICAgICAgbGV0IG9wdGlvbiA9IHNlbGYub3B0aW9uc1tvcHRfdmFsdWVdO1xuICAgICAgICAgICAgaWYgKG9wdGlvbiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IG9wdF9oYXNoID0gZ2V0X2hhc2gob3B0X3ZhbHVlKTtcbiAgICAgICAgICAgIGxldCBvcHRpb25fZWwgPSBzZWxmLmdldE9wdGlvbihvcHRfaGFzaCwgdHJ1ZSk7XG4gICAgICAgICAgICAvLyB0b2dnbGUgJ3NlbGVjdGVkJyBjbGFzc1xuICAgICAgICAgICAgaWYgKCFzZWxmLnNldHRpbmdzLmhpZGVTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbl9lbC5jbGFzc0xpc3QudG9nZ2xlKCdzZWxlY3RlZCcsIHNlbGYuaXRlbXMuaW5jbHVkZXMob3B0X2hhc2gpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGdyb3VwID0gb3B0aW9uW3NlbGYuc2V0dGluZ3Mub3B0Z3JvdXBGaWVsZF0gfHwgJyc7XG4gICAgICAgICAgICBvcHRncm91cHMgPSBBcnJheS5pc0FycmF5KG9wdGdyb3VwKSA/IG9wdGdyb3VwIDogW29wdGdyb3VwXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDAsIGsgPSBvcHRncm91cHMgJiYgb3B0Z3JvdXBzLmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgICAgIG9wdGdyb3VwID0gb3B0Z3JvdXBzW2pdO1xuICAgICAgICAgICAgICAgIGxldCBvcmRlciA9IG9wdGlvbi4kb3JkZXI7XG4gICAgICAgICAgICAgICAgbGV0IHNlbGZfb3B0Z3JvdXAgPSBzZWxmLm9wdGdyb3Vwc1tvcHRncm91cF07XG4gICAgICAgICAgICAgICAgaWYgKHNlbGZfb3B0Z3JvdXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRncm91cCA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXIgPSBzZWxmX29wdGdyb3VwLiRvcmRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgW2dyb3VwX29yZGVyX2ksIGdyb3VwX2ZyYWdtZW50XSA9IGdldEdyb3VwRnJhZ21lbnQob3B0Z3JvdXAsIG9yZGVyKTtcbiAgICAgICAgICAgICAgICAvLyBub2RlcyBjYW4gb25seSBoYXZlIG9uZSBwYXJlbnQsIHNvIGlmIHRoZSBvcHRpb24gaXMgaW4gbXV0cGxlIGdyb3Vwcywgd2UgbmVlZCBhIGNsb25lXG4gICAgICAgICAgICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbl9lbCA9IG9wdGlvbl9lbC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHNldEF0dHIob3B0aW9uX2VsLCB7IGlkOiBvcHRpb24uJGlkICsgJy1jbG9uZS0nICsgaiwgJ2FyaWEtc2VsZWN0ZWQnOiBudWxsIH0pO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25fZWwuY2xhc3NMaXN0LmFkZCgndHMtY2xvbmVkJyk7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzZXMob3B0aW9uX2VsLCAnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBrZWVwIHRoZSBhY3RpdmVPcHRpb24gaW4gdGhlIHNhbWUgZ3JvdXBcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYWN0aXZlT3B0aW9uICYmIHNlbGYuYWN0aXZlT3B0aW9uLmRhdGFzZXQudmFsdWUgPT0gb3B0X3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlX2dyb3VwICYmIGFjdGl2ZV9ncm91cC5kYXRhc2V0Lmdyb3VwID09PSBvcHRncm91cC50b1N0cmluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlX29wdGlvbiA9IG9wdGlvbl9lbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBncm91cF9mcmFnbWVudC5hcHBlbmRDaGlsZChvcHRpb25fZWwpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRncm91cCAhPSAnJykge1xuICAgICAgICAgICAgICAgICAgICBncm91cHNbb3B0Z3JvdXBdID0gZ3JvdXBfb3JkZXJfaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc29ydCBvcHRncm91cHNcbiAgICAgICAgaWYgKHNlbGYuc2V0dGluZ3MubG9ja09wdGdyb3VwT3JkZXIpIHtcbiAgICAgICAgICAgIGdyb3Vwc19vcmRlci5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEub3JkZXIgLSBiLm9yZGVyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVuZGVyIG9wdGdyb3VwIGhlYWRlcnMgJiBqb2luIGdyb3Vwc1xuICAgICAgICBodG1sID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICBpdGVyYXRlKGdyb3Vwc19vcmRlciwgKGdyb3VwX29yZGVyKSA9PiB7XG4gICAgICAgICAgICBsZXQgZ3JvdXBfZnJhZ21lbnQgPSBncm91cF9vcmRlci5mcmFnbWVudDtcbiAgICAgICAgICAgIGxldCBvcHRncm91cCA9IGdyb3VwX29yZGVyLm9wdGdyb3VwO1xuICAgICAgICAgICAgaWYgKCFncm91cF9mcmFnbWVudCB8fCAhZ3JvdXBfZnJhZ21lbnQuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCBncm91cF9oZWFkaW5nID0gc2VsZi5vcHRncm91cHNbb3B0Z3JvdXBdO1xuICAgICAgICAgICAgaWYgKGdyb3VwX2hlYWRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxldCBncm91cF9vcHRpb25zID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgIGxldCBoZWFkZXIgPSBzZWxmLnJlbmRlcignb3B0Z3JvdXBfaGVhZGVyJywgZ3JvdXBfaGVhZGluZyk7XG4gICAgICAgICAgICAgICAgYXBwZW5kKGdyb3VwX29wdGlvbnMsIGhlYWRlcik7XG4gICAgICAgICAgICAgICAgYXBwZW5kKGdyb3VwX29wdGlvbnMsIGdyb3VwX2ZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICBsZXQgZ3JvdXBfaHRtbCA9IHNlbGYucmVuZGVyKCdvcHRncm91cCcsIHsgZ3JvdXA6IGdyb3VwX2hlYWRpbmcsIG9wdGlvbnM6IGdyb3VwX29wdGlvbnMgfSk7XG4gICAgICAgICAgICAgICAgYXBwZW5kKGh0bWwsIGdyb3VwX2h0bWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXBwZW5kKGh0bWwsIGdyb3VwX2ZyYWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGRyb3Bkb3duX2NvbnRlbnQuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIGFwcGVuZChkcm9wZG93bl9jb250ZW50LCBodG1sKTtcbiAgICAgICAgLy8gaGlnaGxpZ2h0IG1hdGNoaW5nIHRlcm1zIGlubGluZVxuICAgICAgICBpZiAoc2VsZi5zZXR0aW5ncy5oaWdobGlnaHQpIHtcbiAgICAgICAgICAgIHJlbW92ZUhpZ2hsaWdodChkcm9wZG93bl9jb250ZW50KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRzLnF1ZXJ5Lmxlbmd0aCAmJiByZXN1bHRzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRlKHJlc3VsdHMudG9rZW5zLCAodG9rKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodChkcm9wZG93bl9jb250ZW50LCB0b2sucmVnZXgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGhlbHBlciBtZXRob2QgZm9yIGFkZGluZyB0ZW1wbGF0ZXMgdG8gZHJvcGRvd25cbiAgICAgICAgdmFyIGFkZF90ZW1wbGF0ZSA9ICh0ZW1wbGF0ZSkgPT4ge1xuICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBzZWxmLnJlbmRlcih0ZW1wbGF0ZSwgeyBpbnB1dDogcXVlcnkgfSk7XG4gICAgICAgICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAgICAgICAgIHNob3dfZHJvcGRvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGRyb3Bkb3duX2NvbnRlbnQuaW5zZXJ0QmVmb3JlKGNvbnRlbnQsIGRyb3Bkb3duX2NvbnRlbnQuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gYWRkIGxvYWRpbmcgbWVzc2FnZVxuICAgICAgICBpZiAoc2VsZi5sb2FkaW5nKSB7XG4gICAgICAgICAgICBhZGRfdGVtcGxhdGUoJ2xvYWRpbmcnKTtcbiAgICAgICAgICAgIC8vIGludmFsaWQgcXVlcnlcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghc2VsZi5zZXR0aW5ncy5zaG91bGRMb2FkLmNhbGwoc2VsZiwgcXVlcnkpKSB7XG4gICAgICAgICAgICBhZGRfdGVtcGxhdGUoJ25vdF9sb2FkaW5nJyk7XG4gICAgICAgICAgICAvLyBhZGQgbm9fcmVzdWx0cyBtZXNzYWdlXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzdWx0cy5pdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGFkZF90ZW1wbGF0ZSgnbm9fcmVzdWx0cycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCBjcmVhdGUgb3B0aW9uXG4gICAgICAgIGhhc19jcmVhdGVfb3B0aW9uID0gc2VsZi5jYW5DcmVhdGUocXVlcnkpO1xuICAgICAgICBpZiAoaGFzX2NyZWF0ZV9vcHRpb24pIHtcbiAgICAgICAgICAgIGNyZWF0ZSA9IGFkZF90ZW1wbGF0ZSgnb3B0aW9uX2NyZWF0ZScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFjdGl2YXRlXG4gICAgICAgIHNlbGYuaGFzT3B0aW9ucyA9IHJlc3VsdHMuaXRlbXMubGVuZ3RoID4gMCB8fCBoYXNfY3JlYXRlX29wdGlvbjtcbiAgICAgICAgaWYgKHNob3dfZHJvcGRvd24pIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHRzLml0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFjdGl2ZV9vcHRpb24gJiYgc2VsZi5zZXR0aW5ncy5tb2RlID09PSAnc2luZ2xlJyAmJiBzZWxmLml0ZW1zWzBdICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVfb3B0aW9uID0gc2VsZi5nZXRPcHRpb24oc2VsZi5pdGVtc1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZHJvcGRvd25fY29udGVudC5jb250YWlucyhhY3RpdmVfb3B0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWN0aXZlX2luZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNyZWF0ZSAmJiAhc2VsZi5zZXR0aW5ncy5hZGRQcmVjZWRlbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVfaW5kZXggPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZV9vcHRpb24gPSBzZWxmLnNlbGVjdGFibGUoKVthY3RpdmVfaW5kZXhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNyZWF0ZSkge1xuICAgICAgICAgICAgICAgIGFjdGl2ZV9vcHRpb24gPSBjcmVhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJpZ2dlckRyb3Bkb3duICYmICFzZWxmLmlzT3Blbikge1xuICAgICAgICAgICAgICAgIHNlbGYub3BlbigpO1xuICAgICAgICAgICAgICAgIHNlbGYuc2Nyb2xsVG9PcHRpb24oYWN0aXZlX29wdGlvbiwgJ2F1dG8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuc2V0QWN0aXZlT3B0aW9uKGFjdGl2ZV9vcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5jbGVhckFjdGl2ZU9wdGlvbigpO1xuICAgICAgICAgICAgaWYgKHRyaWdnZXJEcm9wZG93biAmJiBzZWxmLmlzT3Blbikge1xuICAgICAgICAgICAgICAgIHNlbGYuY2xvc2UoZmFsc2UpOyAvLyBpZiBjcmVhdGVfb3B0aW9uPW51bGwsIHdlIHdhbnQgdGhlIGRyb3Bkb3duIHRvIGNsb3NlIGJ1dCBub3QgcmVzZXQgdGhlIHRleHRib3ggdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gbGlzdCBvZiBzZWxlY3RhYmxlIG9wdGlvbnNcbiAgICAgKlxuICAgICAqL1xuICAgIHNlbGVjdGFibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyb3Bkb3duX2NvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2VsZWN0YWJsZV0nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBhdmFpbGFibGUgb3B0aW9uLiBJZiBpdCBhbHJlYWR5IGV4aXN0cyxcbiAgICAgKiBub3RoaW5nIHdpbGwgaGFwcGVuLiBOb3RlOiB0aGlzIGRvZXMgbm90IHJlZnJlc2hcbiAgICAgKiB0aGUgb3B0aW9ucyBsaXN0IGRyb3Bkb3duICh1c2UgYHJlZnJlc2hPcHRpb25zYFxuICAgICAqIGZvciB0aGF0KS5cbiAgICAgKlxuICAgICAqIFVzYWdlOlxuICAgICAqXG4gICAgICogICB0aGlzLmFkZE9wdGlvbihkYXRhKVxuICAgICAqXG4gICAgICovXG4gICAgYWRkT3B0aW9uKGRhdGEsIHVzZXJfY3JlYXRlZCA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICAvLyBAZGVwcmVjYXRlZCAxLjcuN1xuICAgICAgICAvLyB1c2UgYWRkT3B0aW9ucyggYXJyYXksIHVzZXJfY3JlYXRlZCApIGZvciBhZGRpbmcgbXVsdGlwbGUgb3B0aW9uc1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgc2VsZi5hZGRPcHRpb25zKGRhdGEsIHVzZXJfY3JlYXRlZCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5ID0gaGFzaF9rZXkoZGF0YVtzZWxmLnNldHRpbmdzLnZhbHVlRmllbGRdKTtcbiAgICAgICAgaWYgKGtleSA9PT0gbnVsbCB8fCBzZWxmLm9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEuJG9yZGVyID0gZGF0YS4kb3JkZXIgfHwgKytzZWxmLm9yZGVyO1xuICAgICAgICBkYXRhLiRpZCA9IHNlbGYuaW5wdXRJZCArICctb3B0LScgKyBkYXRhLiRvcmRlcjtcbiAgICAgICAgc2VsZi5vcHRpb25zW2tleV0gPSBkYXRhO1xuICAgICAgICBzZWxmLmxhc3RRdWVyeSA9IG51bGw7XG4gICAgICAgIGlmICh1c2VyX2NyZWF0ZWQpIHtcbiAgICAgICAgICAgIHNlbGYudXNlck9wdGlvbnNba2V5XSA9IHVzZXJfY3JlYXRlZDtcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcignb3B0aW9uX2FkZCcsIGtleSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIG11bHRpcGxlIG9wdGlvbnNcbiAgICAgKlxuICAgICAqL1xuICAgIGFkZE9wdGlvbnMoZGF0YSwgdXNlcl9jcmVhdGVkID0gZmFsc2UpIHtcbiAgICAgICAgaXRlcmF0ZShkYXRhLCAoZGF0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZE9wdGlvbihkYXQsIHVzZXJfY3JlYXRlZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCAxLjcuN1xuICAgICAqL1xuICAgIHJlZ2lzdGVyT3B0aW9uKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkT3B0aW9uKGRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYW4gb3B0aW9uIGdyb3VwIHRvIHRoZSBwb29sIG9mIG9wdGlvbiBncm91cHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufHN0cmluZ31cbiAgICAgKi9cbiAgICByZWdpc3Rlck9wdGlvbkdyb3VwKGRhdGEpIHtcbiAgICAgICAgdmFyIGtleSA9IGhhc2hfa2V5KGRhdGFbdGhpcy5zZXR0aW5ncy5vcHRncm91cFZhbHVlRmllbGRdKTtcbiAgICAgICAgaWYgKGtleSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZGF0YS4kb3JkZXIgPSBkYXRhLiRvcmRlciB8fCArK3RoaXMub3JkZXI7XG4gICAgICAgIHRoaXMub3B0Z3JvdXBzW2tleV0gPSBkYXRhO1xuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBuZXcgb3B0Z3JvdXAgZm9yIG9wdGlvbnNcbiAgICAgKiB0byBiZSBidWNrZXRlZCBpbnRvLlxuICAgICAqXG4gICAgICovXG4gICAgYWRkT3B0aW9uR3JvdXAoaWQsIGRhdGEpIHtcbiAgICAgICAgdmFyIGhhc2hlZF9pZDtcbiAgICAgICAgZGF0YVt0aGlzLnNldHRpbmdzLm9wdGdyb3VwVmFsdWVGaWVsZF0gPSBpZDtcbiAgICAgICAgaWYgKGhhc2hlZF9pZCA9IHRoaXMucmVnaXN0ZXJPcHRpb25Hcm91cChkYXRhKSkge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdvcHRncm91cF9hZGQnLCBoYXNoZWRfaWQsIGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gZXhpc3Rpbmcgb3B0aW9uIGdyb3VwLlxuICAgICAqXG4gICAgICovXG4gICAgcmVtb3ZlT3B0aW9uR3JvdXAoaWQpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0Z3JvdXBzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMub3B0Z3JvdXBzW2lkXTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdvcHRncm91cF9yZW1vdmUnLCBpZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCBleGlzdGluZyBvcHRpb24gZ3JvdXBzLlxuICAgICAqL1xuICAgIGNsZWFyT3B0aW9uR3JvdXBzKCkge1xuICAgICAgICB0aGlzLm9wdGdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdvcHRncm91cF9jbGVhcicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGFuIG9wdGlvbiBhdmFpbGFibGUgZm9yIHNlbGVjdGlvbi4gSWZcbiAgICAgKiBpdCBpcyB2aXNpYmxlIGluIHRoZSBzZWxlY3RlZCBpdGVtcyBvciBvcHRpb25zXG4gICAgICogZHJvcGRvd24sIGl0IHdpbGwgYmUgcmUtcmVuZGVyZWQgYXV0b21hdGljYWxseS5cbiAgICAgKlxuICAgICAqL1xuICAgIHVwZGF0ZU9wdGlvbih2YWx1ZSwgZGF0YSkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGl0ZW1fbmV3O1xuICAgICAgICB2YXIgaW5kZXhfaXRlbTtcbiAgICAgICAgY29uc3QgdmFsdWVfb2xkID0gaGFzaF9rZXkodmFsdWUpO1xuICAgICAgICBjb25zdCB2YWx1ZV9uZXcgPSBoYXNoX2tleShkYXRhW3NlbGYuc2V0dGluZ3MudmFsdWVGaWVsZF0pO1xuICAgICAgICAvLyBzYW5pdHkgY2hlY2tzXG4gICAgICAgIGlmICh2YWx1ZV9vbGQgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGRhdGFfb2xkID0gc2VsZi5vcHRpb25zW3ZhbHVlX29sZF07XG4gICAgICAgIGlmIChkYXRhX29sZCA9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWVfbmV3ICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgbXVzdCBiZSBzZXQgaW4gb3B0aW9uIGRhdGEnKTtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gc2VsZi5nZXRPcHRpb24odmFsdWVfb2xkKTtcbiAgICAgICAgY29uc3QgaXRlbSA9IHNlbGYuZ2V0SXRlbSh2YWx1ZV9vbGQpO1xuICAgICAgICBkYXRhLiRvcmRlciA9IGRhdGEuJG9yZGVyIHx8IGRhdGFfb2xkLiRvcmRlcjtcbiAgICAgICAgZGVsZXRlIHNlbGYub3B0aW9uc1t2YWx1ZV9vbGRdO1xuICAgICAgICAvLyBpbnZhbGlkYXRlIHJlbmRlciBjYWNoZVxuICAgICAgICAvLyBkb24ndCByZW1vdmUgZXhpc3Rpbmcgbm9kZSB5ZXQsIHdlJ2xsIHJlbW92ZSBpdCBhZnRlciByZXBsYWNpbmcgaXRcbiAgICAgICAgc2VsZi51bmNhY2hlVmFsdWUodmFsdWVfbmV3KTtcbiAgICAgICAgc2VsZi5vcHRpb25zW3ZhbHVlX25ld10gPSBkYXRhO1xuICAgICAgICAvLyB1cGRhdGUgdGhlIG9wdGlvbiBpZiBpdCdzIGluIHRoZSBkcm9wZG93blxuICAgICAgICBpZiAob3B0aW9uKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5kcm9wZG93bl9jb250ZW50LmNvbnRhaW5zKG9wdGlvbikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25fbmV3ID0gc2VsZi5fcmVuZGVyKCdvcHRpb24nLCBkYXRhKTtcbiAgICAgICAgICAgICAgICByZXBsYWNlTm9kZShvcHRpb24sIG9wdGlvbl9uZXcpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmFjdGl2ZU9wdGlvbiA9PT0gb3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0QWN0aXZlT3B0aW9uKG9wdGlvbl9uZXcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbi5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGUgdGhlIGl0ZW0gaWYgd2UgaGF2ZSBvbmVcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGluZGV4X2l0ZW0gPSBzZWxmLml0ZW1zLmluZGV4T2YodmFsdWVfb2xkKTtcbiAgICAgICAgICAgIGlmIChpbmRleF9pdGVtICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHNlbGYuaXRlbXMuc3BsaWNlKGluZGV4X2l0ZW0sIDEsIHZhbHVlX25ldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtX25ldyA9IHNlbGYuX3JlbmRlcignaXRlbScsIGRhdGEpO1xuICAgICAgICAgICAgaWYgKGl0ZW0uY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSlcbiAgICAgICAgICAgICAgICBhZGRDbGFzc2VzKGl0ZW1fbmV3LCAnYWN0aXZlJyk7XG4gICAgICAgICAgICByZXBsYWNlTm9kZShpdGVtLCBpdGVtX25ldyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW52YWxpZGF0ZSBsYXN0IHF1ZXJ5IGJlY2F1c2Ugd2UgbWlnaHQgaGF2ZSB1cGRhdGVkIHRoZSBzb3J0RmllbGRcbiAgICAgICAgc2VsZi5sYXN0UXVlcnkgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgc2luZ2xlIG9wdGlvbi5cbiAgICAgKlxuICAgICAqL1xuICAgIHJlbW92ZU9wdGlvbih2YWx1ZSwgc2lsZW50KSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICB2YWx1ZSA9IGdldF9oYXNoKHZhbHVlKTtcbiAgICAgICAgc2VsZi51bmNhY2hlVmFsdWUodmFsdWUpO1xuICAgICAgICBkZWxldGUgc2VsZi51c2VyT3B0aW9uc1t2YWx1ZV07XG4gICAgICAgIGRlbGV0ZSBzZWxmLm9wdGlvbnNbdmFsdWVdO1xuICAgICAgICBzZWxmLmxhc3RRdWVyeSA9IG51bGw7XG4gICAgICAgIHNlbGYudHJpZ2dlcignb3B0aW9uX3JlbW92ZScsIHZhbHVlKTtcbiAgICAgICAgc2VsZi5yZW1vdmVJdGVtKHZhbHVlLCBzaWxlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIG9wdGlvbnMuXG4gICAgICovXG4gICAgY2xlYXJPcHRpb25zKGZpbHRlcikge1xuICAgICAgICBjb25zdCBib3VuZEZpbHRlciA9IChmaWx0ZXIgfHwgdGhpcy5jbGVhckZpbHRlcikuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5sb2FkZWRTZWFyY2hlcyA9IHt9O1xuICAgICAgICB0aGlzLnVzZXJPcHRpb25zID0ge307XG4gICAgICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xuICAgICAgICBjb25zdCBzZWxlY3RlZCA9IHt9O1xuICAgICAgICBpdGVyYXRlKHRoaXMub3B0aW9ucywgKG9wdGlvbiwga2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAoYm91bmRGaWx0ZXIob3B0aW9uLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRba2V5XSA9IG9wdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuc2lmdGVyLml0ZW1zID0gc2VsZWN0ZWQ7XG4gICAgICAgIHRoaXMubGFzdFF1ZXJ5ID0gbnVsbDtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdvcHRpb25fY2xlYXInKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCBieSBjbGVhck9wdGlvbnMoKSB0byBkZWNpZGUgd2hldGhlciBvciBub3QgYW4gb3B0aW9uIHNob3VsZCBiZSByZW1vdmVkXG4gICAgICogUmV0dXJuIHRydWUgdG8ga2VlcCBhbiBvcHRpb24sIGZhbHNlIHRvIHJlbW92ZVxuICAgICAqXG4gICAgICovXG4gICAgY2xlYXJGaWx0ZXIob3B0aW9uLCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pdGVtcy5pbmRleE9mKHZhbHVlKSA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRvbSBlbGVtZW50IG9mIHRoZSBvcHRpb25cbiAgICAgKiBtYXRjaGluZyB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXRPcHRpb24odmFsdWUsIGNyZWF0ZSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGhhc2hlZCA9IGhhc2hfa2V5KHZhbHVlKTtcbiAgICAgICAgaWYgKGhhc2hlZCA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCBvcHRpb24gPSB0aGlzLm9wdGlvbnNbaGFzaGVkXTtcbiAgICAgICAgaWYgKG9wdGlvbiAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb24uJGRpdikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb24uJGRpdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjcmVhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyKCdvcHRpb24nLCBvcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkb20gZWxlbWVudCBvZiB0aGUgbmV4dCBvciBwcmV2aW91cyBkb20gZWxlbWVudCBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICogTm90ZTogYWRqYWNlbnQgb3B0aW9ucyBtYXkgbm90IGJlIGFkamFjZW50IERPTSBlbGVtZW50cyAob3B0Z3JvdXBzKVxuICAgICAqXG4gICAgICovXG4gICAgZ2V0QWRqYWNlbnQob3B0aW9uLCBkaXJlY3Rpb24sIHR5cGUgPSAnb3B0aW9uJykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGFsbDtcbiAgICAgICAgaWYgKCFvcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09ICdpdGVtJykge1xuICAgICAgICAgICAgYWxsID0gc2VsZi5jb250cm9sQ2hpbGRyZW4oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFsbCA9IHNlbGYuZHJvcGRvd25fY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zZWxlY3RhYmxlXScpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYWxsW2ldICE9IG9wdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxsW2kgKyAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhbGxbaSAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkb20gZWxlbWVudCBvZiB0aGUgaXRlbVxuICAgICAqIG1hdGNoaW5nIHRoZSBnaXZlbiB2YWx1ZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGdldEl0ZW0oaXRlbSkge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZSA9IGhhc2hfa2V5KGl0ZW0pO1xuICAgICAgICByZXR1cm4gdmFsdWUgIT09IG51bGxcbiAgICAgICAgICAgID8gdGhpcy5jb250cm9sLnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLXZhbHVlPVwiJHthZGRTbGFzaGVzKHZhbHVlKX1cIl1gKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBcIlNlbGVjdHNcIiBtdWx0aXBsZSBpdGVtcyBhdCBvbmNlLiBBZGRzIHRoZW0gdG8gdGhlIGxpc3RcbiAgICAgKiBhdCB0aGUgY3VycmVudCBjYXJldCBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqL1xuICAgIGFkZEl0ZW1zKHZhbHVlcywgc2lsZW50KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGl0ZW1zID0gQXJyYXkuaXNBcnJheSh2YWx1ZXMpID8gdmFsdWVzIDogW3ZhbHVlc107XG4gICAgICAgIGl0ZW1zID0gaXRlbXMuZmlsdGVyKHggPT4gc2VsZi5pdGVtcy5pbmRleE9mKHgpID09PSAtMSk7XG4gICAgICAgIGNvbnN0IGxhc3RfaXRlbSA9IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgc2VsZi5pc1BlbmRpbmcgPSAoaXRlbSAhPT0gbGFzdF9pdGVtKTtcbiAgICAgICAgICAgIHNlbGYuYWRkSXRlbShpdGVtLCBzaWxlbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogXCJTZWxlY3RzXCIgYW4gaXRlbS4gQWRkcyBpdCB0byB0aGUgbGlzdFxuICAgICAqIGF0IHRoZSBjdXJyZW50IGNhcmV0IHBvc2l0aW9uLlxuICAgICAqXG4gICAgICovXG4gICAgYWRkSXRlbSh2YWx1ZSwgc2lsZW50KSB7XG4gICAgICAgIHZhciBldmVudHMgPSBzaWxlbnQgPyBbXSA6IFsnY2hhbmdlJywgJ2Ryb3Bkb3duX2Nsb3NlJ107XG4gICAgICAgIGRlYm91bmNlX2V2ZW50cyh0aGlzLCBldmVudHMsICgpID0+IHtcbiAgICAgICAgICAgIHZhciBpdGVtLCB3YXNGdWxsO1xuICAgICAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBpbnB1dE1vZGUgPSBzZWxmLnNldHRpbmdzLm1vZGU7XG4gICAgICAgICAgICBjb25zdCBoYXNoZWQgPSBoYXNoX2tleSh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoaGFzaGVkICYmIHNlbGYuaXRlbXMuaW5kZXhPZihoYXNoZWQpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dE1vZGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0TW9kZSA9PT0gJ3NpbmdsZScgfHwgIXNlbGYuc2V0dGluZ3MuZHVwbGljYXRlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc2hlZCA9PT0gbnVsbCB8fCAhc2VsZi5vcHRpb25zLmhhc093blByb3BlcnR5KGhhc2hlZCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGlucHV0TW9kZSA9PT0gJ3NpbmdsZScpXG4gICAgICAgICAgICAgICAgc2VsZi5jbGVhcihzaWxlbnQpO1xuICAgICAgICAgICAgaWYgKGlucHV0TW9kZSA9PT0gJ211bHRpJyAmJiBzZWxmLmlzRnVsbCgpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGl0ZW0gPSBzZWxmLl9yZW5kZXIoJ2l0ZW0nLCBzZWxmLm9wdGlvbnNbaGFzaGVkXSk7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb250cm9sLmNvbnRhaW5zKGl0ZW0pKSB7IC8vIGR1cGxpY2F0ZXNcbiAgICAgICAgICAgICAgICBpdGVtID0gaXRlbS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3YXNGdWxsID0gc2VsZi5pc0Z1bGwoKTtcbiAgICAgICAgICAgIHNlbGYuaXRlbXMuc3BsaWNlKHNlbGYuY2FyZXRQb3MsIDAsIGhhc2hlZCk7XG4gICAgICAgICAgICBzZWxmLmluc2VydEF0Q2FyZXQoaXRlbSk7XG4gICAgICAgICAgICBpZiAoc2VsZi5pc1NldHVwKSB7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIG1lbnUgLyByZW1vdmUgdGhlIG9wdGlvbiAoaWYgdGhpcyBpcyBub3Qgb25lIGl0ZW0gYmVpbmcgYWRkZWQgYXMgcGFydCBvZiBzZXJpZXMpXG4gICAgICAgICAgICAgICAgaWYgKCFzZWxmLmlzUGVuZGluZyAmJiBzZWxmLnNldHRpbmdzLmhpZGVTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb3B0aW9uID0gc2VsZi5nZXRPcHRpb24oaGFzaGVkKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBzZWxmLmdldEFkamFjZW50KG9wdGlvbiwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNldEFjdGl2ZU9wdGlvbihuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyByZWZyZXNoT3B0aW9ucyBhZnRlciBzZXRBY3RpdmVPcHRpb24oKSxcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2Ugc2V0QWN0aXZlT3B0aW9uKCkgd2lsbCBiZSBjYWxsZWQgYnkgcmVmcmVzaE9wdGlvbnMoKSB3aXRoIHRoZSB3cm9uZyB2YWx1ZVxuICAgICAgICAgICAgICAgIGlmICghc2VsZi5pc1BlbmRpbmcgJiYgIXNlbGYuc2V0dGluZ3MuY2xvc2VBZnRlclNlbGVjdCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnJlZnJlc2hPcHRpb25zKHNlbGYuaXNGb2N1c2VkICYmIGlucHV0TW9kZSAhPT0gJ3NpbmdsZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBoaWRlIHRoZSBtZW51IGlmIHRoZSBtYXhpbXVtIG51bWJlciBvZiBpdGVtcyBoYXZlIGJlZW4gc2VsZWN0ZWQgb3Igbm8gb3B0aW9ucyBhcmUgbGVmdFxuICAgICAgICAgICAgICAgIGlmIChzZWxmLnNldHRpbmdzLmNsb3NlQWZ0ZXJTZWxlY3QgIT0gZmFsc2UgJiYgc2VsZi5pc0Z1bGwoKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFzZWxmLmlzUGVuZGluZykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnBvc2l0aW9uRHJvcGRvd24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdpdGVtX2FkZCcsIGhhc2hlZCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxmLmlzUGVuZGluZykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZU9yaWdpbmFsSW5wdXQoeyBzaWxlbnQ6IHNpbGVudCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNlbGYuaXNQZW5kaW5nIHx8ICghd2FzRnVsbCAmJiBzZWxmLmlzRnVsbCgpKSkge1xuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIHNlbGYucmVmcmVzaFN0YXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBzZWxlY3RlZCBpdGVtIG1hdGNoaW5nXG4gICAgICogdGhlIHByb3ZpZGVkIHZhbHVlLlxuICAgICAqXG4gICAgICovXG4gICAgcmVtb3ZlSXRlbShpdGVtID0gbnVsbCwgc2lsZW50KSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpdGVtID0gc2VsZi5nZXRJdGVtKGl0ZW0pO1xuICAgICAgICBpZiAoIWl0ZW0pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBpLCBpZHg7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaXRlbS5kYXRhc2V0LnZhbHVlO1xuICAgICAgICBpID0gbm9kZUluZGV4KGl0ZW0pO1xuICAgICAgICBpdGVtLnJlbW92ZSgpO1xuICAgICAgICBpZiAoaXRlbS5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpKSB7XG4gICAgICAgICAgICBpZHggPSBzZWxmLmFjdGl2ZUl0ZW1zLmluZGV4T2YoaXRlbSk7XG4gICAgICAgICAgICBzZWxmLmFjdGl2ZUl0ZW1zLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3NlcyhpdGVtLCAnYWN0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5pdGVtcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHNlbGYubGFzdFF1ZXJ5ID0gbnVsbDtcbiAgICAgICAgaWYgKCFzZWxmLnNldHRpbmdzLnBlcnNpc3QgJiYgc2VsZi51c2VyT3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHNlbGYucmVtb3ZlT3B0aW9uKHZhbHVlLCBzaWxlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpIDwgc2VsZi5jYXJldFBvcykge1xuICAgICAgICAgICAgc2VsZi5zZXRDYXJldChzZWxmLmNhcmV0UG9zIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi51cGRhdGVPcmlnaW5hbElucHV0KHsgc2lsZW50OiBzaWxlbnQgfSk7XG4gICAgICAgIHNlbGYucmVmcmVzaFN0YXRlKCk7XG4gICAgICAgIHNlbGYucG9zaXRpb25Ecm9wZG93bigpO1xuICAgICAgICBzZWxmLnRyaWdnZXIoJ2l0ZW1fcmVtb3ZlJywgdmFsdWUsIGl0ZW0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBgY3JlYXRlYCBtZXRob2QgcHJvdmlkZWQgaW4gdGhlXG4gICAgICogVG9tU2VsZWN0IG9wdGlvbnMgdGhhdCBzaG91bGQgcHJvdmlkZSB0aGUgZGF0YVxuICAgICAqIGZvciB0aGUgbmV3IGl0ZW0sIGdpdmVuIHRoZSB1c2VyIGlucHV0LlxuICAgICAqXG4gICAgICogT25jZSB0aGlzIGNvbXBsZXRlcywgaXQgd2lsbCBiZSBhZGRlZFxuICAgICAqIHRvIHRoZSBpdGVtIGxpc3QuXG4gICAgICpcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtKGlucHV0ID0gbnVsbCwgY2FsbGJhY2sgPSAoKSA9PiB7IH0pIHtcbiAgICAgICAgLy8gdHJpZ2dlckRyb3Bkb3duIHBhcmFtZXRlciBAZGVwcmVjYXRlZCAyLjEuMVxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBhcmd1bWVudHNbMl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9ICgpID0+IHsgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBjYXJldCA9IHNlbGYuY2FyZXRQb3M7XG4gICAgICAgIHZhciBvdXRwdXQ7XG4gICAgICAgIGlucHV0ID0gaW5wdXQgfHwgc2VsZi5pbnB1dFZhbHVlKCk7XG4gICAgICAgIGlmICghc2VsZi5jYW5DcmVhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYubG9jaygpO1xuICAgICAgICB2YXIgY3JlYXRlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgY3JlYXRlID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHNlbGYudW5sb2NrKCk7XG4gICAgICAgICAgICBpZiAoIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gaGFzaF9rZXkoZGF0YVtzZWxmLnNldHRpbmdzLnZhbHVlRmllbGRdKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLnNldFRleHRib3hWYWx1ZSgpO1xuICAgICAgICAgICAgc2VsZi5hZGRPcHRpb24oZGF0YSwgdHJ1ZSk7XG4gICAgICAgICAgICBzZWxmLnNldENhcmV0KGNhcmV0KTtcbiAgICAgICAgICAgIHNlbGYuYWRkSXRlbSh2YWx1ZSk7XG4gICAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgICAgIGNyZWF0ZWQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIHNlbGYuc2V0dGluZ3MuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBzZWxmLnNldHRpbmdzLmNyZWF0ZS5jYWxsKHRoaXMsIGlucHV0LCBjcmVhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0ID0ge1xuICAgICAgICAgICAgICAgIFtzZWxmLnNldHRpbmdzLmxhYmVsRmllbGRdOiBpbnB1dCxcbiAgICAgICAgICAgICAgICBbc2VsZi5zZXR0aW5ncy52YWx1ZUZpZWxkXTogaW5wdXQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3JlYXRlZCkge1xuICAgICAgICAgICAgY3JlYXRlKG91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlLXJlbmRlcnMgdGhlIHNlbGVjdGVkIGl0ZW0gbGlzdHMuXG4gICAgICovXG4gICAgcmVmcmVzaEl0ZW1zKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHNlbGYubGFzdFF1ZXJ5ID0gbnVsbDtcbiAgICAgICAgaWYgKHNlbGYuaXNTZXR1cCkge1xuICAgICAgICAgICAgc2VsZi5hZGRJdGVtcyhzZWxmLml0ZW1zKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLnVwZGF0ZU9yaWdpbmFsSW5wdXQoKTtcbiAgICAgICAgc2VsZi5yZWZyZXNoU3RhdGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhbGwgc3RhdGUtZGVwZW5kZW50IGF0dHJpYnV0ZXNcbiAgICAgKiBhbmQgQ1NTIGNsYXNzZXMuXG4gICAgICovXG4gICAgcmVmcmVzaFN0YXRlKCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgc2VsZi5yZWZyZXNoVmFsaWRpdHlTdGF0ZSgpO1xuICAgICAgICBjb25zdCBpc0Z1bGwgPSBzZWxmLmlzRnVsbCgpO1xuICAgICAgICBjb25zdCBpc0xvY2tlZCA9IHNlbGYuaXNMb2NrZWQ7XG4gICAgICAgIHNlbGYud3JhcHBlci5jbGFzc0xpc3QudG9nZ2xlKCdydGwnLCBzZWxmLnJ0bCk7XG4gICAgICAgIGNvbnN0IHdyYXBfY2xhc3NMaXN0ID0gc2VsZi53cmFwcGVyLmNsYXNzTGlzdDtcbiAgICAgICAgd3JhcF9jbGFzc0xpc3QudG9nZ2xlKCdmb2N1cycsIHNlbGYuaXNGb2N1c2VkKTtcbiAgICAgICAgd3JhcF9jbGFzc0xpc3QudG9nZ2xlKCdkaXNhYmxlZCcsIHNlbGYuaXNEaXNhYmxlZCk7XG4gICAgICAgIHdyYXBfY2xhc3NMaXN0LnRvZ2dsZSgncmVhZG9ubHknLCBzZWxmLmlzUmVhZE9ubHkpO1xuICAgICAgICB3cmFwX2NsYXNzTGlzdC50b2dnbGUoJ3JlcXVpcmVkJywgc2VsZi5pc1JlcXVpcmVkKTtcbiAgICAgICAgd3JhcF9jbGFzc0xpc3QudG9nZ2xlKCdpbnZhbGlkJywgIXNlbGYuaXNWYWxpZCk7XG4gICAgICAgIHdyYXBfY2xhc3NMaXN0LnRvZ2dsZSgnbG9ja2VkJywgaXNMb2NrZWQpO1xuICAgICAgICB3cmFwX2NsYXNzTGlzdC50b2dnbGUoJ2Z1bGwnLCBpc0Z1bGwpO1xuICAgICAgICB3cmFwX2NsYXNzTGlzdC50b2dnbGUoJ2lucHV0LWFjdGl2ZScsIHNlbGYuaXNGb2N1c2VkICYmICFzZWxmLmlzSW5wdXRIaWRkZW4pO1xuICAgICAgICB3cmFwX2NsYXNzTGlzdC50b2dnbGUoJ2Ryb3Bkb3duLWFjdGl2ZScsIHNlbGYuaXNPcGVuKTtcbiAgICAgICAgd3JhcF9jbGFzc0xpc3QudG9nZ2xlKCdoYXMtb3B0aW9ucycsIGlzRW1wdHlPYmplY3Qoc2VsZi5vcHRpb25zKSk7XG4gICAgICAgIHdyYXBfY2xhc3NMaXN0LnRvZ2dsZSgnaGFzLWl0ZW1zJywgc2VsZi5pdGVtcy5sZW5ndGggPiAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBgcmVxdWlyZWRgIGF0dHJpYnV0ZSBvZiBib3RoIGlucHV0IGFuZCBjb250cm9sIGlucHV0LlxuICAgICAqXG4gICAgICogVGhlIGByZXF1aXJlZGAgcHJvcGVydHkgbmVlZHMgdG8gYmUgYWN0aXZhdGVkIG9uIHRoZSBjb250cm9sIGlucHV0XG4gICAgICogZm9yIHRoZSBlcnJvciB0byBiZSBkaXNwbGF5ZWQgYXQgdGhlIHJpZ2h0IHBsYWNlLiBgcmVxdWlyZWRgIGFsc29cbiAgICAgKiBuZWVkcyB0byBiZSB0ZW1wb3JhcmlseSBkZWFjdGl2YXRlZCBvbiB0aGUgaW5wdXQgc2luY2UgdGhlIGlucHV0IGlzXG4gICAgICogaGlkZGVuIGFuZCBjYW4ndCBzaG93IGVycm9ycy5cbiAgICAgKi9cbiAgICByZWZyZXNoVmFsaWRpdHlTdGF0ZSgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoIXNlbGYuaW5wdXQudmFsaWRpdHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmlzVmFsaWQgPSBzZWxmLmlucHV0LnZhbGlkaXR5LnZhbGlkO1xuICAgICAgICBzZWxmLmlzSW52YWxpZCA9ICFzZWxmLmlzVmFsaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgbW9yZSBpdGVtcyBjYW4gYmUgYWRkZWRcbiAgICAgKiB0byB0aGUgY29udHJvbCB3aXRob3V0IGV4Y2VlZGluZyB0aGUgdXNlci1kZWZpbmVkIG1heGltdW0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0Z1bGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzLm1heEl0ZW1zICE9PSBudWxsICYmIHRoaXMuaXRlbXMubGVuZ3RoID49IHRoaXMuc2V0dGluZ3MubWF4SXRlbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZnJlc2hlcyB0aGUgb3JpZ2luYWwgPHNlbGVjdD4gb3IgPGlucHV0PlxuICAgICAqIGVsZW1lbnQgdG8gcmVmbGVjdCB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICAgKlxuICAgICAqL1xuICAgIHVwZGF0ZU9yaWdpbmFsSW5wdXQob3B0cyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgb3B0aW9uLCBsYWJlbDtcbiAgICAgICAgY29uc3QgZW1wdHlfb3B0aW9uID0gc2VsZi5pbnB1dC5xdWVyeVNlbGVjdG9yKCdvcHRpb25bdmFsdWU9XCJcIl0nKTtcbiAgICAgICAgaWYgKHNlbGYuaXNfc2VsZWN0X3RhZykge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGhhc19zZWxlY3RlZCA9IHNlbGYuaW5wdXQucXVlcnlTZWxlY3RvckFsbCgnb3B0aW9uOmNoZWNrZWQnKS5sZW5ndGg7XG4gICAgICAgICAgICBmdW5jdGlvbiBBZGRTZWxlY3RlZChvcHRpb25fZWwsIHZhbHVlLCBsYWJlbCkge1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9uX2VsKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbl9lbCA9IGdldERvbSgnPG9wdGlvbiB2YWx1ZT1cIicgKyBlc2NhcGVfaHRtbCh2YWx1ZSkgKyAnXCI+JyArIGVzY2FwZV9odG1sKGxhYmVsKSArICc8L29wdGlvbj4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgbW92ZSBlbXB0eSBvcHRpb24gZnJvbSB0b3Agb2YgbGlzdFxuICAgICAgICAgICAgICAgIC8vIGZpeGVzIGJ1ZyBpbiBmaXJlZm94IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE3MjUyOTNcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uX2VsICE9IGVtcHR5X29wdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmlucHV0LmFwcGVuZChvcHRpb25fZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxlY3RlZC5wdXNoKG9wdGlvbl9lbCk7XG4gICAgICAgICAgICAgICAgLy8gbWFya2luZyBlbXB0eSBvcHRpb24gYXMgc2VsZWN0ZWQgY2FuIGJyZWFrIHZhbGlkYXRpb25cbiAgICAgICAgICAgICAgICAvLyBmaXhlcyBodHRwczovL2dpdGh1Yi5jb20vb3JjaGlkanMvdG9tLXNlbGVjdC9pc3N1ZXMvMzAzXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbl9lbCAhPSBlbXB0eV9vcHRpb24gfHwgaGFzX3NlbGVjdGVkID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25fZWwuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9uX2VsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdW5zZWxlY3QgYWxsIHNlbGVjdGVkIG9wdGlvbnNcbiAgICAgICAgICAgIHNlbGYuaW5wdXQucXVlcnlTZWxlY3RvckFsbCgnb3B0aW9uOmNoZWNrZWQnKS5mb3JFYWNoKChvcHRpb25fZWwpID0+IHtcbiAgICAgICAgICAgICAgICBvcHRpb25fZWwuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gbm90aGluZyBzZWxlY3RlZD9cbiAgICAgICAgICAgIGlmIChzZWxmLml0ZW1zLmxlbmd0aCA9PSAwICYmIHNlbGYuc2V0dGluZ3MubW9kZSA9PSAnc2luZ2xlJykge1xuICAgICAgICAgICAgICAgIEFkZFNlbGVjdGVkKGVtcHR5X29wdGlvbiwgXCJcIiwgXCJcIik7XG4gICAgICAgICAgICAgICAgLy8gb3JkZXIgc2VsZWN0ZWQgPG9wdGlvbj4gdGFncyBmb3IgdmFsdWVzIGluIHNlbGYuaXRlbXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuaXRlbXMuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uID0gc2VsZi5vcHRpb25zW3ZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSBvcHRpb25bc2VsZi5zZXR0aW5ncy5sYWJlbEZpZWxkXSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkLmluY2x1ZGVzKG9wdGlvbi4kb3B0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV1c2Vfb3B0ID0gc2VsZi5pbnB1dC5xdWVyeVNlbGVjdG9yKGBvcHRpb25bdmFsdWU9XCIke2FkZFNsYXNoZXModmFsdWUpfVwiXTpub3QoOmNoZWNrZWQpYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBBZGRTZWxlY3RlZChyZXVzZV9vcHQsIHZhbHVlLCBsYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24uJG9wdGlvbiA9IEFkZFNlbGVjdGVkKG9wdGlvbi4kb3B0aW9uLCB2YWx1ZSwgbGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmlucHV0LnZhbHVlID0gc2VsZi5nZXRWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLmlzU2V0dXApIHtcbiAgICAgICAgICAgIGlmICghb3B0cy5zaWxlbnQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ2NoYW5nZScsIHNlbGYuZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIGF1dG9jb21wbGV0ZSBkcm9wZG93biBjb250YWluaW5nXG4gICAgICogdGhlIGF2YWlsYWJsZSBvcHRpb25zLlxuICAgICAqL1xuICAgIG9wZW4oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKHNlbGYuaXNMb2NrZWQgfHwgc2VsZi5pc09wZW4gfHwgKHNlbGYuc2V0dGluZ3MubW9kZSA9PT0gJ211bHRpJyAmJiBzZWxmLmlzRnVsbCgpKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc2VsZi5pc09wZW4gPSB0cnVlO1xuICAgICAgICBzZXRBdHRyKHNlbGYuZm9jdXNfbm9kZSwgeyAnYXJpYS1leHBhbmRlZCc6ICd0cnVlJyB9KTtcbiAgICAgICAgc2VsZi5yZWZyZXNoU3RhdGUoKTtcbiAgICAgICAgYXBwbHlDU1Moc2VsZi5kcm9wZG93biwgeyB2aXNpYmlsaXR5OiAnaGlkZGVuJywgZGlzcGxheTogJ2Jsb2NrJyB9KTtcbiAgICAgICAgc2VsZi5wb3NpdGlvbkRyb3Bkb3duKCk7XG4gICAgICAgIGFwcGx5Q1NTKHNlbGYuZHJvcGRvd24sIHsgdmlzaWJpbGl0eTogJ3Zpc2libGUnLCBkaXNwbGF5OiAnYmxvY2snIH0pO1xuICAgICAgICBzZWxmLmZvY3VzKCk7XG4gICAgICAgIHNlbGYudHJpZ2dlcignZHJvcGRvd25fb3BlbicsIHNlbGYuZHJvcGRvd24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIGF1dG9jb21wbGV0ZSBkcm9wZG93biBtZW51LlxuICAgICAqL1xuICAgIGNsb3NlKHNldFRleHRib3hWYWx1ZSA9IHRydWUpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgdHJpZ2dlciA9IHNlbGYuaXNPcGVuO1xuICAgICAgICBpZiAoc2V0VGV4dGJveFZhbHVlKSB7XG4gICAgICAgICAgICAvLyBiZWZvcmUgYmx1cigpIHRvIHByZXZlbnQgZm9ybSBvbmNoYW5nZSBldmVudFxuICAgICAgICAgICAgc2VsZi5zZXRUZXh0Ym94VmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChzZWxmLnNldHRpbmdzLm1vZGUgPT09ICdzaW5nbGUnICYmIHNlbGYuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pbnB1dFN0YXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgc2V0QXR0cihzZWxmLmZvY3VzX25vZGUsIHsgJ2FyaWEtZXhwYW5kZWQnOiAnZmFsc2UnIH0pO1xuICAgICAgICBhcHBseUNTUyhzZWxmLmRyb3Bkb3duLCB7IGRpc3BsYXk6ICdub25lJyB9KTtcbiAgICAgICAgaWYgKHNlbGYuc2V0dGluZ3MuaGlkZVNlbGVjdGVkKSB7XG4gICAgICAgICAgICBzZWxmLmNsZWFyQWN0aXZlT3B0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5yZWZyZXNoU3RhdGUoKTtcbiAgICAgICAgaWYgKHRyaWdnZXIpXG4gICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ2Ryb3Bkb3duX2Nsb3NlJywgc2VsZi5kcm9wZG93bik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgYW5kIGFwcGxpZXMgdGhlIGFwcHJvcHJpYXRlXG4gICAgICogcG9zaXRpb24gb2YgdGhlIGRyb3Bkb3duIGlmIGRyb3Bkb3duUGFyZW50ID0gJ2JvZHknLlxuICAgICAqIE90aGVyd2lzZSwgcG9zaXRpb24gaXMgZGV0ZXJtaW5lZCBieSBjc3NcbiAgICAgKi9cbiAgICBwb3NpdGlvbkRyb3Bkb3duKCkge1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5kcm9wZG93blBhcmVudCAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRyb2w7XG4gICAgICAgIHZhciByZWN0ID0gY29udGV4dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIHRvcCA9IGNvbnRleHQub2Zmc2V0SGVpZ2h0ICsgcmVjdC50b3AgKyB3aW5kb3cuc2Nyb2xsWTtcbiAgICAgICAgdmFyIGxlZnQgPSByZWN0LmxlZnQgKyB3aW5kb3cuc2Nyb2xsWDtcbiAgICAgICAgYXBwbHlDU1ModGhpcy5kcm9wZG93biwge1xuICAgICAgICAgICAgd2lkdGg6IHJlY3Qud2lkdGggKyAncHgnLFxuICAgICAgICAgICAgdG9wOiB0b3AgKyAncHgnLFxuICAgICAgICAgICAgbGVmdDogbGVmdCArICdweCdcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyAvIGNsZWFycyBhbGwgc2VsZWN0ZWQgaXRlbXNcbiAgICAgKiBmcm9tIHRoZSBjb250cm9sLlxuICAgICAqXG4gICAgICovXG4gICAgY2xlYXIoc2lsZW50KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCFzZWxmLml0ZW1zLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGl0ZW1zID0gc2VsZi5jb250cm9sQ2hpbGRyZW4oKTtcbiAgICAgICAgaXRlcmF0ZShpdGVtcywgKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIHNlbGYucmVtb3ZlSXRlbShpdGVtLCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNlbGYuaW5wdXRTdGF0ZSgpO1xuICAgICAgICBpZiAoIXNpbGVudClcbiAgICAgICAgICAgIHNlbGYudXBkYXRlT3JpZ2luYWxJbnB1dCgpO1xuICAgICAgICBzZWxmLnRyaWdnZXIoJ2NsZWFyJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgaGVscGVyIG1ldGhvZCBmb3IgaW5zZXJ0aW5nIGFuIGVsZW1lbnRcbiAgICAgKiBhdCB0aGUgY3VycmVudCBjYXJldCBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqL1xuICAgIGluc2VydEF0Q2FyZXQoZWwpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGNhcmV0ID0gc2VsZi5jYXJldFBvcztcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gc2VsZi5jb250cm9sO1xuICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKGVsLCB0YXJnZXQuY2hpbGRyZW5bY2FyZXRdIHx8IG51bGwpO1xuICAgICAgICBzZWxmLnNldENhcmV0KGNhcmV0ICsgMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGN1cnJlbnQgc2VsZWN0ZWQgaXRlbShzKS5cbiAgICAgKlxuICAgICAqL1xuICAgIGRlbGV0ZVNlbGVjdGlvbihlKSB7XG4gICAgICAgIHZhciBkaXJlY3Rpb24sIHNlbGVjdGlvbiwgY2FyZXQsIHRhaWw7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgZGlyZWN0aW9uID0gKGUgJiYgZS5rZXlDb2RlID09PSBjb25zdGFudHMuS0VZX0JBQ0tTUEFDRSkgPyAtMSA6IDE7XG4gICAgICAgIHNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihzZWxmLmNvbnRyb2xfaW5wdXQpO1xuICAgICAgICAvLyBkZXRlcm1pbmUgaXRlbXMgdGhhdCB3aWxsIGJlIHJlbW92ZWRcbiAgICAgICAgY29uc3Qgcm1faXRlbXMgPSBbXTtcbiAgICAgICAgaWYgKHNlbGYuYWN0aXZlSXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0YWlsID0gZ2V0VGFpbChzZWxmLmFjdGl2ZUl0ZW1zLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgY2FyZXQgPSBub2RlSW5kZXgodGFpbCk7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID4gMCkge1xuICAgICAgICAgICAgICAgIGNhcmV0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVyYXRlKHNlbGYuYWN0aXZlSXRlbXMsIChpdGVtKSA9PiBybV9pdGVtcy5wdXNoKGl0ZW0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoc2VsZi5pc0ZvY3VzZWQgfHwgc2VsZi5zZXR0aW5ncy5tb2RlID09PSAnc2luZ2xlJykgJiYgc2VsZi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gc2VsZi5jb250cm9sQ2hpbGRyZW4oKTtcbiAgICAgICAgICAgIGxldCBybV9pdGVtO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA8IDAgJiYgc2VsZWN0aW9uLnN0YXJ0ID09PSAwICYmIHNlbGVjdGlvbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBybV9pdGVtID0gaXRlbXNbc2VsZi5jYXJldFBvcyAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uID4gMCAmJiBzZWxlY3Rpb24uc3RhcnQgPT09IHNlbGYuaW5wdXRWYWx1ZSgpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJtX2l0ZW0gPSBpdGVtc1tzZWxmLmNhcmV0UG9zXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChybV9pdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBybV9pdGVtcy5wdXNoKHJtX2l0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghc2VsZi5zaG91bGREZWxldGUocm1faXRlbXMsIGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmVudERlZmF1bHQoZSwgdHJ1ZSk7XG4gICAgICAgIC8vIHBlcmZvcm0gcmVtb3ZhbFxuICAgICAgICBpZiAodHlwZW9mIGNhcmV0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgc2VsZi5zZXRDYXJldChjYXJldCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHJtX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgc2VsZi5yZW1vdmVJdGVtKHJtX2l0ZW1zLnBvcCgpKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmlucHV0U3RhdGUoKTtcbiAgICAgICAgc2VsZi5wb3NpdGlvbkRyb3Bkb3duKCk7XG4gICAgICAgIHNlbGYucmVmcmVzaE9wdGlvbnMoZmFsc2UpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIGl0ZW1zIHNob3VsZCBiZSBkZWxldGVkXG4gICAgICovXG4gICAgc2hvdWxkRGVsZXRlKGl0ZW1zLCBldnQpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gaXRlbXMubWFwKGl0ZW0gPT4gaXRlbS5kYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgLy8gYWxsb3cgdGhlIGNhbGxiYWNrIHRvIGFib3J0XG4gICAgICAgIGlmICghdmFsdWVzLmxlbmd0aCB8fCAodHlwZW9mIHRoaXMuc2V0dGluZ3Mub25EZWxldGUgPT09ICdmdW5jdGlvbicgJiYgdGhpcy5zZXR0aW5ncy5vbkRlbGV0ZSh2YWx1ZXMsIGV2dCkgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIHRoZSBwcmV2aW91cyAvIG5leHQgaXRlbSAoZGVwZW5kaW5nIG9uIHRoZSBgZGlyZWN0aW9uYCBhcmd1bWVudCkuXG4gICAgICpcbiAgICAgKiA+IDAgLSByaWdodFxuICAgICAqIDwgMCAtIGxlZnRcbiAgICAgKlxuICAgICAqL1xuICAgIGFkdmFuY2VTZWxlY3Rpb24oZGlyZWN0aW9uLCBlKSB7XG4gICAgICAgIHZhciBsYXN0X2FjdGl2ZSwgYWRqYWNlbnQsIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoc2VsZi5ydGwpXG4gICAgICAgICAgICBkaXJlY3Rpb24gKj0gLTE7XG4gICAgICAgIGlmIChzZWxmLmlucHV0VmFsdWUoKS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIGFkZCBvciByZW1vdmUgdG8gYWN0aXZlIGl0ZW1zXG4gICAgICAgIGlmIChpc0tleURvd24oY29uc3RhbnRzLktFWV9TSE9SVENVVCwgZSkgfHwgaXNLZXlEb3duKCdzaGlmdEtleScsIGUpKSB7XG4gICAgICAgICAgICBsYXN0X2FjdGl2ZSA9IHNlbGYuZ2V0TGFzdEFjdGl2ZShkaXJlY3Rpb24pO1xuICAgICAgICAgICAgaWYgKGxhc3RfYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsYXN0X2FjdGl2ZS5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkamFjZW50ID0gbGFzdF9hY3RpdmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhZGphY2VudCA9IHNlbGYuZ2V0QWRqYWNlbnQobGFzdF9hY3RpdmUsIGRpcmVjdGlvbiwgJ2l0ZW0nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgbm8gYWN0aXZlIGl0ZW0sIGdldCBpdGVtcyBhZGphY2VudCB0byB0aGUgY29udHJvbCBpbnB1dFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uID4gMCkge1xuICAgICAgICAgICAgICAgIGFkamFjZW50ID0gc2VsZi5jb250cm9sX2lucHV0Lm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkamFjZW50ID0gc2VsZi5jb250cm9sX2lucHV0LnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWRqYWNlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWRqYWNlbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbW92ZUFjdGl2ZUl0ZW0obGFzdF9hY3RpdmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLnNldEFjdGl2ZUl0ZW1DbGFzcyhhZGphY2VudCk7IC8vIG1hcmsgYXMgbGFzdF9hY3RpdmUgISEgYWZ0ZXIgcmVtb3ZlQWN0aXZlSXRlbSgpIG9uIGxhc3RfYWN0aXZlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtb3ZlIGNhcmV0IHRvIHRoZSBsZWZ0IG9yIHJpZ2h0XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWxmLm1vdmVDYXJldChkaXJlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vdmVDYXJldChkaXJlY3Rpb24pIHsgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbGFzdCBhY3RpdmUgaXRlbVxuICAgICAqXG4gICAgICovXG4gICAgZ2V0TGFzdEFjdGl2ZShkaXJlY3Rpb24pIHtcbiAgICAgICAgbGV0IGxhc3RfYWN0aXZlID0gdGhpcy5jb250cm9sLnF1ZXJ5U2VsZWN0b3IoJy5sYXN0LWFjdGl2ZScpO1xuICAgICAgICBpZiAobGFzdF9hY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXN0X2FjdGl2ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jb250cm9sLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hY3RpdmUnKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFRhaWwocmVzdWx0LCBkaXJlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vdmVzIHRoZSBjYXJldCB0byB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgICAqXG4gICAgICogVGhlIGlucHV0IG11c3QgYmUgbW92ZWQgYnkgbGVhdmluZyBpdCBpbiBwbGFjZSBhbmQgbW92aW5nIHRoZVxuICAgICAqIHNpYmxpbmdzLCBkdWUgdG8gdGhlIGZhY3QgdGhhdCBmb2N1cyBjYW5ub3QgYmUgcmVzdG9yZWQgb25jZSBsb3N0XG4gICAgICogb24gbW9iaWxlIHdlYmtpdCBkZXZpY2VzXG4gICAgICpcbiAgICAgKi9cbiAgICBzZXRDYXJldChuZXdfcG9zKSB7XG4gICAgICAgIHRoaXMuY2FyZXRQb3MgPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGxpc3Qgb2YgaXRlbSBkb20gZWxlbWVudHNcbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnRyb2xDaGlsZHJlbigpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jb250cm9sLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXRzLWl0ZW1dJykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlcyB1c2VyIGlucHV0IG9uIHRoZSBjb250cm9sLiBVc2VkIHdoaWxlXG4gICAgICogaXRlbXMgYXJlIGJlaW5nIGFzeW5jaHJvbm91c2x5IGNyZWF0ZWQuXG4gICAgICovXG4gICAgbG9jaygpIHtcbiAgICAgICAgdGhpcy5zZXRMb2NrZWQodHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlLWVuYWJsZXMgdXNlciBpbnB1dCBvbiB0aGUgY29udHJvbC5cbiAgICAgKi9cbiAgICB1bmxvY2soKSB7XG4gICAgICAgIHRoaXMuc2V0TG9ja2VkKGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzYWJsZSBvciBlbmFibGUgdXNlciBpbnB1dCBvbiB0aGUgY29udHJvbFxuICAgICAqL1xuICAgIHNldExvY2tlZChsb2NrID0gdGhpcy5pc1JlYWRPbmx5IHx8IHRoaXMuaXNEaXNhYmxlZCkge1xuICAgICAgICB0aGlzLmlzTG9ja2VkID0gbG9jaztcbiAgICAgICAgdGhpcy5yZWZyZXNoU3RhdGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMgdXNlciBpbnB1dCBvbiB0aGUgY29udHJvbCBjb21wbGV0ZWx5LlxuICAgICAqIFdoaWxlIGRpc2FibGVkLCBpdCBjYW5ub3QgcmVjZWl2ZSBmb2N1cy5cbiAgICAgKi9cbiAgICBkaXNhYmxlKCkge1xuICAgICAgICB0aGlzLnNldERpc2FibGVkKHRydWUpO1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgdGhlIGNvbnRyb2wgc28gdGhhdCBpdCBjYW4gcmVzcG9uZFxuICAgICAqIHRvIGZvY3VzIGFuZCB1c2VyIGlucHV0LlxuICAgICAqL1xuICAgIGVuYWJsZSgpIHtcbiAgICAgICAgdGhpcy5zZXREaXNhYmxlZChmYWxzZSk7XG4gICAgfVxuICAgIHNldERpc2FibGVkKGRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuZm9jdXNfbm9kZS50YWJJbmRleCA9IGRpc2FibGVkID8gLTEgOiB0aGlzLnRhYkluZGV4O1xuICAgICAgICB0aGlzLmlzRGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICAgICAgdGhpcy5pbnB1dC5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgICAgICB0aGlzLmNvbnRyb2xfaW5wdXQuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICAgICAgdGhpcy5zZXRMb2NrZWQoKTtcbiAgICB9XG4gICAgc2V0UmVhZE9ubHkoaXNSZWFkT25seSkge1xuICAgICAgICB0aGlzLmlzUmVhZE9ubHkgPSBpc1JlYWRPbmx5O1xuICAgICAgICB0aGlzLmlucHV0LnJlYWRPbmx5ID0gaXNSZWFkT25seTtcbiAgICAgICAgdGhpcy5jb250cm9sX2lucHV0LnJlYWRPbmx5ID0gaXNSZWFkT25seTtcbiAgICAgICAgdGhpcy5zZXRMb2NrZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGxldGVseSBkZXN0cm95cyB0aGUgY29udHJvbCBhbmRcbiAgICAgKiB1bmJpbmRzIGFsbCBldmVudCBsaXN0ZW5lcnMgc28gdGhhdCBpdCBjYW5cbiAgICAgKiBiZSBnYXJiYWdlIGNvbGxlY3RlZC5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciByZXZlcnRTZXR0aW5ncyA9IHNlbGYucmV2ZXJ0U2V0dGluZ3M7XG4gICAgICAgIHNlbGYudHJpZ2dlcignZGVzdHJveScpO1xuICAgICAgICBzZWxmLm9mZigpO1xuICAgICAgICBzZWxmLndyYXBwZXIucmVtb3ZlKCk7XG4gICAgICAgIHNlbGYuZHJvcGRvd24ucmVtb3ZlKCk7XG4gICAgICAgIHNlbGYuaW5wdXQuaW5uZXJIVE1MID0gcmV2ZXJ0U2V0dGluZ3MuaW5uZXJIVE1MO1xuICAgICAgICBzZWxmLmlucHV0LnRhYkluZGV4ID0gcmV2ZXJ0U2V0dGluZ3MudGFiSW5kZXg7XG4gICAgICAgIHJlbW92ZUNsYXNzZXMoc2VsZi5pbnB1dCwgJ3RvbXNlbGVjdGVkJywgJ3RzLWhpZGRlbi1hY2Nlc3NpYmxlJyk7XG4gICAgICAgIHNlbGYuX2Rlc3Ryb3koKTtcbiAgICAgICAgZGVsZXRlIHNlbGYuaW5wdXQudG9tc2VsZWN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGhlbHBlciBtZXRob2QgZm9yIHJlbmRlcmluZyBcIml0ZW1cIiBhbmRcbiAgICAgKiBcIm9wdGlvblwiIHRlbXBsYXRlcywgZ2l2ZW4gdGhlIGRhdGEuXG4gICAgICpcbiAgICAgKi9cbiAgICByZW5kZXIodGVtcGxhdGVOYW1lLCBkYXRhKSB7XG4gICAgICAgIHZhciBpZCwgaHRtbDtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5zZXR0aW5ncy5yZW5kZXJbdGVtcGxhdGVOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVuZGVyIG1hcmt1cFxuICAgICAgICBodG1sID0gc2VsZi5zZXR0aW5ncy5yZW5kZXJbdGVtcGxhdGVOYW1lXS5jYWxsKHRoaXMsIGRhdGEsIGVzY2FwZV9odG1sKTtcbiAgICAgICAgaWYgKCFodG1sKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBodG1sID0gZ2V0RG9tKGh0bWwpO1xuICAgICAgICAvLyBhZGQgbWFuZGF0b3J5IGF0dHJpYnV0ZXNcbiAgICAgICAgaWYgKHRlbXBsYXRlTmFtZSA9PT0gJ29wdGlvbicgfHwgdGVtcGxhdGVOYW1lID09PSAnb3B0aW9uX2NyZWF0ZScpIHtcbiAgICAgICAgICAgIGlmIChkYXRhW3NlbGYuc2V0dGluZ3MuZGlzYWJsZWRGaWVsZF0pIHtcbiAgICAgICAgICAgICAgICBzZXRBdHRyKGh0bWwsIHsgJ2FyaWEtZGlzYWJsZWQnOiAndHJ1ZScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRBdHRyKGh0bWwsIHsgJ2RhdGEtc2VsZWN0YWJsZSc6ICcnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRlbXBsYXRlTmFtZSA9PT0gJ29wdGdyb3VwJykge1xuICAgICAgICAgICAgaWQgPSBkYXRhLmdyb3VwW3NlbGYuc2V0dGluZ3Mub3B0Z3JvdXBWYWx1ZUZpZWxkXTtcbiAgICAgICAgICAgIHNldEF0dHIoaHRtbCwgeyAnZGF0YS1ncm91cCc6IGlkIH0pO1xuICAgICAgICAgICAgaWYgKGRhdGEuZ3JvdXBbc2VsZi5zZXR0aW5ncy5kaXNhYmxlZEZpZWxkXSkge1xuICAgICAgICAgICAgICAgIHNldEF0dHIoaHRtbCwgeyAnZGF0YS1kaXNhYmxlZCc6ICcnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0ZW1wbGF0ZU5hbWUgPT09ICdvcHRpb24nIHx8IHRlbXBsYXRlTmFtZSA9PT0gJ2l0ZW0nKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGdldF9oYXNoKGRhdGFbc2VsZi5zZXR0aW5ncy52YWx1ZUZpZWxkXSk7XG4gICAgICAgICAgICBzZXRBdHRyKGh0bWwsIHsgJ2RhdGEtdmFsdWUnOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBoYXZlIHNvbWUgY2xhc3NlcyBpZiBhIHRlbXBsYXRlIGlzIG92ZXJ3cml0dGVuXG4gICAgICAgICAgICBpZiAodGVtcGxhdGVOYW1lID09PSAnaXRlbScpIHtcbiAgICAgICAgICAgICAgICBhZGRDbGFzc2VzKGh0bWwsIHNlbGYuc2V0dGluZ3MuaXRlbUNsYXNzKTtcbiAgICAgICAgICAgICAgICBzZXRBdHRyKGh0bWwsIHsgJ2RhdGEtdHMtaXRlbSc6ICcnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3NlcyhodG1sLCBzZWxmLnNldHRpbmdzLm9wdGlvbkNsYXNzKTtcbiAgICAgICAgICAgICAgICBzZXRBdHRyKGh0bWwsIHtcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogJ29wdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIGlkOiBkYXRhLiRpZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBjYWNoZVxuICAgICAgICAgICAgICAgIGRhdGEuJGRpdiA9IGh0bWw7XG4gICAgICAgICAgICAgICAgc2VsZi5vcHRpb25zW3ZhbHVlXSA9IGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFR5cGUgZ3VhcmRlZCByZW5kZXJpbmdcbiAgICAgKlxuICAgICAqL1xuICAgIF9yZW5kZXIodGVtcGxhdGVOYW1lLCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGh0bWwgPSB0aGlzLnJlbmRlcih0ZW1wbGF0ZU5hbWUsIGRhdGEpO1xuICAgICAgICBpZiAoaHRtbCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyAnSFRNTEVsZW1lbnQgZXhwZWN0ZWQnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBodG1sO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIHJlbmRlciBjYWNoZSBmb3IgYSB0ZW1wbGF0ZS4gSWZcbiAgICAgKiBubyB0ZW1wbGF0ZSBpcyBnaXZlbiwgY2xlYXJzIGFsbCByZW5kZXJcbiAgICAgKiBjYWNoZXMuXG4gICAgICpcbiAgICAgKi9cbiAgICBjbGVhckNhY2hlKCkge1xuICAgICAgICBpdGVyYXRlKHRoaXMub3B0aW9ucywgKG9wdGlvbikgPT4ge1xuICAgICAgICAgICAgaWYgKG9wdGlvbi4kZGl2KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uLiRkaXYucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbi4kZGl2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHZhbHVlIGZyb20gaXRlbSBhbmQgb3B0aW9uIGNhY2hlc1xuICAgICAqXG4gICAgICovXG4gICAgdW5jYWNoZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbl9lbCA9IHRoaXMuZ2V0T3B0aW9uKHZhbHVlKTtcbiAgICAgICAgaWYgKG9wdGlvbl9lbClcbiAgICAgICAgICAgIG9wdGlvbl9lbC5yZW1vdmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0byBkaXNwbGF5IHRoZVxuICAgICAqIGNyZWF0ZSBpdGVtIHByb21wdCwgZ2l2ZW4gYSB1c2VyIGlucHV0LlxuICAgICAqXG4gICAgICovXG4gICAgY2FuQ3JlYXRlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzLmNyZWF0ZSAmJiAoaW5wdXQubGVuZ3RoID4gMCkgJiYgdGhpcy5zZXR0aW5ncy5jcmVhdGVGaWx0ZXIuY2FsbCh0aGlzLCBpbnB1dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyYXBzIHRoaXMuYG1ldGhvZGAgc28gdGhhdCBgbmV3X2ZuYCBjYW4gYmUgaW52b2tlZCAnYmVmb3JlJywgJ2FmdGVyJywgb3IgJ2luc3RlYWQnIG9mIHRoZSBvcmlnaW5hbCBtZXRob2RcbiAgICAgKlxuICAgICAqIHRoaXMuaG9vaygnaW5zdGVhZCcsJ29uS2V5RG93bicsZnVuY3Rpb24oIGFyZzEsIGFyZzIgLi4uKXtcbiAgICAgKlxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIGhvb2sod2hlbiwgbWV0aG9kLCBuZXdfZm4pIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgb3JpZ19tZXRob2QgPSBzZWxmW21ldGhvZF07XG4gICAgICAgIHNlbGZbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIHJlc3VsdF9uZXc7XG4gICAgICAgICAgICBpZiAod2hlbiA9PT0gJ2FmdGVyJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG9yaWdfbWV0aG9kLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRfbmV3ID0gbmV3X2ZuLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAod2hlbiA9PT0gJ2luc3RlYWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdF9uZXc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2hlbiA9PT0gJ2JlZm9yZScpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBvcmlnX21ldGhvZC5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9XG59XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b20tc2VsZWN0LmpzLm1hcCIsIi8qKlxuICogQ29udmVydHMgYSBzY2FsYXIgdG8gaXRzIGJlc3Qgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gKiBmb3IgaGFzaCBrZXlzIGFuZCBIVE1MIGF0dHJpYnV0ZSB2YWx1ZXMuXG4gKlxuICogVHJhbnNmb3JtYXRpb25zOlxuICogICAnc3RyJyAgICAgLT4gJ3N0cidcbiAqICAgbnVsbCAgICAgIC0+ICcnXG4gKiAgIHVuZGVmaW5lZCAtPiAnJ1xuICogICB0cnVlICAgICAgLT4gJzEnXG4gKiAgIGZhbHNlICAgICAtPiAnMCdcbiAqICAgMCAgICAgICAgIC0+ICcwJ1xuICogICAxICAgICAgICAgLT4gJzEnXG4gKlxuICovXG5leHBvcnQgY29uc3QgaGFzaF9rZXkgPSAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fCB2YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGdldF9oYXNoKHZhbHVlKTtcbn07XG5leHBvcnQgY29uc3QgZ2V0X2hhc2ggPSAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpXG4gICAgICAgIHJldHVybiB2YWx1ZSA/ICcxJyA6ICcwJztcbiAgICByZXR1cm4gdmFsdWUgKyAnJztcbn07XG4vKipcbiAqIEVzY2FwZXMgYSBzdHJpbmcgZm9yIHVzZSB3aXRoaW4gSFRNTC5cbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBlc2NhcGVfaHRtbCA9IChzdHIpID0+IHtcbiAgICByZXR1cm4gKHN0ciArICcnKVxuICAgICAgICAucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuICAgICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAgICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbn07XG4vKipcbiAqIHVzZSBzZXRUaW1lb3V0IGlmIHRpbWVvdXQgPiAwXG4gKi9cbmV4cG9ydCBjb25zdCB0aW1lb3V0ID0gKGZuLCB0aW1lb3V0KSA9PiB7XG4gICAgaWYgKHRpbWVvdXQgPiAwKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmbiwgdGltZW91dCk7XG4gICAgfVxuICAgIGZuLmNhbGwobnVsbCk7XG4gICAgcmV0dXJuIG51bGw7XG59O1xuLyoqXG4gKiBEZWJvdW5jZSB0aGUgdXNlciBwcm92aWRlZCBsb2FkIGZ1bmN0aW9uXG4gKlxuICovXG5leHBvcnQgY29uc3QgbG9hZERlYm91bmNlID0gKGZuLCBkZWxheSkgPT4ge1xuICAgIHZhciB0aW1lb3V0O1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgIHNlbGYubG9hZGluZyA9IE1hdGgubWF4KHNlbGYubG9hZGluZyAtIDEsIDApO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgc2VsZi5sb2FkZWRTZWFyY2hlc1t2YWx1ZV0gPSB0cnVlO1xuICAgICAgICAgICAgZm4uY2FsbChzZWxmLCB2YWx1ZSwgY2FsbGJhY2spO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgfTtcbn07XG4vKipcbiAqIERlYm91bmNlIGFsbCBmaXJlZCBldmVudHMgdHlwZXMgbGlzdGVkIGluIGB0eXBlc2BcbiAqIHdoaWxlIGV4ZWN1dGluZyB0aGUgcHJvdmlkZWQgYGZuYC5cbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBkZWJvdW5jZV9ldmVudHMgPSAoc2VsZiwgdHlwZXMsIGZuKSA9PiB7XG4gICAgdmFyIHR5cGU7XG4gICAgdmFyIHRyaWdnZXIgPSBzZWxmLnRyaWdnZXI7XG4gICAgdmFyIGV2ZW50X2FyZ3MgPSB7fTtcbiAgICAvLyBvdmVycmlkZSB0cmlnZ2VyIG1ldGhvZFxuICAgIHNlbGYudHJpZ2dlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIGlmICh0eXBlcy5pbmRleE9mKHR5cGUpICE9PSAtMSkge1xuICAgICAgICAgICAgZXZlbnRfYXJnc1t0eXBlXSA9IGFyZ3VtZW50cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cmlnZ2VyLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIGludm9rZSBwcm92aWRlZCBmdW5jdGlvblxuICAgIGZuLmFwcGx5KHNlbGYsIFtdKTtcbiAgICBzZWxmLnRyaWdnZXIgPSB0cmlnZ2VyO1xuICAgIC8vIHRyaWdnZXIgcXVldWVkIGV2ZW50c1xuICAgIGZvciAodHlwZSBvZiB0eXBlcykge1xuICAgICAgICBpZiAodHlwZSBpbiBldmVudF9hcmdzKSB7XG4gICAgICAgICAgICB0cmlnZ2VyLmFwcGx5KHNlbGYsIGV2ZW50X2FyZ3NbdHlwZV0pO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgY3VycmVudCBzZWxlY3Rpb24gd2l0aGluIGEgdGV4dCBpbnB1dCBjb250cm9sLlxuICogUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZzpcbiAqICAgLSBzdGFydFxuICogICAtIGxlbmd0aFxuICpcbiAqIE5vdGU6IFwic2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCAuLi4gYXBwbHkgb25seSB0byBpbnB1dHMgb2YgdHlwZXMgdGV4dCwgc2VhcmNoLCBVUkwsIHRlbCBhbmQgcGFzc3dvcmRcIlxuICogXHQtIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MSW5wdXRFbGVtZW50L3NldFNlbGVjdGlvblJhbmdlXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRTZWxlY3Rpb24gPSAoaW5wdXQpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogaW5wdXQuc2VsZWN0aW9uU3RhcnQgfHwgMCxcbiAgICAgICAgbGVuZ3RoOiAoaW5wdXQuc2VsZWN0aW9uRW5kIHx8IDApIC0gKGlucHV0LnNlbGVjdGlvblN0YXJ0IHx8IDApLFxuICAgIH07XG59O1xuLyoqXG4gKiBQcmV2ZW50IGRlZmF1bHRcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBwcmV2ZW50RGVmYXVsdCA9IChldnQsIHN0b3AgPSBmYWxzZSkgPT4ge1xuICAgIGlmIChldnQpIHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmIChzdG9wKSB7XG4gICAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuLyoqXG4gKiBBZGQgZXZlbnQgaGVscGVyXG4gKlxuICovXG5leHBvcnQgY29uc3QgYWRkRXZlbnQgPSAodGFyZ2V0LCB0eXBlLCBjYWxsYmFjaywgb3B0aW9ucykgPT4ge1xuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrLCBvcHRpb25zKTtcbn07XG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHRoZSByZXF1ZXN0ZWQga2V5IGlzIGRvd25cbiAqIFdpbGwgcmV0dXJuIGZhbHNlIGlmIG1vcmUgdGhhbiBvbmUgY29udHJvbCBjaGFyYWN0ZXIgaXMgcHJlc3NlZCAoIHdoZW4gW2N0cmwrc2hpZnQrYV0gIT0gW2N0cmwrYV0gKVxuICogVGhlIGN1cnJlbnQgZXZ0IG1heSBub3QgYWx3YXlzIHNldCAoIGVnIGNhbGxpbmcgYWR2YW5jZVNlbGVjdGlvbigpIClcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBpc0tleURvd24gPSAoa2V5X25hbWUsIGV2dCkgPT4ge1xuICAgIGlmICghZXZ0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFldnRba2V5X25hbWVdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGNvdW50ID0gKGV2dC5hbHRLZXkgPyAxIDogMCkgKyAoZXZ0LmN0cmxLZXkgPyAxIDogMCkgKyAoZXZ0LnNoaWZ0S2V5ID8gMSA6IDApICsgKGV2dC5tZXRhS2V5ID8gMSA6IDApO1xuICAgIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxuICogR2V0IHRoZSBpZCBvZiBhbiBlbGVtZW50XG4gKiBJZiB0aGUgaWQgYXR0cmlidXRlIGlzIG5vdCBzZXQsIHNldCB0aGUgYXR0cmlidXRlIHdpdGggdGhlIGdpdmVuIGlkXG4gKlxuICovXG5leHBvcnQgY29uc3QgZ2V0SWQgPSAoZWwsIGlkKSA9PiB7XG4gICAgY29uc3QgZXhpc3RpbmdfaWQgPSBlbC5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgaWYgKGV4aXN0aW5nX2lkKSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZ19pZDtcbiAgICB9XG4gICAgZWwuc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICByZXR1cm4gaWQ7XG59O1xuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHdpdGggYmFja3NsYXNoZXMgYWRkZWQgYmVmb3JlIGNoYXJhY3RlcnMgdGhhdCBuZWVkIHRvIGJlIGVzY2FwZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBhZGRTbGFzaGVzID0gKHN0cikgPT4ge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvW1xcXFxcIiddL2csICdcXFxcJCYnKTtcbn07XG4vKipcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBhcHBlbmQgPSAocGFyZW50LCBub2RlKSA9PiB7XG4gICAgaWYgKG5vZGUpXG4gICAgICAgIHBhcmVudC5hcHBlbmQobm9kZSk7XG59O1xuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGFycmF5cyBhbmQgaGFzaGVzLlxuICpcbiAqIGBgYFxuICogaXRlcmF0ZSh0aGlzLml0ZW1zLCBmdW5jdGlvbihpdGVtLCBpZCkge1xuICogICAgLy8gaW52b2tlZCBmb3IgZWFjaCBpdGVtXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IGl0ZXJhdGUgPSAob2JqZWN0LCBjYWxsYmFjaykgPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgb2JqZWN0LmZvckVhY2goY2FsbGJhY2spO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sob2JqZWN0W2tleV0sIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwiaW1wb3J0IHsgaXRlcmF0ZSB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG4vKipcbiAqIFJldHVybiBhIGRvbSBlbGVtZW50IGZyb20gZWl0aGVyIGEgZG9tIHF1ZXJ5IHN0cmluZywgalF1ZXJ5IG9iamVjdCwgYSBkb20gZWxlbWVudCBvciBodG1sIHN0cmluZ1xuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDk0MTQzL2NyZWF0aW5nLWEtbmV3LWRvbS1lbGVtZW50LWZyb20tYW4taHRtbC1zdHJpbmctdXNpbmctYnVpbHQtaW4tZG9tLW1ldGhvZHMtb3ItcHJvLzM1Mzg1NTE4IzM1Mzg1NTE4XG4gKlxuICogcGFyYW0gcXVlcnkgc2hvdWxkIGJlIHt9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXREb20gPSAocXVlcnkpID0+IHtcbiAgICBpZiAocXVlcnkuanF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiBxdWVyeVswXTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgIH1cbiAgICBpZiAoaXNIdG1sU3RyaW5nKHF1ZXJ5KSkge1xuICAgICAgICB2YXIgdHBsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdHBsLmlubmVySFRNTCA9IHF1ZXJ5LnRyaW0oKTsgLy8gTmV2ZXIgcmV0dXJuIGEgdGV4dCBub2RlIG9mIHdoaXRlc3BhY2UgYXMgdGhlIHJlc3VsdFxuICAgICAgICByZXR1cm4gdHBsLmNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgICB9XG4gICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocXVlcnkpO1xufTtcbmV4cG9ydCBjb25zdCBpc0h0bWxTdHJpbmcgPSAoYXJnKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnICYmIGFyZy5pbmRleE9mKCc8JykgPiAtMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmV4cG9ydCBjb25zdCBlc2NhcGVRdWVyeSA9IChxdWVyeSkgPT4ge1xuICAgIHJldHVybiBxdWVyeS5yZXBsYWNlKC9bJ1wiXFxcXF0vZywgJ1xcXFwkJicpO1xufTtcbi8qKlxuICogRGlzcGF0Y2ggYW4gZXZlbnRcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCB0cmlnZ2VyRXZlbnQgPSAoZG9tX2VsLCBldmVudF9uYW1lKSA9PiB7XG4gICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgICBldmVudC5pbml0RXZlbnQoZXZlbnRfbmFtZSwgdHJ1ZSwgZmFsc2UpO1xuICAgIGRvbV9lbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbn07XG4vKipcbiAqIEFwcGx5IENTUyBydWxlcyB0byBhIGRvbSBlbGVtZW50XG4gKlxuICovXG5leHBvcnQgY29uc3QgYXBwbHlDU1MgPSAoZG9tX2VsLCBjc3MpID0+IHtcbiAgICBPYmplY3QuYXNzaWduKGRvbV9lbC5zdHlsZSwgY3NzKTtcbn07XG4vKipcbiAqIEFkZCBjc3MgY2xhc3Nlc1xuICpcbiAqL1xuZXhwb3J0IGNvbnN0IGFkZENsYXNzZXMgPSAoZWxtdHMsIC4uLmNsYXNzZXMpID0+IHtcbiAgICB2YXIgbm9ybV9jbGFzc2VzID0gY2xhc3Nlc0FycmF5KGNsYXNzZXMpO1xuICAgIGVsbXRzID0gY2FzdEFzQXJyYXkoZWxtdHMpO1xuICAgIGVsbXRzLm1hcChlbCA9PiB7XG4gICAgICAgIG5vcm1fY2xhc3Nlcy5tYXAoY2xzID0+IHtcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuLyoqXG4gKiBSZW1vdmUgY3NzIGNsYXNzZXNcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVDbGFzc2VzID0gKGVsbXRzLCAuLi5jbGFzc2VzKSA9PiB7XG4gICAgdmFyIG5vcm1fY2xhc3NlcyA9IGNsYXNzZXNBcnJheShjbGFzc2VzKTtcbiAgICBlbG10cyA9IGNhc3RBc0FycmF5KGVsbXRzKTtcbiAgICBlbG10cy5tYXAoZWwgPT4ge1xuICAgICAgICBub3JtX2NsYXNzZXMubWFwKGNscyA9PiB7XG4gICAgICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbi8qKlxuICogUmV0dXJuIGFyZ3VtZW50c1xuICpcbiAqL1xuZXhwb3J0IGNvbnN0IGNsYXNzZXNBcnJheSA9IChhcmdzKSA9PiB7XG4gICAgdmFyIGNsYXNzZXMgPSBbXTtcbiAgICBpdGVyYXRlKGFyZ3MsIChfY2xhc3NlcykgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIF9jbGFzc2VzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgX2NsYXNzZXMgPSBfY2xhc3Nlcy50cmltKCkuc3BsaXQoL1tcXHRcXG5cXGZcXHJcXHNdLyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoX2NsYXNzZXMpKSB7XG4gICAgICAgICAgICBjbGFzc2VzID0gY2xhc3Nlcy5jb25jYXQoX2NsYXNzZXMpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNsYXNzZXMuZmlsdGVyKEJvb2xlYW4pO1xufTtcbi8qKlxuICogQ3JlYXRlIGFuIGFycmF5IGZyb20gYXJnIGlmIGl0J3Mgbm90IGFscmVhZHkgYW4gYXJyYXlcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBjYXN0QXNBcnJheSA9IChhcmcpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICBhcmcgPSBbYXJnXTtcbiAgICB9XG4gICAgcmV0dXJuIGFyZztcbn07XG4vKipcbiAqIEdldCB0aGUgY2xvc2VzdCBub2RlIHRvIHRoZSBldnQudGFyZ2V0IG1hdGNoaW5nIHRoZSBzZWxlY3RvclxuICogU3RvcHMgYXQgd3JhcHBlclxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IHBhcmVudE1hdGNoID0gKHRhcmdldCwgc2VsZWN0b3IsIHdyYXBwZXIpID0+IHtcbiAgICBpZiAod3JhcHBlciAmJiAhd3JhcHBlci5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2hpbGUgKHRhcmdldCAmJiB0YXJnZXQubWF0Y2hlcykge1xuICAgICAgICBpZiAodGFyZ2V0Lm1hdGNoZXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgIH1cbn07XG4vKipcbiAqIEdldCB0aGUgZmlyc3Qgb3IgbGFzdCBpdGVtIGZyb20gYW4gYXJyYXlcbiAqXG4gKiA+IDAgLSByaWdodCAobGFzdClcbiAqIDw9IDAgLSBsZWZ0IChmaXJzdClcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRUYWlsID0gKGxpc3QsIGRpcmVjdGlvbiA9IDApID0+IHtcbiAgICBpZiAoZGlyZWN0aW9uID4gMCkge1xuICAgICAgICByZXR1cm4gbGlzdFtsaXN0Lmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdFswXTtcbn07XG4vKipcbiAqIFJldHVybiB0cnVlIGlmIGFuIG9iamVjdCBpcyBlbXB0eVxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IGlzRW1wdHlPYmplY3QgPSAob2JqKSA9PiB7XG4gICAgcmV0dXJuIChPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMCk7XG59O1xuLyoqXG4gKiBHZXQgdGhlIGluZGV4IG9mIGFuIGVsZW1lbnQgYW1vbmdzdCBzaWJsaW5nIG5vZGVzIG9mIHRoZSBzYW1lIHR5cGVcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBub2RlSW5kZXggPSAoZWwsIGFtb25nc3QpID0+IHtcbiAgICBpZiAoIWVsKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgYW1vbmdzdCA9IGFtb25nc3QgfHwgZWwubm9kZU5hbWU7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChlbCA9IGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpIHtcbiAgICAgICAgaWYgKGVsLm1hdGNoZXMoYW1vbmdzdCkpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaTtcbn07XG4vKipcbiAqIFNldCBhdHRyaWJ1dGVzIG9mIGFuIGVsZW1lbnRcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRBdHRyID0gKGVsLCBhdHRycykgPT4ge1xuICAgIGl0ZXJhdGUoYXR0cnMsICh2YWwsIGF0dHIpID0+IHtcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgJycgKyB2YWwpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuLyoqXG4gKiBSZXBsYWNlIGEgbm9kZVxuICovXG5leHBvcnQgY29uc3QgcmVwbGFjZU5vZGUgPSAoZXhpc3RpbmcsIHJlcGxhY2VtZW50KSA9PiB7XG4gICAgaWYgKGV4aXN0aW5nLnBhcmVudE5vZGUpXG4gICAgICAgIGV4aXN0aW5nLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHJlcGxhY2VtZW50LCBleGlzdGluZyk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFuaWxsYS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=